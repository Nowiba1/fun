<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ULTIMATE ARENA SHOWDOWN</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial Black', 'Arial', sans-serif;
        }
        
        body {
            background: radial-gradient(circle at center, #0a0a2a 0%, #000000 100%);
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* Screen Styles */
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            padding: 20px;
            text-align: center;
        }
        
        .screen.hidden {
            display: none !important;
        }
        
        /* Game Canvas */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* HUD Elements */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .health-bar-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            border-radius: 10px;
            width: 300px;
            height: 30px;
            margin: 10px;
            overflow: hidden;
        }
        
        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #00ff00);
            width: 100%;
            transition: width 0.3s;
        }
        
        .player-info {
            position: absolute;
            top: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid;
            min-width: 250px;
        }
        
        .player-name {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .player-stats {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .ability {
            position: absolute;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #ff9900;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .ability-cooldown {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: conic-gradient(#ff9900 0%, #333 0%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
        }
        
        /* Game Messages */
        #gameMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #ffcc00;
            text-shadow: 0 0 20px #ff0066, 0 0 40px #ff0066;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            text-align: center;
        }
        
        #miniMap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00aaff;
            border-radius: 10px;
            overflow: hidden;
        }
        
        /* Title Styles */
        .title {
            font-size: 4rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff0066, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 0, 102, 0.5);
            animation: titleGlow 2s infinite alternate;
        }
        
        @keyframes titleGlow {
            0% { text-shadow: 0 0 20px rgba(255, 0, 102, 0.5); }
            100% { text-shadow: 0 0 40px rgba(255, 0, 102, 0.8), 0 0 60px rgba(0, 204, 255, 0.5); }
        }
        
        /* Button Styles */
        .btn {
            background: linear-gradient(45deg, #ff0066, #00ccff);
            color: white;
            border: none;
            padding: 20px 40px;
            margin: 15px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.5);
            min-width: 300px;
            text-align: center;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 102, 0.8);
        }
        
        .btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #00ccff, #ff0066);
        }
        
        /* Form Styles */
        .form-group {
            margin: 25px 0;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-size: 1.3rem;
            color: #00ccff;
        }
        
        select, input {
            padding: 15px 25px;
            font-size: 1.2rem;
            border-radius: 25px;
            border: 2px solid #00ccff;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            width: 350px;
            text-align: center;
            outline: none;
        }
        
        /* Game Stats */
        #gameStats {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 15px;
            border: 2px solid #ffcc00;
            display: flex;
            gap: 30px;
            font-size: 1.2rem;
        }
        
        .stat-value {
            color: #ffcc00;
            font-weight: bold;
        }
        
        /* Kill Feed */
        #killFeed {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff0066;
            border-radius: 10px;
            padding: 10px;
        }
        
        .kill-message {
            margin: 5px 0;
            padding: 5px;
            border-radius: 5px;
            background: rgba(255, 0, 102, 0.2);
            font-size: 0.9rem;
        }
        
        /* Power-up Display */
        .power-up {
            position: absolute;
            bottom: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #00ff00;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Controls Display */
        .controls-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ccff;
            font-size: 0.9rem;
            max-width: 300px;
        }
        
        /* Loading Screen */
        .loading-bar {
            width: 400px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            margin: 30px 0;
            overflow: hidden;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #00ccff);
            width: 0%;
            transition: width 0.3s;
            border-radius: 15px;
        }
        
        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 20px;
            z-index: 30;
        }
        
        .mobile-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            user-select: none;
            touch-action: none;
            backdrop-filter: blur(10px);
        }
        
        @media (max-width: 768px) {
            .title { font-size: 2.5rem; }
            .btn { padding: 15px 30px; font-size: 1.2rem; min-width: 250px; }
            select, input { width: 280px; }
            #gameStats { font-size: 1rem; gap: 15px; }
            .player-info { min-width: 200px; }
            #mobileControls { display: flex; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Loading Screen -->
        <div id="loadingScreen" class="screen">
            <h1 class="title">LOADING</h1>
            <div class="loading-bar">
                <div id="loadingProgress" class="loading-progress"></div>
            </div>
            <div id="loadingText">Initializing Game Engine...</div>
        </div>
        
        <!-- Main Menu -->
        <div id="menuScreen" class="screen hidden">
            <h1 class="title">ULTIMATE ARENA SHOWDOWN</h1>
            <p style="font-size: 1.3rem; margin-bottom: 40px; color: #00ccff;">
                Survive the arena, collect upgrades, and become the ultimate champion!
            </p>
            
            <button id="playBtn" class="btn">PLAY NOW</button>
            <button id="howToPlayBtn" class="btn btn-secondary">HOW TO PLAY</button>
            <button id="settingsBtn" class="btn">SETTINGS</button>
            
            <div style="margin-top: 50px; color: #888; font-size: 0.9rem;">
                Use WASD to move • SPACE to jump • MOUSE to aim/shoot • R to reload
            </div>
        </div>
        
        <!-- Game Screen -->
        <div id="gameScreen" class="screen hidden">
            <canvas id="gameCanvas"></canvas>
            <div id="hud"></div>
            <div id="gameStats">
                <div>ROUND: <span id="roundCount" class="stat-value">1</span></div>
                <div>ALIVE: <span id="playersAlive" class="stat-value">4</span>/<span id="totalPlayers" class="stat-value">4</span></div>
                <div>KILLS: <span id="killCount" class="stat-value">0</span></div>
                <div>TIME: <span id="gameTimer" class="stat-value">5:00</span></div>
            </div>
            <div id="killFeed"></div>
            <div id="gameMessage"></div>
        </div>
        
        <!-- Settings Screen -->
        <div id="settingsScreen" class="screen hidden">
            <h1 class="title">SETTINGS</h1>
            
            <div class="form-group">
                <label for="playerName">PLAYER NAME</label>
                <input type="text" id="playerName" value="PLAYER" maxlength="12">
            </div>
            
            <div class="form-group">
                <label for="difficulty">DIFFICULTY</label>
                <select id="difficulty">
                    <option value="easy">EASY</option>
                    <option value="normal" selected>NORMAL</option>
                    <option value="hard">HARD</option>
                    <option value="insane">INSANE</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="botCount">NUMBER OF BOTS (1-7)</label>
                <input type="range" id="botCount" min="1" max="7" value="3">
                <span id="botCountValue">3</span>
            </div>
            
            <div class="form-group">
                <label for="volume">VOLUME</label>
                <input type="range" id="volume" min="0" max="100" value="70">
                <span id="volumeValue">70%</span>
            </div>
            
            <button id="saveSettingsBtn" class="btn">SAVE SETTINGS</button>
            <button id="backToMenuBtn" class="btn btn-secondary">BACK TO MENU</button>
        </div>
        
        <!-- How to Play Screen -->
        <div id="howToPlayScreen" class="screen hidden">
            <h1 class="title">HOW TO PLAY</h1>
            
            <div style="max-width: 800px; text-align: left; margin: 30px 0; line-height: 1.6;">
                <h2 style="color: #00ccff; margin: 20px 0;">OBJECTIVE</h2>
                <p>Be the last player standing in the arena! Eliminate opponents using weapons, collect power-ups, and upgrade your abilities.</p>
                
                <h2 style="color: #00ccff; margin: 20px 0;">CONTROLS</h2>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <div><strong>WASD:</strong> Movement</div>
                    <div><strong>MOUSE:</strong> Aim/Shoot</div>
                    <div><strong>SPACE:</strong> Jump</div>
                    <div><strong>SHIFT:</strong> Sprint</div>
                    <div><strong>R:</strong> Reload</div>
                    <div><strong>1-4:</strong> Switch Weapons</div>
                    <div><strong>E:</strong> Use/Interact</div>
                    <div><strong>Q:</strong> Special Ability</div>
                </div>
                
                <h2 style="color: #00ccff; margin: 20px 0;">POWER-UPS</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="border-left: 4px solid #ff0066; padding-left: 10px;">
                        <strong style="color: #ff0066;">DAMAGE BOOST</strong><br>
                        Increases weapon damage
                    </div>
                    <div style="border-left: 4px solid #00ff00; padding-left: 10px;">
                        <strong style="color: #00ff00;">SPEED BOOST</strong><br>
                        Increases movement speed
                    </div>
                    <div style="border-left: 4px solid #00ccff; padding-left: 10px;">
                        <strong style="color: #00ccff;">HEALTH PACK</strong><br>
                        Restores health
                    </div>
                    <div style="border-left: 4px solid #ffcc00; padding-left: 10px;">
                        <strong style="color: #ffcc00;">SHIELD</strong><br>
                        Temporary damage reduction
                    </div>
                </div>
                
                <h2 style="color: #00ccff; margin: 20px 0;">UPGRADE SYSTEM</h2>
                <p>Eliminate enemies to earn upgrade points. Between rounds, spend points to upgrade:</p>
                <ul style="margin-left: 20px;">
                    <li><strong>HEALTH:</strong> Increase maximum health</li>
                    <li><strong>DAMAGE:</strong> Deal more damage</li>
                    <li><strong>SPEED:</strong> Move faster</li>
                    <li><strong>RELOAD:</strong> Faster reload times</li>
                    <li><strong>SPECIAL ABILITY:</strong> Unique class ability</li>
                </ul>
            </div>
            
            <button id="backFromHowToBtn" class="btn">BACK TO MENU</button>
        </div>
        
        <!-- Upgrade Screen -->
        <div id="upgradeScreen" class="screen hidden">
            <h1 class="title">UPGRADES AVAILABLE!</h1>
            <p style="font-size: 1.5rem; margin-bottom: 30px; color: #ffcc00;">
                Points: <span id="upgradePoints" class="stat-value">0</span>
            </p>
            
            <div id="upgradeOptions" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; max-width: 800px; margin: 30px;">
                <!-- Upgrades will be populated here -->
            </div>
            
            <button id="continueBtn" class="btn" style="margin-top: 30px;">CONTINUE TO NEXT ROUND</button>
        </div>
        
        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="screen hidden">
            <h1 id="gameOverTitle" class="title">GAME OVER</h1>
            <p id="gameOverMessage" style="font-size: 2rem; margin-bottom: 30px; color: #ffcc00;"></p>
            
            <div id="finalStats" style="background: rgba(255, 255, 255, 0.1); padding: 30px; border-radius: 15px; margin: 20px; min-width: 400px;">
                <h2 style="color: #00ccff; margin-bottom: 20px;">FINAL STATISTICS</h2>
                <div id="statsList"></div>
            </div>
            
            <button id="playAgainBtn" class="btn">PLAY AGAIN</button>
            <button id="mainMenuBtn" class="btn btn-secondary">MAIN MENU</button>
        </div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls" class="hidden">
            <div class="mobile-btn" id="mobileMove">↖</div>
            <div class="mobile-btn" id="mobileJump">↑</div>
            <div class="mobile-btn" id="mobileShoot">○</div>
            <div class="mobile-btn" id="mobileReload">R</div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Cannon.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    
    <!-- TWEEN.js for animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    
    <script>
        // ============================
        // GAME CONFIGURATION
        // ============================
        const CONFIG = {
            // Game Settings
            ROUND_TIME: 300, // 5 minutes
            MAX_ROUNDS: 5,
            PLAYER_COUNT: 8,
            UPGRADE_POINTS_PER_KILL: 10,
            
            // Player Settings
            PLAYER_HEALTH: 100,
            PLAYER_SPEED: 15,
            PLAYER_JUMP_FORCE: 12,
            PLAYER_SIZE: 1.5,
            
            // Weapon Settings
            WEAPONS: {
                pistol: { damage: 15, range: 100, fireRate: 0.5, ammo: 12, reloadTime: 1.5 },
                shotgun: { damage: 30, range: 30, fireRate: 1.0, ammo: 6, reloadTime: 2.0 },
                rifle: { damage: 20, range: 150, fireRate: 0.2, ammo: 30, reloadTime: 2.5 },
                rocket: { damage: 50, range: 200, fireRate: 2.0, ammo: 3, reloadTime: 3.0 }
            },
            
            // AI Settings
            AI_DIFFICULTY: {
                easy: { accuracy: 0.3, reaction: 0.8, aggression: 0.4 },
                normal: { accuracy: 0.5, reaction: 0.6, aggression: 0.6 },
                hard: { accuracy: 0.7, reaction: 0.4, aggression: 0.8 },
                insane: { accuracy: 0.9, reaction: 0.2, aggression: 1.0 }
            },
            
            // Arena Settings
            ARENA_SIZE: 100,
            ARENA_HEIGHT: 50,
            
            // Power-up Settings
            POWERUP_SPAWN_RATE: 10, // seconds
            POWERUP_TYPES: ['health', 'damage', 'speed', 'shield', 'ammo']
        };

        // ============================
        // GAME STATE
        // ============================
        let gameState = {
            // Game Flow
            currentScreen: 'loading',
            gameActive: false,
            roundActive: false,
            roundNumber: 1,
            gameTimer: CONFIG.ROUND_TIME,
            playersAlive: 0,
            totalPlayers: CONFIG.PLAYER_COUNT,
            
            // Player State
            players: [],
            localPlayer: null,
            playerUpgrades: {
                health: 0,
                damage: 0,
                speed: 0,
                reload: 0,
                ability: 0
            },
            upgradePoints: 0,
            
            // Game Objects
            bullets: [],
            powerups: [],
            obstacles: [],
            
            // Statistics
            kills: 0,
            damageDealt: 0,
            accuracy: 0,
            shotsFired: 0,
            hits: 0,
            
            // Settings
            playerName: 'PLAYER',
            difficulty: 'normal',
            botCount: 3,
            volume: 0.7,
            
            // References
            world: null,
            scene: null,
            camera: null,
            renderer: null,
            clock: null,
            lastTime: 0
        };

        // ============================
        // THREE.JS SETUP
        // ============================
        let scene, camera, renderer, world;
        let physicsWorld, clock = new THREE.Clock();
        let objectsToUpdate = [];
        let currentWeapon = 'pistol';
        let weaponMeshes = {};
        
        // Input State
        let inputState = {
            // Keyboard
            keys: {
                'w': false, 'a': false, 's': false, 'd': false,
                ' ': false, 'shift': false, 'r': false, 'e': false, 'q': false
            },
            
            // Mouse
            mouse: { x: 0, y: 0, deltaX: 0, deltaY: 0 },
            mouseButtons: { left: false, right: false },
            
            // Mobile Touch
            touch: { left: false, right: false, jump: false, reload: false },
            
            // Gamepad
            gamepad: null,
            
            // Weapon Selection
            weaponSelection: 1 // 1-4
        };

        // ============================
        // INITIALIZATION
        // ============================
        function init() {
            console.log("Initializing Ultimate Arena Showdown...");
            
            // Load settings from localStorage
            loadSettings();
            
            // Set up event listeners
            setupEventListeners();
            
            // Set up Three.js
            initThreeJS();
            
            // Initialize physics
            initPhysics();
            
            // Create arena
            createArena();
            
            // Start game loop
            animate();
            
            // Show menu screen
            setTimeout(() => {
                showScreen('menu');
            }, 500);
        }

        // ============================
        // EVENT LISTENERS
        // ============================
        function setupEventListeners() {
            console.log("Setting up event listeners...");
            
            // Menu Buttons
            document.getElementById('playBtn').addEventListener('click', () => {
                startNewGame();
            });
            
            document.getElementById('howToPlayBtn').addEventListener('click', () => {
                showScreen('howToPlay');
            });
            
            document.getElementById('settingsBtn').addEventListener('click', () => {
                showScreen('settings');
            });
            
            // Settings Screen
            document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
            document.getElementById('backToMenuBtn').addEventListener('click', () => showScreen('menu'));
            document.getElementById('botCount').addEventListener('input', updateSliderValue);
            document.getElementById('volume').addEventListener('input', updateSliderValue);
            
            // How to Play Screen
            document.getElementById('backFromHowToBtn').addEventListener('click', () => showScreen('menu'));
            
            // Upgrade Screen
            document.getElementById('continueBtn').addEventListener('click', continueToNextRound);
            
            // Game Over Screen
            document.getElementById('playAgainBtn').addEventListener('click', startNewGame);
            document.getElementById('mainMenuBtn').addEventListener('click', () => showScreen('menu'));
            
            // Keyboard Input
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                inputState.keys[key] = true;
                
                // Weapon selection (1-4)
                if (key >= '1' && key <= '4') {
                    inputState.weaponSelection = parseInt(key);
                    switchWeapon(parseInt(key));
                }
                
                // Prevent spacebar from scrolling
                if (key === ' ') {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                inputState.keys[key] = false;
            });
            
            // Mouse Input
            document.addEventListener('mousemove', (e) => {
                const rect = renderer.domElement.getBoundingClientRect();
                inputState.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                inputState.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                inputState.mouse.deltaX = e.movementX || 0;
                inputState.mouse.deltaY = e.movementY || 0;
            });
            
            document.addEventListener('mousedown', (e) => {
                if (e.button === 0) inputState.mouseButtons.left = true;
                if (e.button === 2) inputState.mouseButtons.right = true;
            });
            
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) inputState.mouseButtons.left = false;
                if (e.button === 2) inputState.mouseButtons.right = false;
            });
            
            // Prevent right-click menu
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Window Resize
            window.addEventListener('resize', onWindowResize);
            
            // Mobile Touch Events
            setupMobileControls();
            
            console.log("Event listeners set up successfully");
        }

        function setupMobileControls() {
            const mobileBtns = document.querySelectorAll('.mobile-btn');
            mobileBtns.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const id = e.target.id;
                    switch(id) {
                        case 'mobileMove': inputState.touch.left = true; break;
                        case 'mobileShoot': inputState.mouseButtons.left = true; break;
                        case 'mobileJump': inputState.keys[' '] = true; break;
                        case 'mobileReload': inputState.keys['r'] = true; break;
                    }
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const id = e.target.id;
                    switch(id) {
                        case 'mobileMove': inputState.touch.left = false; break;
                        case 'mobileShoot': inputState.mouseButtons.left = false; break;
                        case 'mobileJump': inputState.keys[' '] = false; break;
                        case 'mobileReload': inputState.keys['r'] = false; break;
                    }
                });
            });
        }

        function updateSliderValue(e) {
            const element = e.target;
            const valueElement = document.getElementById(element.id + 'Value');
            if (valueElement) {
                valueElement.textContent = element.value + (element.id === 'volume' ? '%' : '');
            }
        }

        // ============================
        // SCREEN MANAGEMENT
        // ============================
        function showScreen(screenName) {
            console.log(`Showing screen: ${screenName}`);
            
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.add('hidden');
            });
            
            // Show requested screen
            const screenElement = document.getElementById(screenName + 'Screen');
            if (screenElement) {
                screenElement.classList.remove('hidden');
                gameState.currentScreen = screenName;
            }
            
            // Screen-specific setup
            switch(screenName) {
                case 'game':
                    if (!gameState.gameActive) {
                        setupGame();
                    }
                    break;
                case 'upgrade':
                    showUpgradeScreen();
                    break;
            }
        }

        // ============================
        // THREE.JS INITIALIZATION
        // ============================
        function initThreeJS() {
            console.log("Initializing Three.js...");
            
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 200);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 30);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Add hemisphere light for better ambiance
            const hemisphereLight = new THREE.HemisphereLight(0x0000ff, 0xff0000, 0.3);
            scene.add(hemisphereLight);
            
            console.log("Three.js initialized");
        }

        // ============================
        // PHYSICS INITIALIZATION
        // ============================
        function initPhysics() {
            console.log("Initializing Physics...");
            
            // Create Cannon.js world
            physicsWorld = new CANNON.World();
            physicsWorld.gravity.set(0, -9.82, 0);
            physicsWorld.broadphase = new CANNON.NaiveBroadphase();
            physicsWorld.solver.iterations = 10;
            
            console.log("Physics initialized");
        }

        // ============================
        // ARENA CREATION
        // ============================
        function createArena() {
            console.log("Creating arena...");
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(CONFIG.ARENA_SIZE * 2, CONFIG.ARENA_SIZE * 2);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Ground physics body
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Plane()
            });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            physicsWorld.addBody(groundBody);
            
            // Arena walls
            const wallHeight = 20;
            const wallThickness = 2;
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                emissive: 0x222222,
                roughness: 0.7
            });
            
            // Create 4 walls around the arena
            const wallPositions = [
                { x: CONFIG.ARENA_SIZE, y: wallHeight/2, z: 0 },
                { x: -CONFIG.ARENA_SIZE, y: wallHeight/2, z: 0 },
                { x: 0, y: wallHeight/2, z: CONFIG.ARENA_SIZE },
                { x: 0, y: wallHeight/2, z: -CONFIG.ARENA_SIZE }
            ];
            
            wallPositions.forEach((pos, i) => {
                const wallGeometry = new THREE.BoxGeometry(
                    i < 2 ? wallThickness : CONFIG.ARENA_SIZE * 2,
                    wallHeight,
                    i < 2 ? CONFIG.ARENA_SIZE * 2 : wallThickness
                );
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(pos.x, pos.y, pos.z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                
                // Physics body for wall
                const wallBody = new CANNON.Body({
                    mass: 0,
                    shape: new CANNON.Box(new CANNON.Vec3(
                        i < 2 ? wallThickness/2 : CONFIG.ARENA_SIZE,
                        wallHeight/2,
                        i < 2 ? CONFIG.ARENA_SIZE : wallThickness/2
                    ))
                });
                wallBody.position.copy(wall.position);
                physicsWorld.addBody(wallBody);
                objectsToUpdate.push({ mesh: wall, body: wallBody });
            });
            
            // Add obstacles and platforms
            createObstacles();
            
            // Add decorative elements
            createDecorations();
            
            console.log("Arena created");
        }

        function createObstacles() {
            // Add various obstacles for cover and platforming
            const obstacleMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.8
            });
            
            const obstacles = [
                { x: 30, y: 5, z: 30, size: { x: 10, y: 10, z: 10 } },
                { x: -30, y: 5, z: 30, size: { x: 10, y: 10, z: 10 } },
                { x: 30, y: 5, z: -30, size: { x: 10, y: 10, z: 10 } },
                { x: -30, y: 5, z: -30, size: { x: 10, y: 10, z: 10 } },
                { x: 0, y: 10, z: 0, size: { x: 20, y: 20, z: 20 } }, // Central tower
                { x: 50, y: 15, z: 0, size: { x: 5, y: 30, z: 5 } }, // Tall pillar
                { x: -50, y: 15, z: 0, size: { x: 5, y: 30, z: 5 } }, // Tall pillar
            ];
            
            obstacles.forEach((obs, i) => {
                const geometry = new THREE.BoxGeometry(obs.size.x, obs.size.y, obs.size.z);
                const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
                obstacle.position.set(obs.x, obs.y, obs.z);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
                
                // Physics body
                const body = new CANNON.Body({
                    mass: 0,
                    shape: new CANNON.Box(new CANNON.Vec3(obs.size.x/2, obs.size.y/2, obs.size.z/2))
                });
                body.position.copy(obstacle.position);
                physicsWorld.addBody(body);
                objectsToUpdate.push({ mesh: obstacle, body: body });
                
                gameState.obstacles.push(obstacle);
            });
        }

        function createDecorations() {
            // Add some visual flair to the arena
            const colors = [0xff0066, 0x00ccff, 0x00ff00, 0xffcc00];
            
            // Floating orbs
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.SphereGeometry(1 + Math.random() * 2, 8, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    emissive: true,
                    emissiveIntensity: 0.5
                });
                const orb = new THREE.Mesh(geometry, material);
                orb.position.set(
                    (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5,
                    30 + Math.random() * 20,
                    (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5
                );
                scene.add(orb);
                
                // Animate orbs
                const startY = orb.position.y;
                new TWEEN.Tween(orb.position)
                    .to({ y: startY + 10 }, 2000 + Math.random() * 3000)
                    .easing(TWEEN.Easing.Sinusoidal.InOut)
                    .yoyo(true)
                    .repeat(Infinity)
                    .start();
            }
            
            // Floor patterns
            const floorPattern = new THREE.GridHelper(CONFIG.ARENA_SIZE * 2, 20, 0x00ccff, 0x0088aa);
            floorPattern.position.y = 0.1;
            scene.add(floorPattern);
        }

        // ============================
        // GAME SETUP
        // ============================
        function setupGame() {
            console.log("Setting up new game...");
            
            // Reset game state
            gameState.gameActive = true;
            gameState.roundActive = true;
            gameState.roundNumber = 1;
            gameState.gameTimer = CONFIG.ROUND_TIME;
            gameState.players = [];
            gameState.bullets = [];
            gameState.powerups = [];
            gameState.kills = 0;
            gameState.damageDealt = 0;
            gameState.shotsFired = 0;
            gameState.hits = 0;
            gameState.upgradePoints = 0;
            
            // Clear scene
            scene.traverse((object) => {
                if (object.userData && object.userData.type === 'player' || 
                    object.userData && object.userData.type === 'bullet' ||
                    object.userData && object.userData.type === 'powerup') {
                    scene.remove(object);
                    if (object.body) {
                        physicsWorld.removeBody(object.body);
                    }
                }
            });
            
            // Create local player
            createPlayer(true);
            
            // Create AI players
            const botCount = gameState.botCount;
            for (let i = 0; i < botCount; i++) {
                createPlayer(false, i + 1);
            }
            
            // Set up HUD
            updateHUD();
            
            // Start power-up spawner
            startPowerUpSpawner();
            
            console.log("Game setup complete");
        }

        // ============================
        // PLAYER CREATION
        // ============================
        function createPlayer(isLocal, botId = 0) {
            const playerId = gameState.players.length;
            const playerColor = new THREE.Color(
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5
            );
            
            // Player character
            const group = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.8, 1.5, 4, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: playerColor,
                roughness: 0.7,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xffddbb,
                roughness: 0.8
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.2;
            head.castShadow = true;
            group.add(head);
            
            // Arms
            const armGeometry = new THREE.CapsuleGeometry(0.2, 1.2, 4, 4);
            const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArm.position.set(1, 0.5, 0);
            leftArm.castShadow = true;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArm.position.set(-1, 0.5, 0);
            rightArm.castShadow = true;
            group.add(rightArm);
            
            // Weapon
            const weaponGeometry = new THREE.BoxGeometry(1, 0.2, 0.2);
            const weaponMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                metalness: 0.8,
                roughness: 0.2
            });
            const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            weapon.position.set(1.5, 0.8, 0.5);
            group.add(weapon);
            weaponMeshes[playerId] = weapon;
            
            // Position player randomly in arena
            const angle = (playerId / gameState.totalPlayers) * Math.PI * 2;
            const radius = CONFIG.ARENA_SIZE * 0.7;
            const position = {
                x: Math.cos(angle) * radius,
                y: 5,
                z: Math.sin(angle) * radius
            };
            
            group.position.set(position.x, position.y, position.z);
            scene.add(group);
            
            // Physics body
            const shape = new CANNON.Sphere(0.8);
            const bodyPhysics = new CANNON.Body({
                mass: 5,
                shape: shape,
                linearDamping: 0.9,
                angularDamping: 0.9
            });
            bodyPhysics.position.copy(position);
            physicsWorld.addBody(bodyPhysics);
            
            // Player data
            const player = {
                id: playerId,
                name: isLocal ? gameState.playerName : `BOT ${botId}`,
                isLocal: isLocal,
                isAI: !isLocal,
                isAlive: true,
                health: CONFIG.PLAYER_HEALTH + (gameState.playerUpgrades.health * 20),
                maxHealth: CONFIG.PLAYER_HEALTH + (gameState.playerUpgrades.health * 20),
                damageMultiplier: 1 + (gameState.playerUpgrades.damage * 0.2),
                speedMultiplier: 1 + (gameState.playerUpgrades.speed * 0.1),
                reloadMultiplier: 1 - (gameState.playerUpgrades.reload * 0.1),
                
                position: position,
                velocity: new THREE.Vector3(),
                rotation: 0,
                
                weapon: 'pistol',
                ammo: CONFIG.WEAPONS.pistol.ammo,
                maxAmmo: CONFIG.WEAPONS.pistol.ammo,
                reloading: false,
                reloadTimer: 0,
                fireTimer: 0,
                
                physicsBody: bodyPhysics,
                mesh: group,
                weaponMesh: weapon,
                
                stats: {
                    kills: 0,
                    damageDealt: 0,
                    accuracy: 0,
                    shotsFired: 0,
                    hits: 0
                },
                
                // AI specific
                aiState: isLocal ? null : {
                    target: null,
                    state: 'wander',
                    wanderTimer: 0,
                    decisionTimer: 0,
                    lastKnownPlayerPosition: null
                }
            };
            
            gameState.players.push(player);
            
            if (isLocal) {
                gameState.localPlayer = player;
                // Set camera to follow player
                camera.position.set(position.x, position.y + 10, position.z + 15);
            }
            
            objectsToUpdate.push({ mesh: group, body: bodyPhysics });
            
            return player;
        }

        // ============================
        // GAME LOOP
        // ============================
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min(clock.getDelta(), 0.1);
            
            // Update physics
            physicsWorld.step(1/60, deltaTime, 3);
            
            // Update objects with physics
            objectsToUpdate.forEach(obj => {
                if (obj.body && obj.mesh) {
                    obj.mesh.position.copy(obj.body.position);
                    obj.mesh.quaternion.copy(obj.body.quaternion);
                }
            });
            
            // Update game state based on current screen
            switch(gameState.currentScreen) {
                case 'game':
                    if (gameState.roundActive) {
                        updateGame(deltaTime);
                    }
                    break;
            }
            
            // Update TWEEN animations
            TWEEN.update();
            
            // Render scene
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        function updateGame(deltaTime) {
            // Update game timer
            gameState.gameTimer -= deltaTime;
            if (gameState.gameTimer <= 0) {
                gameState.gameTimer = 0;
                endRound();
                return;
            }
            
            // Update players
            gameState.players.forEach((player, index) => {
                if (!player.isAlive) return;
                
                // Update timers
                if (player.reloading) {
                    player.reloadTimer -= deltaTime;
                    if (player.reloadTimer <= 0) {
                        player.reloading = false;
                        player.ammo = player.maxAmmo;
                    }
                }
                
                if (player.fireTimer > 0) {
                    player.fireTimer -= deltaTime;
                }
                
                // Update physics position
                if (player.physicsBody) {
                    player.position.copy(player.physicsBody.position);
                }
                
                // Handle input for local player
                if (player.isLocal) {
                    handlePlayerInput(player, deltaTime);
                } else if (player.isAI) {
                    updateAI(player, deltaTime);
                }
                
                // Update weapon mesh
                if (player.weaponMesh) {
                    player.weaponMesh.lookAt(camera.position);
                }
                
                // Check if player fell off arena
                if (player.position.y < -10) {
                    playerDie(player, null);
                }
            });
            
            // Update bullets
            gameState.bullets.forEach((bullet, index) => {
                bullet.position.add(bullet.velocity.clone().multiplyScalar(deltaTime * 50));
                bullet.mesh.position.copy(bullet.position);
                
                // Check for collisions
                checkBulletCollisions(bullet);
                
                // Remove bullets that are too far
                if (bullet.position.length() > CONFIG.ARENA_SIZE * 2) {
                    scene.remove(bullet.mesh);
                    gameState.bullets.splice(index, 1);
                }
            });
            
            // Update HUD
            updateHUD();
            
            // Update camera to follow local player
            if (gameState.localPlayer && gameState.localPlayer.isAlive) {
                const targetPosition = gameState.localPlayer.position.clone();
                const cameraOffset = new THREE.Vector3(
                    Math.sin(gameState.localPlayer.rotation) * 15,
                    10,
                    Math.cos(gameState.localPlayer.rotation) * 15
                );
                
                camera.position.lerp(targetPosition.clone().add(cameraOffset), deltaTime * 5);
                camera.lookAt(targetPosition.clone().add(new THREE.Vector3(0, 3, 0)));
            }
            
            // Check win condition
            const alivePlayers = gameState.players.filter(p => p.isAlive);
            if (alivePlayers.length <= 1) {
                endRound();
            }
        }

        // ============================
        // INPUT HANDLING
        // ============================
        function handlePlayerInput(player, deltaTime) {
            if (!player.isAlive) return;
            
            const moveSpeed = CONFIG.PLAYER_SPEED * player.speedMultiplier;
            const moveVector = new THREE.Vector3();
            
            // Keyboard movement
            if (inputState.keys['w']) moveVector.z -= 1;
            if (inputState.keys['s']) moveVector.z += 1;
            if (inputState.keys['a']) moveVector.x -= 1;
            if (inputState.keys['d']) moveVector.x += 1;
            
            // Sprinting
            const sprintMultiplier = inputState.keys['shift'] ? 1.5 : 1;
            
            // Normalize diagonal movement
            if (moveVector.length() > 0) {
                moveVector.normalize();
                moveVector.multiplyScalar(moveSpeed * sprintMultiplier * deltaTime);
                
                // Rotate movement vector based on camera direction
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                cameraDirection.y = 0;
                cameraDirection.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(new THREE.Vector3(0, 1, 0), cameraDirection).normalize();
                
                const forwardMovement = cameraDirection.clone().multiplyScalar(moveVector.z);
                const rightMovement = right.clone().multiplyScalar(moveVector.x);
                
                const finalMovement = forwardMovement.add(rightMovement);
                
                // Apply movement to physics body
                player.physicsBody.velocity.x = finalMovement.x * 50;
                player.physicsBody.velocity.z = finalMovement.z * 50;
                
                // Rotate player to face movement direction
                if (finalMovement.length() > 0.1) {
                    player.rotation = Math.atan2(finalMovement.x, finalMovement.z);
                }
            } else {
                // Apply damping when not moving
                player.physicsBody.velocity.x *= 0.9;
                player.physicsBody.velocity.z *= 0.9;
            }
            
            // Jumping
            if (inputState.keys[' '] && Math.abs(player.physicsBody.velocity.y) < 0.1) {
                player.physicsBody.velocity.y = CONFIG.PLAYER_JUMP_FORCE;
            }
            
            // Shooting
            if (inputState.mouseButtons.left && player.fireTimer <= 0 && !player.reloading) {
                if (player.ammo > 0) {
                    shoot(player);
                    player.ammo--;
                    player.fireTimer = CONFIG.WEAPONS[player.weapon].fireRate;
                    
                    if (player.ammo <= 0) {
                        startReload(player);
                    }
                } else {
                    startReload(player);
                }
            }
            
            // Reloading
            if (inputState.keys['r'] && !player.reloading && player.ammo < player.maxAmmo) {
                startReload(player);
            }
            
            // Update player rotation based on mouse
            if (inputState.mouse.deltaX !== 0) {
                player.rotation += inputState.mouse.deltaX * 0.002;
            }
            
            // Reset mouse delta
            inputState.mouse.deltaX = 0;
            inputState.mouse.deltaY = 0;
        }

        // ============================
        // SHOOTING SYSTEM
        // ============================
        function shoot(player) {
            const weapon = CONFIG.WEAPONS[player.weapon];
            const damage = weapon.damage * player.damageMultiplier;
            
            // Create bullet mesh
            const bulletGeometry = new THREE.SphereGeometry(0.2, 4, 4);
            const bulletMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0xff9900,
                emissiveIntensity: 0.5
            });
            const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Calculate direction
            const direction = new THREE.Vector3();
            direction.setFromSphericalCoords(
                1,
                Math.PI / 2 - inputState.mouse.y * 0.5,
                player.rotation + inputState.mouse.x * 2
            );
            
            // Position bullet at player's weapon
            const bulletPosition = player.position.clone().add(new THREE.Vector3(0, 2, 0));
            bulletMesh.position.copy(bulletPosition);
            scene.add(bulletMesh);
            
            // Create bullet object
            const bullet = {
                shooter: player,
                position: bulletPosition,
                velocity: direction.clone().normalize().multiplyScalar(100),
                damage: damage,
                mesh: bulletMesh,
                weaponType: player.weapon
            };
            
            gameState.bullets.push(bullet);
            
            // Update stats
            player.stats.shotsFired++;
            gameState.shotsFired++;
            
            // Visual feedback
            if (player.weaponMesh) {
                player.weaponMesh.scale.set(1.2, 0.8, 1.2);
                new TWEEN.Tween(player.weaponMesh.scale)
                    .to({ x: 1, y: 1, z: 1 }, 100)
                    .start();
            }
            
            // Add recoil
            player.physicsBody.velocity.add(
                new CANNON.Vec3(-direction.x * 2, 0, -direction.z * 2)
            );
        }

        function checkBulletCollisions(bullet) {
            // Check player collisions
            gameState.players.forEach(player => {
                if (!player.isAlive || player === bullet.shooter) return;
                
                const distance = bullet.position.distanceTo(player.position);
                if (distance < 2) { // Hit detection radius
                    // Hit player
                    player.health -= bullet.damage;
                    bullet.shooter.stats.hits++;
                    bullet.shooter.stats.damageDealt += bullet.damage;
                    gameState.hits++;
                    gameState.damageDealt += bullet.damage;
                    
                    // Show hit effect
                    showHitEffect(player.position);
                    
                    // Remove bullet
                    scene.remove(bullet.mesh);
                    gameState.bullets.splice(gameState.bullets.indexOf(bullet), 1);
                    
                    // Check if player died
                    if (player.health <= 0) {
                        playerDie(player, bullet.shooter);
                    }
                    
                    return;
                }
            });
            
            // Check obstacle collisions
            gameState.obstacles.forEach(obstacle => {
                const distance = bullet.position.distanceTo(obstacle.position);
                if (distance < 5) {
                    // Hit obstacle
                    scene.remove(bullet.mesh);
                    gameState.bullets.splice(gameState.bullets.indexOf(bullet), 1);
                    showExplosionEffect(bullet.position);
                }
            });
        }

        function startReload(player) {
            if (player.reloading || player.ammo === player.maxAmmo) return;
            
            player.reloading = true;
            player.reloadTimer = CONFIG.WEAPONS[player.weapon].reloadTime * player.reloadMultiplier;
            
            // Visual feedback
            if (player.weaponMesh) {
                new TWEEN.Tween(player.weaponMesh.rotation)
                    .to({ y: player.weaponMesh.rotation.y + Math.PI * 2 }, player.reloadTimer * 1000)
                    .start();
            }
        }

        function switchWeapon(weaponNumber) {
            const weapons = ['pistol', 'shotgun', 'rifle', 'rocket'];
            if (weaponNumber >= 1 && weaponNumber <= 4) {
                currentWeapon = weapons[weaponNumber - 1];
                if (gameState.localPlayer) {
                    gameState.localPlayer.weapon = currentWeapon;
                    gameState.localPlayer.maxAmmo = CONFIG.WEAPONS[currentWeapon].ammo;
                    
                    // Visual feedback
                    showGameMessage(`Switched to ${currentWeapon.toUpperCase()}`, '#00ccff');
                }
            }
        }

        // ============================
        // AI SYSTEM
        // ============================
        function updateAI(player, deltaTime) {
            if (!player.aiState) return;
            
            const ai = player.aiState;
            const difficulty = CONFIG.AI_DIFFICULTY[gameState.difficulty];
            
            // Update decision timer
            ai.decisionTimer -= deltaTime;
            if (ai.decisionTimer <= 0) {
                makeAIDecision(player);
                ai.decisionTimer = 1 + Math.random() * 2;
            }
            
            // Execute current state
            switch(ai.state) {
                case 'wander':
                    wanderBehavior(player, deltaTime);
                    break;
                case 'chase':
                    chaseBehavior(player, deltaTime);
                    break;
                case 'attack':
                    attackBehavior(player, deltaTime);
                    break;
                case 'flee':
                    fleeBehavior(player, deltaTime);
                    break;
            }
            
            // Update wander timer
            ai.wanderTimer -= deltaTime;
            if (ai.wanderTimer <= 0) {
                ai.wanderTimer = 3 + Math.random() * 5;
                ai.target = null;
            }
        }

        function makeAIDecision(player) {
            const ai = player.aiState;
            const alivePlayers = gameState.players.filter(p => p.isAlive && !p.isAI);
            
            // Find closest player
            let closestPlayer = null;
            let closestDistance = Infinity;
            
            alivePlayers.forEach(target => {
                const distance = player.position.distanceTo(target.position);
                if (distance < closestDistance && distance < 50) {
                    closestDistance = distance;
                    closestPlayer = target;
                }
            });
            
            if (closestPlayer) {
                ai.target = closestPlayer;
                ai.lastKnownPlayerPosition = closestPlayer.position.clone();
                
                // Decide behavior based on distance and health
                if (closestDistance < 20 && player.health > 30) {
                    ai.state = 'attack';
                } else if (closestDistance < 40) {
                    ai.state = 'chase';
                } else if (player.health < 30) {
                    ai.state = 'flee';
                } else {
                    ai.state = 'wander';
                }
            } else {
                ai.state = 'wander';
            }
        }

        function wanderBehavior(player, deltaTime) {
            // Random movement
            if (!player.aiState.wanderDirection || Math.random() < 0.02) {
                player.aiState.wanderDirection = new THREE.Vector3(
                    Math.random() - 0.5,
                    0,
                    Math.random() - 0.5
                ).normalize();
            }
            
            // Apply movement
            const moveSpeed = CONFIG.PLAYER_SPEED * 0.7;
            player.physicsBody.velocity.x = player.aiState.wanderDirection.x * moveSpeed;
            player.physicsBody.velocity.z = player.aiState.wanderDirection.z * moveSpeed;
            
            // Rotate player
            if (player.aiState.wanderDirection.length() > 0) {
                player.rotation = Math.atan2(
                    player.aiState.wanderDirection.x,
                    player.aiState.wanderDirection.z
                );
            }
            
            // Occasionally jump
            if (Math.random() < 0.01 && Math.abs(player.physicsBody.velocity.y) < 0.1) {
                player.physicsBody.velocity.y = CONFIG.PLAYER_JUMP_FORCE * 0.8;
            }
        }

        function chaseBehavior(player, deltaTime) {
            if (!player.aiState.target) return;
            
            const target = player.aiState.target;
            const direction = new THREE.Vector3().subVectors(target.position, player.position);
            direction.y = 0;
            
            if (direction.length() > 2) {
                direction.normalize();
                const moveSpeed = CONFIG.PLAYER_SPEED;
                player.physicsBody.velocity.x = direction.x * moveSpeed;
                player.physicsBody.velocity.z = direction.z * moveSpeed;
                
                // Rotate toward target
                player.rotation = Math.atan2(direction.x, direction.z);
            }
            
            // Try to shoot if in range
            if (direction.length() < 25 && player.fireTimer <= 0 && !player.reloading) {
                if (player.ammo > 0 && Math.random() < 0.8) {
                    aiShoot(player, target);
                } else if (!player.reloading) {
                    startReload(player);
                }
            }
        }

        function attackBehavior(player, deltaTime) {
            if (!player.aiState.target) return;
            
            const target = player.aiState.target;
            const direction = new THREE.Vector3().subVectors(target.position, player.position);
            direction.y = 0;
            
            // Strafe around target
            const distance = direction.length();
            if (distance > 10) {
                direction.normalize();
                player.physicsBody.velocity.x = direction.x * CONFIG.PLAYER_SPEED * 0.5;
                player.physicsBody.velocity.z = direction.z * CONFIG.PLAYER_SPEED * 0.5;
            } else {
                // Strafe perpendicular to target
                const strafeDirection = new THREE.Vector3(-direction.z, 0, direction.x);
                strafeDirection.normalize();
                player.physicsBody.velocity.x = strafeDirection.x * CONFIG.PLAYER_SPEED * 0.7;
                player.physicsBody.velocity.z = strafeDirection.z * CONFIG.PLAYER_SPEED * 0.7;
            }
            
            // Always face target
            player.rotation = Math.atan2(direction.x, direction.z);
            
            // Shoot aggressively
            if (player.fireTimer <= 0 && !player.reloading) {
                if (player.ammo > 0) {
                    aiShoot(player, target);
                } else {
                    startReload(player);
                }
            }
        }

        function fleeBehavior(player, deltaTime) {
            // Find safe direction (away from threats)
            let fleeDirection = new THREE.Vector3();
            
            gameState.players.forEach(other => {
                if (other.isAlive && other !== player) {
                    const direction = new THREE.Vector3().subVectors(player.position, other.position);
                    const distance = direction.length();
                    if (distance < 30) {
                        direction.normalize();
                        fleeDirection.add(direction.multiplyScalar(1 / distance));
                    }
                }
            });
            
            if (fleeDirection.length() === 0) {
                fleeDirection.set(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
            }
            
            fleeDirection.normalize();
            player.physicsBody.velocity.x = fleeDirection.x * CONFIG.PLAYER_SPEED;
            player.physicsBody.velocity.z = fleeDirection.z * CONFIG.PLAYER_SPEED;
            player.rotation = Math.atan2(fleeDirection.x, fleeDirection.z);
            
            // Try to heal
            if (player.health < 50 && Math.random() < 0.1) {
                // AI would look for health packs here
            }
        }

        function aiShoot(player, target) {
            // Simple aiming (could be improved with lead prediction)
            const direction = new THREE.Vector3().subVectors(target.position, player.position);
            direction.normalize();
            
            // Add some inaccuracy based on difficulty
            const difficulty = CONFIG.AI_DIFFICULTY[gameState.difficulty];
            const inaccuracy = (1 - difficulty.accuracy) * 0.2;
            direction.x += (Math.random() - 0.5) * inaccuracy;
            direction.y += (Math.random() - 0.5) * inaccuracy;
            direction.z += (Math.random() - 0.5) * inaccuracy;
            direction.normalize();
            
            // Create bullet
            const bulletGeometry = new THREE.SphereGeometry(0.2, 4, 4);
            const bulletMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.3
            });
            const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bulletMesh.position.copy(player.position.clone().add(new THREE.Vector3(0, 2, 0)));
            scene.add(bulletMesh);
            
            const bullet = {
                shooter: player,
                position: bulletMesh.position.clone(),
                velocity: direction.clone().multiplyScalar(80),
                damage: CONFIG.WEAPONS[player.weapon].damage,
                mesh: bulletMesh,
                weaponType: player.weapon
            };
            
            gameState.bullets.push(bullet);
            player.ammo--;
            player.fireTimer = CONFIG.WEAPONS[player.weapon].fireRate;
            player.stats.shotsFired++;
            
            if (player.ammo <= 0) {
                startReload(player);
            }
        }

        // ============================
        // GAME EVENTS
        // ============================
        function playerDie(player, killer) {
            player.isAlive = false;
            
            // Update killer stats
            if (killer) {
                killer.stats.kills++;
                killer.upgradePoints += CONFIG.UPGRADE_POINTS_PER_KILL;
                gameState.kills++;
                
                // Add kill to feed
                addKillToFeed(killer.name, player.name);
                
                // Show kill message
                if (killer.isLocal) {
                    showGameMessage(`ELIMINATED ${player.name}! +${CONFIG.UPGRADE_POINTS_PER_KILL} POINTS`, '#ffcc00');
                }
            }
            
            // Death animation
            if (player.physicsBody) {
                player.physicsBody.velocity.y = 5;
                player.physicsBody.angularVelocity.set(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                );
                
                // Remove physics body after delay
                setTimeout(() => {
                    if (player.physicsBody) {
                        physicsWorld.removeBody(player.physicsBody);
                    }
                }, 3000);
            }
            
            // Check if local player died
            if (player.isLocal) {
                setTimeout(() => {
                    showGameMessage('YOU DIED!', '#ff0000');
                }, 1000);
            }
        }

        function endRound() {
            gameState.roundActive = false;
            
            // Determine winner
            const alivePlayers = gameState.players.filter(p => p.isAlive);
            let winner = null;
            
            if (alivePlayers.length === 1) {
                winner = alivePlayers[0];
                showGameMessage(`${winner.name} WINS ROUND ${gameState.roundNumber}!`, '#00ff00');
            } else if (alivePlayers.length === 0) {
                showGameMessage('DRAW! NO WINNER', '#ffcc00');
            } else {
                // Time ran out, player with most kills wins
                winner = gameState.players.reduce((a, b) => 
                    (a.stats.kills > b.stats.kills) ? a : b
                );
                showGameMessage(`${winner.name} WINS ON POINTS!`, '#00ccff');
            }
            
            // Give upgrade points to local player
            if (gameState.localPlayer && gameState.localPlayer.isAlive) {
                gameState.upgradePoints += CONFIG.UPGRADE_POINTS_PER_KILL * 2;
            }
            
            // Show upgrade screen after delay
            setTimeout(() => {
                if (gameState.roundNumber < CONFIG.MAX_ROUNDS) {
                    gameState.roundNumber++;
                    showScreen('upgrade');
                } else {
                    gameOver(winner);
                }
            }, 3000);
        }

        function gameOver(winner) {
            gameState.gameActive = false;
            
            // Update game over screen
            const title = document.getElementById('gameOverTitle');
            const message = document.getElementById('gameOverMessage');
            const statsList = document.getElementById('statsList');
            
            if (winner && winner.isLocal) {
                title.textContent = "VICTORY!";
                message.textContent = "YOU ARE THE ULTIMATE CHAMPION!";
            } else if (winner) {
                title.textContent = "DEFEAT";
                message.textContent = `${winner.name} WINS THE TOURNAMENT!`;
            } else {
                title.textContent = "GAME OVER";
                message.textContent = "TOURNAMENT COMPLETE";
            }
            
            // Update stats
            let statsHTML = '';
            gameState.players.forEach(player => {
                const accuracy = player.stats.shotsFired > 0 
                    ? Math.round((player.stats.hits / player.stats.shotsFired) * 100)
                    : 0;
                
                statsHTML += `
                    <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                        <strong style="color: ${player.isLocal ? '#00ccff' : '#ff0066'}">${player.name}</strong>
                        <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                            <span>Kills: ${player.stats.kills}</span>
                            <span>Damage: ${Math.round(player.stats.damageDealt)}</span>
                            <span>Accuracy: ${accuracy}%</span>
                        </div>
                    </div>
                `;
            });
            
            statsList.innerHTML = statsHTML;
            
            showScreen('gameOver');
        }

        function startNewGame() {
            // Reset upgrades
            gameState.playerUpgrades = {
                health: 0,
                damage: 0,
                speed: 0,
                reload: 0,
                ability: 0
            };
            
            // Start game
            showScreen('game');
            setupGame();
        }

        // ============================
        // POWER-UP SYSTEM
        // ============================
        function startPowerUpSpawner() {
            setInterval(() => {
                if (!gameState.roundActive) return;
                
                // Don't spawn too many power-ups
                if (gameState.powerups.length < 5) {
                    spawnPowerUp();
                }
            }, CONFIG.POWERUP_SPAWN_RATE * 1000);
        }

        function spawnPowerUp() {
            const type = CONFIG.POWERUP_TYPES[Math.floor(Math.random() * CONFIG.POWERUP_TYPES.length)];
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5,
                2,
                (Math.random() - 0.5) * CONFIG.ARENA_SIZE * 1.5
            );
            
            // Create power-up mesh
            let geometry, color;
            switch(type) {
                case 'health':
                    geometry = new THREE.OctahedronGeometry(1, 0);
                    color = 0x00ff00;
                    break;
                case 'damage':
                    geometry = new THREE.TetrahedronGeometry(1, 0);
                    color = 0xff0000;
                    break;
                case 'speed':
                    geometry = new THREE.DodecahedronGeometry(1, 0);
                    color = 0x00ccff;
                    break;
                case 'shield':
                    geometry = new THREE.IcosahedronGeometry(1, 0);
                    color = 0xffcc00;
                    break;
                default:
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    color = 0xffffff;
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            scene.add(mesh);
            
            // Add floating animation
            mesh.userData.floatOffset = Math.random() * Math.PI * 2;
            mesh.userData.type = 'powerup';
            
            // Store power-up
            gameState.powerups.push({
                type: type,
                position: position,
                mesh: mesh,
                collected: false
            });
        }

        // ============================
        // UPGRADE SYSTEM
        // ============================
        function showUpgradeScreen() {
            const pointsElement = document.getElementById('upgradePoints');
            const optionsElement = document.getElementById('upgradeOptions');
            
            pointsElement.textContent = gameState.upgradePoints;
            
            const upgrades = [
                {
                    id: 'health',
                    name: 'HEALTH BOOST',
                    description: 'Increase maximum health by 20',
                    cost: 10,
                    currentLevel: gameState.playerUpgrades.health,
                    maxLevel: 5,
                    color: '#00ff00'
                },
                {
                    id: 'damage',
                    name: 'DAMAGE BOOST',
                    description: 'Increase weapon damage by 20%',
                    cost: 15,
                    currentLevel: gameState.playerUpgrades.damage,
                    maxLevel: 5,
                    color: '#ff0000'
                },
                {
                    id: 'speed',
                    name: 'SPEED BOOST',
                    description: 'Increase movement speed by 10%',
                    cost: 8,
                    currentLevel: gameState.playerUpgrades.speed,
                    maxLevel: 5,
                    color: '#00ccff'
                },
                {
                    id: 'reload',
                    name: 'FAST RELOAD',
                    description: 'Decrease reload time by 10%',
                    cost: 12,
                    currentLevel: gameState.playerUpgrades.reload,
                    maxLevel: 5,
                    color: '#ffcc00'
                },
                {
                    id: 'ability',
                    name: 'SPECIAL ABILITY',
                    description: 'Unlock powerful special ability',
                    cost: 25,
                    currentLevel: gameState.playerUpgrades.ability,
                    maxLevel: 1,
                    color: '#ff00ff'
                }
            ];
            
            let optionsHTML = '';
            upgrades.forEach(upgrade => {
                const canBuy = gameState.upgradePoints >= upgrade.cost && upgrade.currentLevel < upgrade.maxLevel;
                const buttonClass = canBuy ? '' : 'disabled';
                
                optionsHTML += `
                    <div style="background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; border-left: 5px solid ${upgrade.color}">
                        <h3 style="color: ${upgrade.color}; margin-bottom: 10px;">${upgrade.name}</h3>
                        <p style="margin-bottom: 15px; color: #ccc;">${upgrade.description}</p>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="color: #ffcc00;">Cost: ${upgrade.cost} points</span><br>
                                <span style="color: #00ccff;">Level: ${upgrade.currentLevel}/${upgrade.maxLevel}</span>
                            </div>
                            <button onclick="buyUpgrade('${upgrade.id}', ${upgrade.cost})" 
                                    style="background: ${canBuy ? upgrade.color : '#666'}; 
                                           color: white; 
                                           border: none; 
                                           padding: 10px 20px; 
                                           border-radius: 5px; 
                                           cursor: ${canBuy ? 'pointer' : 'not-allowed'};"
                                    ${!canBuy ? 'disabled' : ''}>
                                ${upgrade.currentLevel >= upgrade.maxLevel ? 'MAXED' : 'UPGRADE'}
                            </button>
                        </div>
                    </div>
                `;
            });
            
            optionsElement.innerHTML = optionsHTML;
        }

        function buyUpgrade(id, cost) {
            if (gameState.upgradePoints >= cost && gameState.playerUpgrades[id] < 5) {
                gameState.upgradePoints -= cost;
                gameState.playerUpgrades[id]++;
                
                // Apply upgrade to local player
                if (gameState.localPlayer) {
                    switch(id) {
                        case 'health':
                            gameState.localPlayer.maxHealth += 20;
                            gameState.localPlayer.health = gameState.localPlayer.maxHealth;
                            break;
                        case 'damage':
                            gameState.localPlayer.damageMultiplier += 0.2;
                            break;
                        case 'speed':
                            gameState.localPlayer.speedMultiplier += 0.1;
                            break;
                        case 'reload':
                            gameState.localPlayer.reloadMultiplier -= 0.1;
                            break;
                        case 'ability':
                            // Unlock special ability
                            showGameMessage('SPECIAL ABILITY UNLOCKED! PRESS Q TO USE', '#ff00ff');
                            break;
                    }
                }
                
                // Update display
                showUpgradeScreen();
            }
        }

        function continueToNextRound() {
            // Reset players for next round
            gameState.players.forEach(player => {
                if (player.isAlive) {
                    player.health = player.maxHealth;
                    player.ammo = player.maxAmmo;
                    player.reloading = false;
                    
                    // Reset position
                    const angle = Math.random() * Math.PI * 2;
                    const radius = CONFIG.ARENA_SIZE * 0.7;
                    player.physicsBody.position.set(
                        Math.cos(angle) * radius,
                        5,
                        Math.sin(angle) * radius
                    );
                    player.physicsBody.velocity.set(0, 0, 0);
                }
            });
            
            // Reset game timer
            gameState.gameTimer = CONFIG.ROUND_TIME;
            gameState.roundActive = true;
            
            showScreen('game');
            showGameMessage(`ROUND ${gameState.roundNumber} START!`, '#ffcc00');
        }

        // ============================
        // VISUAL EFFECTS
        // ============================
        function showHitEffect(position) {
            const geometry = new THREE.SphereGeometry(2, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.5
            });
            const effect = new THREE.Mesh(geometry, material);
            effect.position.copy(position);
            scene.add(effect);
            
            // Animate and remove
            new TWEEN.Tween(effect.scale)
                .to({ x: 3, y: 3, z: 3 }, 300)
                .start();
            
            new TWEEN.Tween(effect.material)
                .to({ opacity: 0 }, 300)
                .onComplete(() => scene.remove(effect))
                .start();
        }

        function showExplosionEffect(position) {
            // Create explosion particles
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.SphereGeometry(0.2, 4, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xff9900 : 0xff0000
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                // Random velocity
                const velocity = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize().multiplyScalar(10);
                
                scene.add(particle);
                
                // Animate particle
                new TWEEN.Tween(particle.position)
                    .to({
                        x: position.x + velocity.x,
                        y: position.y + velocity.y,
                        z: position.z + velocity.z
                    }, 1000)
                    .start();
                
                new TWEEN.Tween(particle.material)
                    .to({ opacity: 0 }, 1000)
                    .onComplete(() => scene.remove(particle))
                    .start();
            }
        }

        function showGameMessage(text, color = '#ffffff') {
            const element = document.getElementById('gameMessage');
            element.textContent = text;
            element.style.color = color;
            element.style.opacity = 1;
            
            // Hide after delay
            setTimeout(() => {
                element.style.opacity = 0;
            }, 3000);
        }

        function addKillToFeed(killer, victim) {
            const feed = document.getElementById('killFeed');
            const message = document.createElement('div');
            message.className = 'kill-message';
            message.textContent = `${killer} eliminated ${victim}`;
            feed.insertBefore(message, feed.firstChild);
            
            // Keep only last 5 messages
            while (feed.children.length > 5) {
                feed.removeChild(feed.lastChild);
            }
        }

        // ============================
        // HUD UPDATE
        // ============================
        function updateHUD() {
            const hud = document.getElementById('hud');
            let hudHTML = '';
            
            // Update game stats
            document.getElementById('playersAlive').textContent = 
                gameState.players.filter(p => p.isAlive).length;
            document.getElementById('killCount').textContent = gameState.kills;
            
            // Update timer
            const minutes = Math.floor(gameState.gameTimer / 60);
            const seconds = Math.floor(gameState.gameTimer % 60);
            document.getElementById('gameTimer').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Create local player HUD if exists
            if (gameState.localPlayer && gameState.localPlayer.isAlive) {
                const player = gameState.localPlayer;
                const healthPercent = (player.health / player.maxHealth) * 100;
                const accuracy = player.stats.shotsFired > 0 
                    ? Math.round((player.stats.hits / player.stats.shotsFired) * 100)
                    : 0;
                
                hudHTML = `
                    <div class="player-info" style="left: 20px; border-color: #00ccff;">
                        <div class="player-name" style="color: #00ccff;">${player.name}</div>
                        <div class="health-bar-container">
                            <div class="health-bar" style="width: ${healthPercent}%"></div>
                        </div>
                        <div class="player-stats">
                            <div class="stat">HP: ${Math.round(player.health)}/${player.maxHealth}</div>
                            <div class="stat">ACC: ${accuracy}%</div>
                            <div class="stat">KILLS: ${player.stats.kills}</div>
                        </div>
                    </div>
                    
                    <div class="ability" style="left: 20px; bottom: 100px;">
                        <div>WEAPON</div>
                        <div class="ability-cooldown" style="background: conic-gradient(#ff9900 ${(player.ammo/player.maxAmmo)*100}%, #333 ${(player.ammo/player.maxAmmo)*100}%)">
                            ${player.ammo}/${player.maxAmmo}
                        </div>
                        <div>${player.weapon.toUpperCase()}</div>
                        ${player.reloading ? `<div>RELOADING...</div>` : ''}
                    </div>
                    
                    <div class="ability" style="left: 120px; bottom: 100px;">
                        <div>SPECIAL</div>
                        <div class="ability-cooldown">Q</div>
                        <div>READY</div>
                    </div>
                `;
            }
            
            hud.innerHTML = hudHTML;
        }

        // ============================
        // SETTINGS MANAGEMENT
        // ============================
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('arenaShowdownSettings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    gameState.playerName = settings.playerName || 'PLAYER';
                    gameState.difficulty = settings.difficulty || 'normal';
                    gameState.botCount = settings.botCount || 3;
                    gameState.volume = settings.volume || 0.7;
                    
                    // Update UI
                    document.getElementById('playerName').value = gameState.playerName;
                    document.getElementById('difficulty').value = gameState.difficulty;
                    document.getElementById('botCount').value = gameState.botCount;
                    document.getElementById('botCountValue').textContent = gameState.botCount;
                    document.getElementById('volume').value = gameState.volume * 100;
                    document.getElementById('volumeValue').textContent = Math.round(gameState.volume * 100) + '%';
                }
            } catch (e) {
                console.log("No saved settings found");
            }
        }

        function saveSettings() {
            gameState.playerName = document.getElementById('playerName').value;
            gameState.difficulty = document.getElementById('difficulty').value;
            gameState.botCount = parseInt(document.getElementById('botCount').value);
            gameState.volume = parseInt(document.getElementById('volume').value) / 100;
            
            const settings = {
                playerName: gameState.playerName,
                difficulty: gameState.difficulty,
                botCount: gameState.botCount,
                volume: gameState.volume
            };
            
            localStorage.setItem('arenaShowdownSettings', JSON.stringify(settings));
            
            showGameMessage('SETTINGS SAVED', '#00ff00');
            setTimeout(() => {
                showScreen('menu');
            }, 1000);
        }

        // ============================
        // UTILITY FUNCTIONS
        // ============================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================
        // START GAME
        // ============================
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Game loading...");
            
            // Simulate loading progress
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 20;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(interval);
                    setTimeout(init, 500);
                }
                
                document.getElementById('loadingProgress').style.width = progress + '%';
                document.getElementById('loadingText').textContent = 
                    progress < 30 ? 'Loading assets...' :
                    progress < 60 ? 'Initializing physics...' :
                    progress < 90 ? 'Setting up arena...' :
                    'Ready!';
            }, 100);
        });
        
        // Make functions available globally for button clicks
        window.buyUpgrade = buyUpgrade;
    </script>
</body>
</html>
