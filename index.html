<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Riders: Delivery Chaos - NEXT LEVEL</title>
    <!-- Babylon.js Core -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <!-- Havok Physics -->
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_es.js"></script>
    <!-- Post-processing effects -->
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            overflow: hidden;
            background: #0a0a14;
            color: #fff;
        }
        
        #renderCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            outline: none;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .hud-container {
            position: absolute;
            top: 25px;
            left: 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .hud-panel {
            background: linear-gradient(135deg, rgba(20, 20, 30, 0.85), rgba(40, 40, 60, 0.85));
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ff6b00;
            box-shadow: 0 8px 32px rgba(255, 107, 0, 0.2);
            backdrop-filter: blur(10px);
            min-width: 280px;
            transition: all 0.3s ease;
        }
        
        .hud-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(255, 107, 0, 0.3);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-label {
            color: #a0a0c0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            color: #ff6b00;
            font-size: 22px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 107, 0, 0.5);
        }
        
        .stat-unit {
            color: #ffb866;
            font-size: 12px;
            margin-left: 4px;
        }
        
        #productsPanel {
            border-color: #00ff88;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.2);
        }
        
        #productsPanel:hover {
            box-shadow: 0 12px 40px rgba(0, 255, 136, 0.3);
        }
        
        .products-display {
            text-align: center;
            padding: 20px;
        }
        
        .products-count {
            font-size: 56px;
            font-weight: 900;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
            margin: 10px 0;
        }
        
        .products-label {
            color: #a0ffd0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .speedometer {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 180px;
            height: 180px;
        }
        
        .speed-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(20, 20, 30, 0.9), rgba(10, 10, 20, 0.95));
            border: 4px solid #ff6b00;
            box-shadow: 0 0 40px rgba(255, 107, 0, 0.4);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .speed-value {
            font-size: 42px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }
        
        .speed-label {
            color: #ffb866;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 5px;
        }
        
        .bot-indicator {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 50, 50, 0.9), rgba(180, 0, 0, 0.9));
            padding: 15px 30px;
            border-radius: 25px;
            border: 2px solid #ff3333;
            box-shadow: 0 0 30px rgba(255, 50, 50, 0.6);
            display: flex;
            align-items: center;
            gap: 15px;
            backdrop-filter: blur(10px);
        }
        
        .bot-icon {
            font-size: 24px;
            animation: pulse 2s infinite;
        }
        
        .bot-count {
            font-size: 28px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .controls-panel {
            position: absolute;
            bottom: 40px;
            left: 40px;
            background: rgba(20, 20, 30, 0.8);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #444466;
            max-width: 320px;
            backdrop-filter: blur(10px);
        }
        
        .controls-title {
            color: #ff6b00;
            font-size: 18px;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-key {
            background: linear-gradient(135deg, #333355, #222244);
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid #555588;
            color: #fff;
            font-weight: 600;
            min-width: 100px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(10, 10, 20, 0.95), rgba(5, 5, 15, 0.98));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: all;
        }
        
        .screen-title {
            font-size: 64px;
            font-weight: 900;
            color: #ff6b00;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 0 0 30px rgba(255, 107, 0, 0.8);
            background: linear-gradient(45deg, #ff6b00, #ffa500);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .screen-subtitle {
            font-size: 24px;
            color: #a0a0c0;
            margin-bottom: 50px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
        }
        
        .button-container {
            display: flex;
            gap: 25px;
            margin-top: 30px;
        }
        
        .game-button {
            background: linear-gradient(135deg, #ff6b00, #ff8533);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(255, 107, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .game-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(255, 107, 0, 0.6);
        }
        
        .game-button:active {
            transform: translateY(-2px);
        }
        
        .secondary-button {
            background: linear-gradient(135deg, #333355, #444477);
            box-shadow: 0 8px 25px rgba(51, 51, 85, 0.4);
        }
        
        .secondary-button:hover {
            box-shadow: 0 15px 35px rgba(51, 51, 85, 0.6);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin: 40px 0;
            background: rgba(30, 30, 45, 0.7);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #444466;
        }
        
        .stat-card {
            text-align: center;
            padding: 20px;
            background: rgba(40, 40, 60, 0.8);
            border-radius: 10px;
            border: 1px solid #555588;
        }
        
        .stat-card-value {
            font-size: 36px;
            font-weight: 900;
            color: #ff6b00;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 107, 0, 0.5);
        }
        
        .hidden {
            display: none !important;
        }
        
        #loadingScreen {
            z-index: 300;
        }
        
        .loading-bar-container {
            width: 400px;
            height: 12px;
            background: rgba(40, 40, 60, 0.8);
            border-radius: 6px;
            overflow: hidden;
            margin: 40px 0;
            border: 1px solid #555588;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b00, #ffa500);
            width: 0%;
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.7);
        }
        
        .loading-text {
            color: #a0a0c0;
            font-size: 16px;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .road-line {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, transparent, #ffff00, transparent);
            animation: roadFlow 1s linear infinite;
        }
        
        @keyframes roadFlow {
            0% { background-position: -200px 0; }
            100% { background-position: 200px 0; }
        }
        
        #boostBar {
            position: absolute;
            top: 25px;
            right: 25px;
            width: 200px;
            height: 15px;
            background: rgba(40, 40, 60, 0.8);
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #ff6b00;
        }
        
        #boostFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ff88, #00ffcc);
            border-radius: 6px;
            transition: width 0.2s ease;
        }
        
        .boost-label {
            position: absolute;
            top: -25px;
            right: 0;
            color: #00ff88;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .collision-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: #ff3333;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 40px rgba(255, 50, 50, 0.8);
        }
        
        .lane-indicator {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        .lane-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .lane-dot.active {
            background: #ff6b00;
            border-color: #ffa500;
            box-shadow: 0 0 15px rgba(255, 107, 0, 0.8);
            transform: scale(1.3);
        }
    </style>
</head>
<body>
    <!-- Babylon.js Canvas -->
    <canvas id="renderCanvas"></canvas>
    
    <!-- Game UI -->
    <div id="ui">
        <!-- Left HUD Panel -->
        <div class="hud-container">
            <div class="hud-panel" id="statsPanel">
                <div class="stat-row">
                    <span class="stat-label">Score</span>
                    <span class="stat-value" id="scoreValue">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Distance</span>
                    <span class="stat-value" id="distanceValue">0<span class="stat-unit">m</span></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Time</span>
                    <span class="stat-value" id="timeValue">00:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Active Bots</span>
                    <span class="stat-value" id="botCountValue">0</span>
                </div>
            </div>
            
            <div class="hud-panel" id="productsPanel">
                <div class="products-display">
                    <div class="products-count" id="productsValue">10</div>
                    <div class="products-label">Products Remaining</div>
                </div>
            </div>
        </div>
        
        <!-- Speedometer -->
        <div class="speedometer">
            <div class="speed-circle">
                <div class="speed-value" id="speedValue">0</div>
                <div class="speed-label">km/h</div>
            </div>
        </div>
        
        <!-- Bot Indicator -->
        <div class="bot-indicator" id="botIndicator">
            <span class="bot-icon">ü§ñ</span>
            <span class="bot-count" id="botCount">0</span>
            <span>Bots Chasing</span>
        </div>
        
        <!-- Boost Bar -->
        <div id="boostBar">
            <div class="boost-label">Boost</div>
            <div id="boostFill"></div>
        </div>
        
        <!-- Lane Indicator -->
        <div class="lane-indicator">
            <div class="lane-dot" id="laneLeft"></div>
            <div class="lane-dot" id="laneCenter"></div>
            <div class="lane-dot" id="laneRight"></div>
        </div>
        
        <!-- Controls Panel -->
        <div class="controls-panel">
            <div class="controls-title">Controls</div>
            <div class="control-item">
                <span>Accelerate</span>
                <span class="control-key">W / ‚Üë</span>
            </div>
            <div class="control-item">
                <span>Brake/Reverse</span>
                <span class="control-key">S / ‚Üì</span>
            </div>
            <div class="control-item">
                <span>Move Left</span>
                <span class="control-key">A / ‚Üê</span>
            </div>
            <div class="control-item">
                <span>Move Right</span>
                <span class="control-key">D / ‚Üí</span>
            </div>
            <div class="control-item">
                <span>Boost</span>
                <span class="control-key">SPACE</span>
            </div>
            <div class="control-item">
                <span>Pause</span>
                <span class="control-key">ESC / P</span>
            </div>
        </div>
        
        <!-- Collision Warning -->
        <div class="collision-warning" id="collisionWarning">‚ö†</div>
    </div>
    
    <!-- Loading Screen -->
    <div id="loadingScreen" class="screen-overlay">
        <h1 class="screen-title">CART RIDERS</h1>
        <h2 class="screen-subtitle">Delivery Chaos - Next Level Edition</h2>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing Advanced Engine...</div>
    </div>
    
    <!-- Pause Screen -->
    <div id="pauseScreen" class="screen-overlay hidden">
        <h1 class="screen-title">GAME PAUSED</h1>
        <h2 class="screen-subtitle">Delivery chaos is temporarily suspended. Ready to continue?</h2>
        <div class="button-container">
            <button id="resumeButton" class="game-button">Resume Delivery</button>
            <button id="restartButton" class="game-button secondary-button">Restart Run</button>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen-overlay hidden">
        <h1 class="screen-title">DELIVERY FAILED!</h1>
        <h2 class="screen-subtitle">All products destroyed. The bots have won this round.</h2>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-card-value" id="finalScore">0</div>
                <div class="stat-label">Final Score</div>
            </div>
            <div class="stat-card">
                <div class="stat-card-value" id="finalDistance">0m</div>
                <div class="stat-label">Distance Traveled</div>
            </div>
            <div class="stat-card">
                <div class="stat-card-value" id="finalTime">00:00</div>
                <div class="stat-label">Survival Time</div>
            </div>
            <div class="stat-card">
                <div class="stat-card-value" id="finalBots">0</div>
                <div class="stat-label">Bots Defeated</div>
            </div>
        </div>
        
        <div class="button-container">
            <button id="playAgainButton" class="game-button">Make Another Delivery</button>
        </div>
    </div>

    <script>
        // Game Constants
        const GAME_CONFIG = {
            ROAD: {
                WIDTH: 15,
                LANE_WIDTH: 5,
                SEGMENT_LENGTH: 40,
                VISIBLE_SEGMENTS: 60,
                CURVE_INTENSITY: 0.4,
                HILL_INTENSITY: 8,
                BANK_INTENSITY: 0.3
            },
            PLAYER: {
                START_LANE: 1, // 0: left, 1: center, 2: right
                START_PRODUCTS: 10,
                BASE_SPEED: 40,
                MAX_SPEED: 120,
                ACCELERATION: 1.2,
                DECELERATION: 0.8,
                BOOST_MULTIPLIER: 1.8,
                BOOST_CAPACITY: 100,
                BOOST_DRAIN_RATE: 25,
                BOOST_RECHARGE_RATE: 15,
                LANE_CHANGE_SPEED: 0.2
            },
            AI: {
                SPAWN_SCORE_INTERVAL: 750,
                MIN_SPEED: 25,
                MAX_SPEED: 80,
                AGGRESSION_LEVELS: [0.3, 0.6, 0.9],
                MISTAKE_PROBABILITY: 0.02,
                REACTION_TIME: 0.5
            },
            WORLD: {
                BUILDING_SPACING: 30,
                MAX_BUILDINGS: 50,
                FOG_DENSITY: 0.1,
                VIEW_DISTANCE: 800
            },
            PHYSICS: {
                GRAVITY: -9.81,
                COLLISION_FORCE: 2.5,
                BOUNCE_FACTOR: 0.3
            }
        };

        // Game State
        let gameState = 'LOADING';
        let gameTime = 0;
        let score = 0;
        let distance = 0;
        let activeBots = 0;
        let nextBotScore = GAME_CONFIG.AI.SPAWN_SCORE_INTERVAL;
        
        // Babylon.js Variables
        let engine, scene, camera, canvas;
        let player, roadManager, buildingManager, botManager, uiManager;
        let havokInstance, physicsPlugin;
        
        // Input State
        const input = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            boost: false,
            lane: GAME_CONFIG.PLAYER.START_LANE,
            targetLane: GAME_CONFIG.PLAYER.START_LANE
        };

        // DOM Elements
        const dom = {
            loadingScreen: document.getElementById('loadingScreen'),
            loadingBar: document.getElementById('loadingBar'),
            loadingText: document.getElementById('loadingText'),
            pauseScreen: document.getElementById('pauseScreen'),
            gameOverScreen: document.getElementById('gameOverScreen'),
            scoreValue: document.getElementById('scoreValue'),
            distanceValue: document.getElementById('distanceValue'),
            timeValue: document.getElementById('timeValue'),
            botCountValue: document.getElementById('botCountValue'),
            productsValue: document.getElementById('productsValue'),
            speedValue: document.getElementById('speedValue'),
            botIndicator: document.getElementById('botIndicator'),
            botCount: document.getElementById('botCount'),
            boostFill: document.getElementById('boostFill'),
            collisionWarning: document.getElementById('collisionWarning'),
            laneLeft: document.getElementById('laneLeft'),
            laneCenter: document.getElementById('laneCenter'),
            laneRight: document.getElementById('laneRight'),
            resumeButton: document.getElementById('resumeButton'),
            restartButton: document.getElementById('restartButton'),
            playAgainButton: document.getElementById('playAgainButton'),
            finalScore: document.getElementById('finalScore'),
            finalDistance: document.getElementById('finalDistance'),
            finalTime: document.getElementById('finalTime'),
            finalBots: document.getElementById('finalBots')
        };

        // Initialize the Game
        async function initGame() {
            updateLoadingProgress(10, 'Initializing Babylon.js Engine...');
            
            // Get canvas and create engine
            canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true
            });
            
            updateLoadingProgress(20, 'Creating Scene...');
            
            // Create scene
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1.0);
            
            // Enable physics
            updateLoadingProgress(30, 'Initializing Physics Engine...');
            await initPhysics();
            
            updateLoadingProgress(40, 'Setting Up Lighting...');
            setupLighting();
            
            updateLoadingProgress(50, 'Creating Environment...');
            setupEnvironment();
            
            updateLoadingProgress(60, 'Creating Road System...');
            roadManager = new RoadManager();
            
            updateLoadingProgress(70, 'Creating Building System...');
            buildingManager = new BuildingManager();
            
            updateLoadingProgress(80, 'Creating Player...');
            player = new Player();
            
            updateLoadingProgress(90, 'Initializing AI System...');
            botManager = new BotManager();
            
            updateLoadingProgress(95, 'Setting Up Camera...');
            setupCamera();
            
            updateLoadingProgress(100, 'Finalizing Setup...');
            
            // Setup post-processing
            setupPostProcessing();
            
            // Setup event listeners
            setupEventListeners();
            
            // Start game loop
            engine.runRenderLoop(() => {
                if (gameState === 'PLAYING') {
                    const deltaTime = engine.getDeltaTime() / 1000;
                    updateGame(deltaTime);
                }
                scene.render();
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
            
            // Hide loading screen and start game
            setTimeout(() => {
                dom.loadingScreen.classList.add('hidden');
                startGame();
            }, 1000);
        }

        // Initialize Physics
        async function initPhysics() {
            try {
                // Initialize Havok physics
                havokInstance = await HavokPhysics();
                physicsPlugin = new BABYLON.HavokPlugin(true, havokInstance);
                scene.enablePhysics(new BABYLON.Vector3(0, GAME_CONFIG.PHYSICS.GRAVITY, 0), physicsPlugin);
            } catch (error) {
                console.warn('Havok physics failed, falling back to default physics');
                scene.enablePhysics(new BABYLON.Vector3(0, GAME_CONFIG.PHYSICS.GRAVITY, 0));
            }
        }

        // Setup Lighting
        function setupLighting() {
            // Hemispheric light (sky light)
            const hemiLight = new BABYLON.HemisphericLight(
                'hemiLight',
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemiLight.intensity = 0.6;
            hemiLight.groundColor = new BABYLON.Color3(0.1, 0.1, 0.2);
            hemiLight.specular = new BABYLON.Color3(0, 0, 0);
            
            // Directional light (sun)
            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-1, -2, -1),
                scene
            );
            dirLight.position = new BABYLON.Vector3(20, 40, 20);
            dirLight.intensity = 0.8;
            dirLight.shadowEnabled = true;
            
            // Shadow generator
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, dirLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurScale = 2;
            shadowGenerator.setDarkness(0.4);
            
            // Fog
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = GAME_CONFIG.WORLD.FOG_DENSITY;
            scene.fogColor = new BABYLON.Color3(0.05, 0.05, 0.1);
        }

        // Setup Environment
        function setupEnvironment() {
            // Skybox
            const skybox = BABYLON.MeshBuilder.CreateBox('skybox', { size: 1000 }, scene);
            const skyboxMaterial = new BABYLON.StandardMaterial('skyboxMaterial', scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
                'https://assets.babylonjs.com/textures/skybox',
                scene
            );
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;
            
            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround(
                'ground',
                { width: 1000, height: 1000 },
                scene
            );
            const groundMaterial = new BABYLON.StandardMaterial('groundMaterial', scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture(
                'https://assets.babylonjs.com/textures/grass.png',
                scene
            );
            groundMaterial.diffuseTexture.uScale = 100;
            groundMaterial.diffuseTexture.vScale = 100;
            groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            ground.material = groundMaterial;
            ground.receiveShadows = true;
            
            // Enable physics for ground
            ground.physicsImpostor = new BABYLON.PhysicsImpostor(
                ground,
                BABYLON.PhysicsImpostor.BoxImpostor,
                { mass: 0, restitution: 0.1 },
                scene
            );
        }

        // Road Manager Class
        class RoadManager {
            constructor() {
                this.segments = [];
                this.currentIndex = 0;
                this.noiseOffset = Math.random() * 1000;
                this.generateInitialRoad();
            }
            
            generateInitialRoad() {
                for (let i = 0; i < GAME_CONFIG.ROAD.VISIBLE_SEGMENTS; i++) {
                    this.createSegment(i);
                }
            }
            
            createSegment(index) {
                const z = index * GAME_CONFIG.ROAD.SEGMENT_LENGTH;
                
                // Use noise for natural curves and hills
                const noiseX = this.simplexNoise(this.noiseOffset + z * 0.01, 0);
                const noiseY = this.simplexNoise(this.noiseOffset + 1000 + z * 0.005, 0);
                const noiseZ = this.simplexNoise(this.noiseOffset + 2000 + z * 0.02, 0);
                
                const curve = noiseX * GAME_CONFIG.ROAD.CURVE_INTENSITY;
                const elevation = noiseY * GAME_CONFIG.ROAD.HILL_INTENSITY;
                const bank = noiseZ * GAME_CONFIG.ROAD.BANK_INTENSITY;
                
                // Create road segment
                const segment = BABYLON.MeshBuilder.CreateBox(
                    `road_${index}`,
                    {
                        width: GAME_CONFIG.ROAD.WIDTH,
                        height: 0.2,
                        depth: GAME_CONFIG.ROAD.SEGMENT_LENGTH
                    },
                    scene
                );
                
                segment.position = new BABYLON.Vector3(curve * 50, elevation, z);
                segment.rotation.x = bank;
                segment.rotation.y = curve;
                
                // Road material
                const roadMaterial = new BABYLON.StandardMaterial(`roadMat_${index}`, scene);
                roadMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                roadMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                
                // Add lane markings using decals
                this.addLaneMarkings(segment, elevation);
                
                segment.material = roadMaterial;
                segment.receiveShadows = true;
                
                // Add physics
                segment.physicsImpostor = new BABYLON.PhysicsImpostor(
                    segment,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 0.2 },
                    scene
                );
                
                // Store segment data
                this.segments[index] = {
                    mesh: segment,
                    index,
                    z,
                    curve,
                    elevation,
                    bank
                };
                
                // Occasionally add obstacles
                if (Math.random() < 0.1 && index > 10) {
                    this.addRoadObstacle(segment, elevation);
                }
            }
            
            addLaneMarkings(segment, elevation) {
                const laneWidth = GAME_CONFIG.ROAD.LANE_WIDTH;
                const roadWidth = GAME_CONFIG.ROAD.WIDTH;
                
                // Left lane marking
                const leftMarking = BABYLON.MeshBuilder.CreateBox(
                    'leftMarking',
                    { width: 0.1, height: 0.02, depth: GAME_CONFIG.ROAD.SEGMENT_LENGTH },
                    scene
                );
                leftMarking.parent = segment;
                leftMarking.position = new BABYLON.Vector3(-laneWidth, 0.11, 0);
                leftMarking.material = this.createLaneMaterial(0xFFFF00);
                
                // Right lane marking
                const rightMarking = BABYLON.MeshBuilder.CreateBox(
                    'rightMarking',
                    { width: 0.1, height: 0.02, depth: GAME_CONFIG.ROAD.SEGMENT_LENGTH },
                    scene
                );
                rightMarking.parent = segment;
                rightMarking.position = new BABYLON.Vector3(laneWidth, 0.11, 0);
                rightMarking.material = this.createLaneMaterial(0xFFFF00);
                
                // Center dashed markings
                const dashCount = Math.floor(GAME_CONFIG.ROAD.SEGMENT_LENGTH / 5);
                for (let i = 0; i < dashCount; i++) {
                    const dash = BABYLON.MeshBuilder.CreateBox(
                        `dash_${i}`,
                        { width: 0.05, height: 0.02, depth: 2 },
                        scene
                    );
                    dash.parent = segment;
                    dash.position = new BABYLON.Vector3(
                        0,
                        0.11,
                        -GAME_CONFIG.ROAD.SEGMENT_LENGTH/2 + i * 5 + 2.5
                    );
                    dash.material = this.createLaneMaterial(0xFFFFFF);
                }
            }
            
            createLaneMaterial(color) {
                const
