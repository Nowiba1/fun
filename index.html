<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless 3D Road Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 100%);
            color: #333;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #ui h2 {
            margin-bottom: 10px;
            color: #4CAF50;
            font-size: 1.4em;
        }
        
        .ui-row {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .ui-label {
            color: #aaa;
        }
        
        .ui-value {
            font-weight: bold;
            color: white;
        }
        
        #speedBar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        #speedFill {
            height: 100%;
            width: 30%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #controls h3 {
            margin-bottom: 10px;
            color: #FF9800;
        }
        
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            margin: 2px;
            border-radius: 5px;
            font-family: monospace;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            min-width: 300px;
            border: 2px solid #4CAF50;
        }
        
        #loading h2 {
            margin-bottom: 15px;
            color: #4CAF50;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 15px;
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            min-width: 350px;
            display: none;
            border: 3px solid #FF5252;
            box-shadow: 0 0 30px rgba(255, 82, 82, 0.5);
        }
        
        #gameOver h2 {
            font-size: 2.5em;
            color: #FF5252;
            margin-bottom: 20px;
        }
        
        #gameOver button {
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s;
        }
        
        #gameOver button:hover {
            transform: scale(1.05);
        }
        
        #roadCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <h2>ROAD RUNNER</h2>
            <div class="ui-row">
                <span class="ui-label">SCORE:</span>
                <span id="score" class="ui-value">0</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">SPEED:</span>
                <span id="speed" class="ui-value">60 km/h</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">DISTANCE:</span>
                <span id="distance" class="ui-value">0 m</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">ENEMIES:</span>
                <span id="enemies" class="ui-value">0</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">LANE:</span>
                <span id="lane" class="ui-value">2</span>
            </div>
            <div id="speedBar">
                <div id="speedFill"></div>
            </div>
        </div>
        
        <div id="controls">
            <h3>CONTROLS</h3>
            <p><span class="key">W</span>/<span class="key">↑</span> - Accelerate</p>
            <p><span class="key">A</span>/<span class="key">←</span> - Left Lane</p>
            <p><span class="key">D</span>/<span class="key">→</span> - Right Lane</p>
            <p><span class="key">S</span>/<span class="key">↓</span> - Brake</p>
            <p style="margin-top: 10px; color: #FF9800;">Gamepad Supported</p>
        </div>
        
        <div id="loading">
            <h2>LOADING GAME</h2>
            <p id="loadingText">Initializing 3D engine...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="loadingProgress"></div>
            </div>
        </div>
        
        <div id="gameOver">
            <h2>GAME OVER</h2>
            <p>You crashed!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Distance Traveled: <span id="finalDistance">0 m</span></p>
            <button onclick="restartGame()">PLAY AGAIN</button>
        </div>
        
        <canvas id="roadCanvas"></canvas>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // Import Three.js modules
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://unpkg.com/three@0.162.0/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.162.0/examples/jsm/controls/OrbitControls.js';

        // ====================
        // GAME CONFIGURATION
        // ====================
        const CONFIG = {
            // Road settings
            ROAD_WIDTH: 20,
            ROAD_LENGTH: 2000,
            LANE_POSITIONS: [-4.5, -1.5, 1.5, 4.5], // Fixed lane centers
            SEGMENT_LENGTH: 25,
            
            // Curve generation settings
            CURVE_POINTS: 80,
            MAX_HORIZONTAL_OFFSET: 8,
            MAX_VERTICAL_OFFSET: 4,
            
            // Game settings
            INITIAL_SPEED: 20,
            MAX_SPEED: 120,
            ACCELERATION: 0.1,
            LANE_CHANGE_SPEED: 0.2,
            
            // Enemy settings
            MAX_ENEMIES: 10,
            ENEMY_SPAWN_INTERVAL: 2000, // ms
            ENEMY_SPEED_VARIATION: 0.8,
            
            // NPC settings
            MAX_NPCS: 15,
            NPC_SPAWN_INTERVAL: 3000, // ms
            NPC_SPEED_VARIATION: 0.6
        };

        // ====================
        // GAME STATE
        // ====================
        let gameState = {
            score: 0,
            distance: 0,
            speed: CONFIG.INITIAL_SPEED,
            currentLane: 2, // Index in LANE_POSITIONS (0-3)
            targetLane: 2,
            gameOver: false,
            playerCar: null,
            enemies: [],
            npcs: [],
            roadCurve: null,
            roadMesh: null,
            lastEnemySpawn: 0,
            lastNPCSpawn: 0,
            gamepad: null
        };

        // ====================
        // THREE.JS SETUP
        // ====================
        let scene, camera, renderer, controls;
        let roadGeometry, roadMaterial;
        let carModels = { player: [], enemy: [], npc: [] };
        let buildings = [];
        let clock = new THREE.Clock();
        
        // Update loading progress
        function updateLoading(text, progress) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingProgress').style.width = `${progress}%`;
        }
        
        // Initialize the game
        async function init() {
            updateLoading("Setting up 3D scene...", 10);
            
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);
            
            // Camera setup (third-person)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 10, -20);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('roadCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            updateLoading("Generating procedural road...", 30);
            
            // Generate road curve and mesh
            generateRoad();
            
            updateLoading("Creating environment...", 50);
            
            // Create buildings along the road
            generateBuildings();
            
            // Load car models (simulated - in a real implementation, you would load actual GLTF files)
            await loadCarModels();
            
            updateLoading("Setting up player car...", 80);
            
            // Create player car
            createPlayerCar();
            
            // Setup event listeners
            setupEventListeners();
            
            updateLoading("Starting game...", 100);
            
            // Hide loading screen after a brief delay
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                animate();
            }, 500);
        }
        
        // ====================
        // ROAD GENERATION (Curve-based)
        // ====================
        function generateRoad() {
            /*
            Road Generation Explanation:
            - We create a smooth CatmullRomCurve3 with procedurally generated control points
            - Control points have random horizontal (for turns) and vertical (for hills) offsets
            - The curve ensures the road is continuous and gap-free
            - Road mesh is generated by extruding a profile along this curve
            */
            
            // Create control points for the curve
            const points = [];
            
            for (let i = 0; i < CONFIG.CURVE_POINTS; i++) {
                // Base position along Z-axis
                const z = i * (CONFIG.ROAD_LENGTH / CONFIG.CURVE_POINTS);
                
                // Add horizontal offset for turns
                const turnAmount = Math.sin(i * 0.3) * CONFIG.MAX_HORIZONTAL_OFFSET;
                
                // Add vertical offset for hills and dips
                const hillAmount = Math.sin(i * 0.2) * CONFIG.MAX_VERTICAL_OFFSET;
                
                // Add occasional speed bumps
                let y = hillAmount;
                if (i % 15 === 0) {
                    y += 1.5; // Speed bump
                }
                
                points.push(new THREE.Vector3(turnAmount, y, z));
            }
            
            // Create smooth curve from points
            gameState.roadCurve = new THREE.CatmullRomCurve3(points);
            gameState.roadCurve.curveType = 'centripetal';
            gameState.roadCurve.tension = 0.5;
            
            // Create road geometry by extruding along the curve
            const roadShape = new THREE.Shape();
            const halfWidth = CONFIG.ROAD_WIDTH / 2;
            roadShape.moveTo(-halfWidth, 0);
            roadShape.lineTo(halfWidth, 0);
            
            const extrudeSettings = {
                steps: 100,
                bevelEnabled: false,
                extrudePath: gameState.roadCurve
            };
            
            roadGeometry = new THREE.ExtrudeGeometry(roadShape, extrudeSettings);
            
            // Create road material
            roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // Create road mesh
            gameState.roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            gameState.roadMesh.receiveShadow = true;
            scene.add(gameState.roadMesh);
            
            // Add road markings
            addRoadMarkings();
        }
        
        function addRoadMarkings() {
            // Center line
            const linePoints = gameState.roadCurve.getPoints(500);
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            
            // Create a curve for the center line slightly above the road
            const offsetCurve = gameState.roadCurve.clone();
            linePoints.forEach((point, i) => {
                point.y += 0.02; // Slight elevation above road
            });
            
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const centerLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(centerLine);
            
            // Lane markings
            const laneMarkingMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            
            CONFIG.LANE_POSITIONS.forEach((laneOffset, index) => {
                if (index < CONFIG.LANE_POSITIONS.length - 1) {
                    const lanePoints = [];
                    const segments = 100;
                    
                    for (let i = 0; i <= segments; i++) {
                        const t = i / segments;
                        const point = gameState.roadCurve.getPoint(t);
                        const tangent = gameState.roadCurve.getTangent(t);
                        const up = new THREE.Vector3(0, 1, 0);
                        const binormal = new THREE.Vector3().crossVectors(up, tangent).normalize();
                        
                        const lanePoint = point.clone().add(
                            binormal.multiplyScalar(laneOffset + 1.5)
                        );
                        lanePoint.y += 0.02;
                        
                        lanePoints.push(lanePoint);
                    }
                    
                    const laneGeometry = new THREE.BufferGeometry().setFromPoints(lanePoints);
                    const laneMarking = new THREE.Line(laneGeometry, laneMarkingMaterial);
                    scene.add(laneMarking);
                }
            });
        }
        
        // ====================
        // BUILDING GENERATION
        // ====================
        function generateBuildings() {
            const buildingColors = [0x8B4513, 0xA0522D, 0xDEB887, 0xD2691E, 0xCD853F];
            
            for (let i = 0; i < 50; i++) {
                // Random position along the road
                const t = Math.random();
                const roadPoint = gameState.roadCurve.getPoint(t);
                const tangent = gameState.roadCurve.getTangent(t);
                const up = new THREE.Vector3(0, 1, 0);
                const binormal = new THREE.Vector3().crossVectors(up, tangent).normalize();
                
                // Place building on left or right side of road
                const side = Math.random() > 0.5 ? 1 : -1;
                const distanceFromRoad = 30 + Math.random() * 40;
                
                const buildingPos = roadPoint.clone().add(
                    binormal.multiplyScalar(side * (CONFIG.ROAD_WIDTH / 2 + distanceFromRoad))
                );
                buildingPos.y = 0;
                
                // Random building dimensions
                const width = 5 + Math.random() * 10;
                const height = 10 + Math.random() * 30;
                const depth = 5 + Math.random() * 10;
                
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingMaterial = new THREE.MeshStandardMaterial({
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                    roughness: 0.7
                });
                
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.copy(buildingPos);
                building.castShadow = true;
                building.receiveShadow = true;
                
                scene.add(building);
                buildings.push(building);
            }
        }
        
        // ====================
        // CAR MODEL LOADING (Simulated)
        // ====================
        async function loadCarModels() {
            // In a real implementation, you would scan the /models/ folder
            // and load actual GLTF/GLB files. For this example, we'll create
            // simple placeholder cars and simulate the auto-detection logic.
            
            // Simulate loading delay
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Create placeholder car models (in reality, these would be loaded from files)
            function createPlaceholderCar(color) {
                const group = new THREE.Group();
                
                // Car body
                const bodyGeometry = new THREE.BoxGeometry(3, 1, 6);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                body.position.y = 1;
                group.add(body);
                
                // Wheels
                const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 8);
                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const wheelPositions = [
                    [-1.5, 0.5, 2],
                    [1.5, 0.5, 2],
                    [-1.5, 0.5, -2],
                    [1.5, 0.5, -2]
                ];
                
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(pos[0], pos[1], pos[2]);
                    wheel.castShadow = true;
                    group.add(wheel);
                });
                
                return group;
            }
            
            // Simulate auto-detection based on filenames
            // In reality, you would have actual filenames like "playerCar.glb", "enemyTruck.gltf", etc.
            
            // Player cars (would be loaded from files containing "player" in name)
            for (let i = 0; i < 3; i++) {
                const car = createPlaceholderCar(0x2196F3); // Blue for player
                car.userData.type = 'player';
                car.userData.speed = 1.0;
                carModels.player.push(car);
            }
            
            // Enemy cars (would be loaded from files containing "enemy" in name)
            for (let i = 0; i < 4; i++) {
                const car = createPlaceholderCar(0xF44336); // Red for enemy
                car.userData.type = 'enemy';
                car.userData.speed = 0.9 + Math.random() * 0.3;
                carModels.enemy.push(car);
            }
            
            // NPC cars (would be loaded from files containing "npc" in name)
            for (let i = 0; i < 5; i++) {
                const car = createPlaceholderCar(0x4CAF50); // Green for NPC
                car.userData.type = 'npc';
                car.userData.speed = 0.7 + Math.random() * 0.4;
                carModels.npc.push(car);
            }
            
            console.log(`Loaded: ${carModels.player.length} player cars, ${carModels.enemy.length} enemy cars, ${carModels.npc.length} NPC cars`);
        }
        
        // ====================
        // LANE SYSTEM
        // ====================
        function getLanePosition(laneIndex) {
            /*
            Lane System Explanation:
            - Lanes are fixed positions relative to the road center
            - Player movement snaps between these fixed lane centers
            - Smooth interpolation between lanes for realistic movement
            */
            return CONFIG.LANE_POSITIONS[laneIndex];
        }
        
        function updatePlayerLane() {
            // Smoothly interpolate between current and target lane
            const currentX = gameState.playerCar.position.x;
            const targetX = getLanePosition(gameState.targetLane);
            
            if (Math.abs(currentX - targetX) > 0.01) {
                const newX = THREE.MathUtils.lerp(currentX, targetX, CONFIG.LANE_CHANGE_SPEED);
                gameState.playerCar.position.x = newX;
            } else {
                gameState.currentLane = gameState.targetLane;
                updateUI();
            }
        }
        
        // ====================
        // CAR CREATION
        // ====================
        function createPlayerCar() {
            if (carModels.player.length === 0) return;
            
            // Randomly select a player car model
            const carIndex = Math.floor(Math.random() * carModels.player.length);
            gameState.playerCar = carModels.player[carIndex].clone();
            gameState.playerCar.position.set(0, 1, 0);
            gameState.playerCar.userData.speed = 1.0;
            scene.add(gameState.playerCar);
        }
        
        function createEnemyCar() {
            if (carModels.enemy.length === 0 || gameState.enemies.length >= CONFIG.MAX_ENEMIES) return;
            
            const carIndex = Math.floor(Math.random() * carModels.enemy.length);
            const enemyCar = carModels.enemy[carIndex].clone();
            
            // Random lane
            const laneIndex = Math.floor(Math.random() * CONFIG.LANE_POSITIONS.length);
            const lanePos = getLanePosition(laneIndex);
            
            // Position behind player
            const distanceBehind = 50 + Math.random() * 100;
            const t = Math.max(0, (gameState.distance - distanceBehind) / CONFIG.ROAD_LENGTH);
            
            if (t < 0) return; // Don't spawn too far behind
            
            const roadPoint = gameState.roadCurve.getPoint(t);
            const tangent = gameState.roadCurve.getTangent(t);
            const up = new THREE.Vector3(0, 1, 0);
            const binormal = new THREE.Vector3().crossVectors(up, tangent).normalize();
            
            enemyCar.position.copy(roadPoint);
            enemyCar.position.add(binormal.multiplyScalar(lanePos));
            enemyCar.position.y += 1;
            
            // Rotate to face road direction
            enemyCar.lookAt(roadPoint.clone().add(tangent));
            
            enemyCar.userData.lane = laneIndex;
            enemyCar.userData.targetLane = laneIndex;
            enemyCar.userData.speed = gameState.speed * (0.8 + Math.random() * 0.4);
            enemyCar.userData.type = 'enemy';
            
            scene.add(enemyCar);
            gameState.enemies.push(enemyCar);
            
            updateUI();
        }
        
        function createNPCCar() {
            if (carModels.npc.length === 0 || gameState.npcs.length >= CONFIG.MAX_NPCS) return;
            
            const carIndex = Math.floor(Math.random() * carModels.npc.length);
            const npcCar = carModels.npc[carIndex].clone();
            
            // Random lane
            const laneIndex = Math.floor(Math.random() * CONFIG.LANE_POSITIONS.length);
            const lanePos = getLanePosition(laneIndex);
            
            // Random position along road
            const t = Math.random();
            const roadPoint = gameState.roadCurve.getPoint(t);
            const tangent = gameState.roadCurve.getTangent(t);
            const up = new THREE.Vector3(0, 1, 0);
            const binormal = new THREE.Vector3().crossVectors(up, tangent).normalize();
            
            npcCar.position.copy(roadPoint);
            npcCar.position.add(binormal.multiplyScalar(lanePos));
            npcCar.position.y += 1;
            
            // Rotate to face road direction
            npcCar.lookAt(roadPoint.clone().add(tangent));
            
            npcCar.userData.lane = laneIndex;
            npcCar.userData.speed = gameState.speed * (0.5 + Math.random() * 0.5);
            npcCar.userData.type = 'npc';
            
            scene.add(npcCar);
            gameState.npcs.push(npcCar);
        }
        
        // ====================
        // UPDATE FUNCTIONS
        // ====================
        function updatePlayerPosition(delta) {
            if (!gameState.playerCar || gameState.gameOver) return;
            
            // Move player forward along road
            const playerT = (gameState.distance % CONFIG.ROAD_LENGTH) / CONFIG.ROAD_LENGTH;
            const roadPoint = gameState.roadCurve.getPoint(playerT);
            const tangent = gameState.roadCurve.getTangent(playerT);
            
            // Update player position and rotation
            gameState.playerCar.position.z = roadPoint.z;
            gameState.playerCar.position.y = roadPoint.y + 1;
            
            // Smooth rotation toward road tangent
            const targetQuaternion = new THREE.Quaternion();
            targetQuaternion.setFromUnitVectors(
                new THREE.Vector3(0, 0, 1),
                tangent.normalize()
            );
            
            gameState.playerCar.quaternion.slerp(targetQuaternion, 0.1);
            
            // Update lane position
            updatePlayerLane();
            
            // Update distance and score
            gameState.distance += gameState.speed * delta;
            gameState.score = Math.floor(gameState.distance / 10);
            
            updateUI();
        }
        
        function updateEnemies(delta) {
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // Simple AI: occasionally change lanes
                if (Math.random() < 0.01) {
                    enemy.userData.targetLane = Math.floor(Math.random() * CONFIG.LANE_POSITIONS.length);
                }
                
                // Update lane position
                const currentX = enemy.position.x;
                const targetX = getLanePosition(enemy.userData.targetLane);
                
                if (Math.abs(currentX - targetX) > 0.1) {
                    const newX = THREE.MathUtils.lerp(currentX, targetX, 0.05);
                    enemy.position.x = newX;
                }
                
                // Move enemy forward
                enemy.position.z -= enemy.userData.speed * delta;
                
                // Remove enemies that are far behind
                if (enemy.position.z < gameState.playerCar.position.z - 200) {
                    scene.remove(enemy);
                    gameState.enemies.splice(i, 1);
                    updateUI();
                }
                
                // Check collision with player
                if (checkCollision(gameState.playerCar, enemy)) {
                    gameOver();
                }
            }
        }
        
        function updateNPCs(delta) {
            for (let i = gameState.npcs.length - 1; i >= 0; i--) {
                const npc = gameState.npcs[i];
                
                // Move NPC forward
                npc.position.z -= npc.userData.speed * delta;
                
                // Remove NPCs that are far behind
                if (npc.position.z < gameState.playerCar.position.z - 200) {
                    scene.remove(npc);
                    gameState.npcs.splice(i, 1);
                }
                
                // Check collision with player
                if (checkCollision(gameState.playerCar, npc)) {
                    gameState.speed = Math.max(10, gameState.speed * 0.7);
                    scene.remove(npc);
                    gameState.npcs.splice(i, 1);
                    updateUI();
                }
            }
        }
        
        function checkCollision(car1, car2) {
            const distance = car1.position.distanceTo(car2.position);
            return distance < 3; // Simple distance-based collision
        }
        
        function updateCamera() {
            if (!gameState.playerCar) return;
            
            // Third-person camera behind and above the car
            const playerT = (gameState.distance % CONFIG.ROAD_LENGTH) / CONFIG.ROAD_LENGTH;
            const roadPoint = gameState.roadCurve.getPoint(playerT);
            const tangent = gameState.roadCurve.getTangent(playerT);
            
            // Calculate camera position
            const cameraOffset = new THREE.Vector3(0, 8, -15);
            cameraOffset.applyQuaternion(gameState.playerCar.quaternion);
            
            camera.position.copy(gameState.playerCar.position).add(cameraOffset);
            
            // Look slightly ahead of the car
            const lookAtPoint = gameState.playerCar.position.clone();
            lookAtPoint.add(tangent.multiplyScalar(20));
            lookAtPoint.y += 2;
            
            camera.lookAt(lookAtPoint);
        }
        
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('speed').textContent = `${Math.round(gameState.speed)} km/h`;
            document.getElementById('distance').textContent = `${Math.round(gameState.distance)} m`;
            document.getElementById('enemies').textContent = gameState.enemies.length;
            document.getElementById('lane').textContent = gameState.currentLane + 1;
            
            // Update speed bar
            const speedPercent = (gameState.speed / CONFIG.MAX_SPEED) * 100;
            document.getElementById('speedFill').style.width = `${speedPercent}%`;
        }
        
        function spawnCars() {
            const now = Date.now();
            
            // Spawn enemies
            if (now - gameState.lastEnemySpawn > CONFIG.ENEMY_SPAWN_INTERVAL) {
                createEnemyCar();
                gameState.lastEnemySpawn = now;
                
                // Increase spawn rate with score
                CONFIG.ENEMY_SPAWN_INTERVAL = Math.max(500, 2000 - gameState.score * 10);
            }
            
            // Spawn NPCs
            if (now - gameState.lastNPCSpawn > CONFIG.NPC_SPAWN_INTERVAL) {
                createNPCCar();
                gameState.lastNPCSpawn = now;
            }
        }
        
        // ====================
        // INPUT HANDLING
        // ====================
        function setupEventListeners() {
            // Keyboard input
            document.addEventListener('keydown', (e) => {
                if (gameState.gameOver) return;
                
                switch(e.key.toLowerCase()) {
                    case 'a':
                    case 'arrowleft':
                        gameState.targetLane = Math.max(0, gameState.targetLane - 1);
                        break;
                    case 'd':
                    case 'arrowright':
                        gameState.targetLane = Math.min(CONFIG.LANE_POSITIONS.length - 1, gameState.targetLane + 1);
                        break;
                    case 'w':
                    case 'arrowup':
                        gameState.speed = Math.min(CONFIG.MAX_SPEED, gameState.speed + 5);
                        break;
                    case 's':
                    case 'arrowdown':
                        gameState.speed = Math.max(10, gameState.speed - 5);
                        break;
                }
            });
            
            // Gamepad support
            window.addEventListener('gamepadconnected', (e) => {
                console.log('Gamepad connected:', e.gamepad.id);
                gameState.gamepad = e.gamepad;
            });
            
            window.addEventListener('gamepaddisconnected', () => {
                gameState.gamepad = null;
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function updateGamepadInput() {
            if (!gameState.gamepad) return;
            
            const gamepad = navigator.getGamepads()[gameState.gamepad.index];
            if (!gamepad) return;
            
            // Left stick for lane changes
            const stickX = gamepad.axes[0];
            if (stickX < -0.5) {
                gameState.targetLane = Math.max(0, gameState.targetLane - 1);
            } else if (stickX > 0.5) {
                gameState.targetLane = Math.min(CONFIG.LANE_POSITIONS.length - 1, gameState.targetLane + 1);
            }
            
            // Right trigger for acceleration
            const acceleration = gamepad.buttons[7].value;
            if (acceleration > 0.1) {
                gameState.speed = Math.min(CONFIG.MAX_SPEED, gameState.speed + acceleration * 2);
            }
            
            // Left trigger for brake
            const brake = gamepad.buttons[6].value;
            if (brake > 0.1) {
                gameState.speed = Math.max(10, gameState.speed - brake * 2);
            }
        }
        
        // ====================
        // GAME FLOW
        // ====================
        function gameOver() {
            gameState.gameOver = true;
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalDistance').textContent = `${Math.round(gameState.distance)} m`;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            // Reset game state
            gameState = {
                score: 0,
                distance: 0,
                speed: CONFIG.INITIAL_SPEED,
                currentLane: 2,
                targetLane: 2,
                gameOver: false,
                playerCar: gameState.playerCar,
                enemies: [],
                npcs: [],
                roadCurve: gameState.roadCurve,
                roadMesh: gameState.roadMesh,
                lastEnemySpawn: 0,
                lastNPCSpawn: 0,
                gamepad: gameState.gamepad
            };
            
            // Remove all cars from scene
            gameState.enemies.forEach(enemy => scene.remove(enemy));
            gameState.npcs.forEach(npc => scene.remove(npc));
            
            // Reset player car position
            if (gameState.playerCar) {
                gameState.playerCar.position.set(0, 1, 0);
                gameState.playerCar.rotation.set(0, 0, 0);
            }
            
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            updateUI();
        }
        
        // ====================
        // ANIMATION LOOP
        // ====================
        function animate() {
            if (gameState.gameOver) return;
            
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1); // Cap delta time
            
            // Update gamepad input
            updateGamepadInput();
            
            // Spawn new cars
            spawnCars();
            
            // Update game objects
            updatePlayerPosition(delta);
            updateEnemies(delta);
            updateNPCs(delta);
            updateCamera();
            
            // Render
            renderer.render(scene, camera);
        }
        
        // ====================
        // START THE GAME
        // ====================
        init().catch(console.error);
        
        // Make restartGame available globally
        window.restartGame = restartGame;
    </script>
</body>
</html>
