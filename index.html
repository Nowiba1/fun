<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cell Block Zero - Cooperative Prison Escape</title>
    
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Load improved noise library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        /* UI Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
            transition: opacity 0.5s;
        }

        #lobbyScreen {
            display: flex;
            background: linear-gradient(135deg, #0a0a2a 0%, #1a1a3a 100%);
        }

        #gameScreen {
            display: none;
        }

        #solitaryScreen {
            display: none;
            background: #000;
        }

        #loadingScreen {
            display: none;
            background: #000;
        }

        /* Modern UI Box */
        .ui-box {
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.95), rgba(10, 15, 30, 0.95));
            border: 2px solid rgba(0, 150, 255, 0.3);
            border-radius: 15px;
            padding: 35px;
            max-width: 800px;
            width: 90%;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            animation: boxGlow 3s infinite alternate;
        }

        @keyframes boxGlow {
            0% { box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1); }
            100% { box-shadow: 0 15px 35px rgba(0, 100, 255, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1); }
        }

        h1 {
            color: #4cc9f0;
            font-size: 3.8em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(76, 201, 240, 0.5);
            letter-spacing: 1px;
            font-weight: 800;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(45deg, #4cc9f0, #4361ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: titlePulse 2s infinite alternate;
        }

        @keyframes titlePulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.02); }
        }

        h2 {
            color: #fff;
            margin: 25px 0;
            font-size: 2.2em;
            font-weight: 600;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        h3 {
            color: #ffd166;
            margin: 15px 0;
            font-size: 1.6em;
        }

        p {
            margin: 15px 0;
            line-height: 1.7;
            font-size: 1.1em;
            color: #b8c1ec;
        }

        /* Modern Buttons */
        .modern-btn {
            background: linear-gradient(145deg, #4361ee, #3a0ca3);
            color: white;
            border: none;
            padding: 18px 35px;
            margin: 15px;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(67, 97, 238, 0.4);
        }

        .modern-btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }

        .modern-btn:hover:before {
            left: 100%;
        }

        .modern-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(67, 97, 238, 0.6);
            background: linear-gradient(145deg, #4cc9f0, #4361ee);
        }

        .modern-btn:active {
            transform: translateY(-1px);
        }

        .modern-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Modern Input */
        input {
            background: rgba(30, 35, 60, 0.8);
            color: white;
            border: 2px solid #4361ee;
            padding: 15px;
            margin: 12px;
            border-radius: 8px;
            font-size: 1.1em;
            width: 280px;
            transition: all 0.3s;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2);
        }

        input:focus {
            outline: none;
            border-color: #4cc9f0;
            box-shadow: 0 0 20px rgba(76, 201, 240, 0.5);
            background: rgba(40, 45, 70, 0.9);
        }

        input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        /* Game UI */
        #connectionStatus {
            position: absolute;
            top: 25px;
            left: 25px;
            padding: 12px 25px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid;
            border-radius: 10px;
            font-weight: 600;
            font-size: 1.1em;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-connected .status-indicator {
            background: #4ade80;
            box-shadow: 0 0 10px #4ade80;
        }

        .status-connecting .status-indicator {
            background: #fbbf24;
            box-shadow: 0 0 10px #fbbf24;
            animation: pulse 1s infinite;
        }

        .status-disconnected .status-indicator {
            background: #ef4444;
            box-shadow: 0 0 10px #ef4444;
        }

        #gameUI {
            position: absolute;
            bottom: 35px;
            left: 35px;
            right: 35px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            gap: 25px;
        }

        .player-card {
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.9), rgba(10, 15, 30, 0.9));
            border: 2px solid;
            padding: 25px;
            min-width: 280px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            transition: transform 0.3s;
        }

        .player-card:hover {
            transform: translateY(-5px);
        }

        .player1 {
            border-color: #ef4444;
        }

        .player2 {
            border-color: #4cc9f0;
        }

        .player-info h3 {
            margin-top: 0;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .health-container {
            margin: 15px 0;
        }

        .health-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #94a3b8;
        }

        .health-bar {
            height: 22px;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 11px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f97316);
            border-radius: 11px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .health-fill:after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Inventory */
        #inventory {
            position: absolute;
            top: 25px;
            right: 25px;
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.95), rgba(10, 15, 30, 0.95));
            border: 2px solid #ffd166;
            padding: 25px;
            border-radius: 15px;
            display: none;
            min-width: 250px;
            backdrop-filter: blur(10px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .inventory-slot {
            width: 70px;
            height: 70px;
            background: rgba(30, 41, 59, 0.6);
            border: 2px solid rgba(255, 209, 102, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            transition: all 0.3s;
            position: relative;
        }

        .inventory-slot:hover {
            transform: scale(1.1);
            border-color: #ffd166;
            box-shadow: 0 0 20px rgba(255, 209, 102, 0.5);
        }

        .inventory-slot.empty {
            background: rgba(30, 41, 59, 0.3);
            border: 2px dashed rgba(255,255,255,0.1);
        }

        .item-count {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
        }

        /* Objective */
        #objective {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(20, 0, 30, 0.95), rgba(10, 0, 20, 0.95));
            border: 3px solid #ff6b6b;
            padding: 50px;
            text-align: center;
            display: none;
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(255, 107, 107, 0.4);
            max-width: 650px;
            width: 90%;
            backdrop-filter: blur(10px);
            animation: objectivePulse 2s infinite alternate;
        }

        @keyframes objectivePulse {
            0% { box-shadow: 0 20px 50px rgba(255, 107, 107, 0.4); }
            100% { box-shadow: 0 20px 50px rgba(255, 107, 107, 0.6); }
        }

        /* Chat */
        #chat {
            position: absolute;
            bottom: 180px;
            left: 35px;
            width: 380px;
            max-height: 320px;
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.95), rgba(10, 15, 30, 0.95));
            border: 2px solid #4cc9f0;
            padding: 20px;
            border-radius: 15px;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        #chatMessages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 10px;
            max-height: 200px;
            scrollbar-width: thin;
            scrollbar-color: #4cc9f0 rgba(15, 23, 42, 0.6);
        }

        #chatMessages::-webkit-scrollbar {
            width: 8px;
        }

        #chatMessages::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 4px;
        }

        #chatMessages::-webkit-scrollbar-thumb {
            background: #4cc9f0;
            border-radius: 4px;
        }

        .chat-message {
            margin: 8px 0;
            padding: 10px;
            border-radius: 10px;
            word-break: break-word;
            animation: messageSlide 0.3s ease-out;
        }

        @keyframes messageSlide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message.you {
            background: linear-gradient(90deg, rgba(67, 97, 238, 0.3), rgba(67, 97, 238, 0.1));
            border-left: 4px solid #4361ee;
        }

        .chat-message.partner {
            background: linear-gradient(90deg, rgba(76, 201, 240, 0.3), rgba(76, 201, 240, 0.1));
            border-left: 4px solid #4cc9f0;
        }

        /* Escape Menu */
        #escapeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.98), rgba(10, 15, 30, 0.98));
            border: 3px solid #ffd166;
            padding: 50px;
            display: none;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            border-radius: 20px;
            box-shadow: 0 25px 60px rgba(255, 209, 102, 0.3);
            min-width: 750px;
            backdrop-filter: blur(20px);
        }

        .escape-option {
            padding: 30px;
            border: 2px solid rgba(76, 201, 240, 0.3);
            cursor: pointer;
            text-align: center;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 15px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .escape-option:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: 0.5s;
        }

        .escape-option:hover:before {
            left: 100%;
        }

        .escape-option:hover {
            transform: translateY(-5px) scale(1.03);
            border-color: #4cc9f0;
            box-shadow: 0 15px 35px rgba(76, 201, 240, 0.4);
            background: rgba(20, 30, 48, 0.8);
        }

        .escape-option.ready {
            border-color: #4ade80;
            background: linear-gradient(145deg, rgba(20, 83, 45, 0.4), rgba(5, 46, 22, 0.4));
        }

        .escape-option.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: #64748b;
        }

        .escape-option.disabled:hover {
            transform: none;
            background: rgba(15, 23, 42, 0.6);
            border-color: #64748b;
        }

        /* Solitary Screen */
        #solitaryScreen {
            background: linear-gradient(135deg, #000 0%, #1a0033 100%);
        }

        #solitaryAnimation {
            width: 100%;
            height: 300px;
            background: #000;
            border: 3px solid #333;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
            border-radius: 10px;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 35px;
            right: 35px;
            display: none;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
            z-index: 100;
        }

        .mobile-joystick {
            width: 120px;
            height: 120px;
            background: rgba(20, 25, 45, 0.7);
            border: 2px solid rgba(76, 201, 240, 0.5);
            border-radius: 50%;
            position: relative;
            backdrop-filter: blur(5px);
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #4361ee, #3a0ca3);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        .mobile-action-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .mobile-action-btn {
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, #ef4444, #dc2626);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            pointer-events: auto;
            touch-action: manipulation;
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
            transition: all 0.2s;
        }

        .mobile-action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 4px 10px rgba(239, 68, 68, 0.6);
        }

        .mobile-action-btn.jump {
            background: linear-gradient(145deg, #4ade80, #16a34a);
            box-shadow: 0 8px 20px rgba(74, 222, 128, 0.4);
        }

        /* Message Display */
        #messageDisplay {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.95), rgba(10, 15, 30, 0.95));
            border: 2px solid;
            padding: 20px 40px;
            border-radius: 12px;
            display: none;
            z-index: 1001;
            text-align: center;
            max-width: 80%;
            word-break: break-word;
            backdrop-filter: blur(10px);
            animation: messageFloat 0.5s ease-out;
        }

        @keyframes messageFloat {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* Progress Bar */
        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            height: 12px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 6px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4cc9f0, #4361ee);
            border-radius: 6px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .progress-fill:after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: progressShine 2s infinite;
        }

        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 320px;
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.98), rgba(10, 15, 30, 0.98));
            color: #fff;
            text-align: center;
            border-radius: 10px;
            padding: 15px;
            position: absolute;
            z-index: 1002;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            border: 2px solid #4cc9f0;
            font-size: 0.95em;
            backdrop-filter: blur(10px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            top: 25px;
            left: 25px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #4cc9f0;
            border-radius: 10px;
            overflow: hidden;
            display: none;
            z-index: 99;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* Day/Night Indicator */
        #timeIndicator {
            position: absolute;
            top: 25px;
            right: 25px;
            padding: 12px 25px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffd166;
            border-radius: 10px;
            font-weight: 600;
            backdrop-filter: blur(5px);
            display: none;
        }

        /* Audio Controls */
        #audioControls {
            position: absolute;
            bottom: 25px;
            right: 25px;
            display: flex;
            gap: 15px;
        }

        .audio-btn {
            width: 50px;
            height: 50px;
            background: rgba(20, 25, 45, 0.8);
            border: 2px solid #4cc9f0;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }

        .audio-btn:hover {
            transform: scale(1.1);
            background: rgba(67, 97, 238, 0.8);
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            h1 { font-size: 3em; }
            .ui-box { padding: 25px; }
            #escapeMenu { 
                grid-template-columns: 1fr; 
                min-width: 90%;
                padding: 30px;
            }
            .player-card { min-width: auto; }
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.5em; }
            h2 { font-size: 1.8em; }
            .modern-btn { padding: 15px 25px; font-size: 1em; }
            .ui-box { padding: 20px; }
            #gameUI { 
                flex-direction: column; 
                gap: 15px;
                bottom: 150px;
            }
            #chat {
                width: calc(100% - 70px);
                bottom: 400px;
            }
            #mobileControls { display: flex; }
            .mobile-joystick { width: 100px; height: 100px; }
        }

        /* Animations */
        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .shake {
            animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Loading Animation */
        .loading-bar {
            width: 300px;
            height: 8px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin: 30px auto;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #4cc9f0, #4361ee);
            border-radius: 4px;
            transition: width 0.3s;
            position: relative;
        }

        .loading-progress:after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: loadingShine 1.5s infinite;
        }

        @keyframes loadingShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
    </style>
    
    <!-- Preload fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>
    <div id="gameContainer">
        <!-- Loading Screen -->
        <div id="loadingScreen" class="screen">
            <div class="ui-box">
                <h1>CELL BLOCK ZERO</h1>
                <div class="loading-bar">
                    <div id="loadingProgress" class="loading-progress" style="width: 0%"></div>
                </div>
                <h2 id="loadingText">Initializing Systems...</h2>
                <p>Establishing secure connection to prison network...</p>
                <div id="loadingTips"></div>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobbyScreen" class="screen">
            <div class="ui-box">
                <h1>CELL BLOCK ZERO</h1>
                <h2>MAXIMUM SECURITY ESCAPE</h2>
                <p>Coordinate with your partner to escape from a high-tech prison facility.</p>
                <p>Use stealth, strategy, and teamwork to overcome security systems.</p>
                
                <div id="connectionStatus" class="status-disconnected">
                    <span class="status-indicator"></span>
                    <span id="statusText">Status: Disconnected</span>
                </div>
                
                <div style="margin: 40px 0;">
                    <button onclick="hostGame()" id="hostBtn" class="modern-btn">CREATE SESSION</button>
                    <button onclick="joinGame()" id="joinBtn" class="modern-btn">JOIN SESSION</button>
                    <button onclick="showTutorial()" id="tutorialBtn" class="modern-btn">TRAINING</button>
                </div>
                
                <div id="joinSection" style="display: none; margin: 30px 0;">
                    <h3>Enter Session Code</h3>
                    <input type="text" id="roomCode" placeholder="Enter 6-digit code" maxlength="6" pattern="[A-Z0-9]{6}">
                    <div style="margin-top: 20px;">
                        <button onclick="connectToHost()" class="modern-btn">CONNECT</button>
                        <button onclick="cancelJoin()" class="modern-btn">BACK</button>
                    </div>
                </div>
                
                <div id="roomInfo" style="display: none; margin: 30px 0;">
                    <h3>Session Active</h3>
                    <p style="font-size: 1.3em; color: #4cc9f0;">Code: <span id="displayCode" class="pulse">XXXXXX</span></p>
                    <p>Share this code with your partner</p>
                    <p id="connectionCount" style="color: #ffd166;">Waiting for player 2...</p>
                    <div style="margin: 30px 0;">
                        <button onclick="startGame()" id="startBtn" class="modern-btn" disabled>BEGIN ESCAPE</button>
                        <button onclick="cancelHost()" class="modern-btn">CANCEL</button>
                    </div>
                </div>
                
                <div id="tutorialSection" style="display: none; margin: 30px 0; text-align: left;">
                    <h3>Escape Protocol:</h3>
                    <div style="background: rgba(30, 41, 59, 0.5); padding: 25px; border-radius: 10px;">
                        <p>1. <strong>Establish Connection:</strong> One player creates session, other joins with code</p>
                        <p>2. <strong>Reconnaissance:</strong> Explore facility and locate security weak points</p>
                        <p>3. <strong>Acquire Resources:</strong> Collect tools and equipment for escape plans</p>
                        <p>4. <strong>Coordinate:</strong> Work together to avoid patrols and security systems</p>
                        <p>5. <strong>Execute:</strong> Choose escape method when all requirements are met</p>
                        <p>6. <strong>Evade:</strong> If detected, you'll be sent to solitary confinement</p>
                    </div>
                    <button onclick="hideTutorial()" class="modern-btn" style="margin-top: 25px;">CONTINUE</button>
                </div>
                
                <div style="margin-top: 40px; border-top: 1px solid rgba(76, 201, 240, 0.3); padding-top: 25px;">
                    <h3>Control Protocol:</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 15px;">
                        <div style="text-align: left;">
                            <p><strong>Movement:</strong> WASD / Arrow Keys</p>
                            <p><strong>Sprint:</strong> Shift</p>
                            <p><strong>Jump:</strong> Space</p>
                        </div>
                        <div style="text-align: left;">
                            <p><strong>Interact:</strong> E</p>
                            <p><strong>Inventory:</strong> Tab</p>
                            <p><strong>Escape Menu:</strong> M</p>
                            <p><strong>Chat:</strong> C</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="screen">
            <canvas id="gameCanvas"></canvas>
            
            <div id="connectionStatus" class="status-connected">
                <span class="status-indicator"></span>
                <span id="statusText">Connected</span>
            </div>
            
            <div id="minimap"></div>
            
            <div id="timeIndicator">
                <span id="timeText">DAY</span>
                <div class="progress-bar" style="width: 100px; margin-top: 5px;">
                    <div id="timeProgress" class="progress-fill" style="width: 50%"></div>
                </div>
            </div>
            
            <div id="gameUI">
                <div class="player-card player1">
                    <div class="player-info">
                        <h3>üë§ PLAYER 1 <span id="playerName1"></span></h3>
                        <div class="health-container">
                            <div class="health-label">
                                <span>HEALTH</span>
                                <span id="health1">100</span>
                            </div>
                            <div class="health-bar">
                                <div id="healthBar1" class="health-fill" style="width: 100%"></div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 15px;">
                            <div>
                                <p style="color: #94a3b8; font-size: 0.9em;">CONTRABAND</p>
                                <p style="font-size: 1.3em; color: #ffd166;" id="contraband1">0</p>
                            </div>
                            <div>
                                <p style="color: #94a3b8; font-size: 0.9em;">REPUTATION</p>
                                <p style="font-size: 1.3em; color: #4ade80;" id="rep1">0</p>
                            </div>
                        </div>
                        <p style="margin-top: 15px; color: #4cc9f0; font-size: 0.9em;">
                            LOCATION: <span id="pos1">CELL BLOCK A</span>
                        </p>
                    </div>
                </div>
                
                <div class="player-card player2">
                    <div class="player-info">
                        <h3>üë• PLAYER 2 <span id="playerName2"></span></h3>
                        <div class="health-container">
                            <div class="health-label">
                                <span>HEALTH</span>
                                <span id="health2">100</span>
                            </div>
                            <div class="health-bar">
                                <div id="healthBar2" class="health-fill" style="width: 100%"></div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 15px;">
                            <div>
                                <p style="color: #94a3b8; font-size: 0.9em;">CONTRABAND</p>
                                <p style="font-size: 1.3em; color: #ffd166;" id="contraband2">0</p>
                            </div>
                            <div>
                                <p style="color: #94a3b8; font-size: 0.9em;">REPUTATION</p>
                                <p style="font-size: 1.3em; color: #4ade80;" id="rep2">0</p>
                            </div>
                        </div>
                        <p style="margin-top: 15px; color: #4cc9f0; font-size: 0.9em;">
                            LOCATION: <span id="pos2">CELL BLOCK B</span>
                        </p>
                    </div>
                </div>
            </div>
            
            <div id="inventory">
                <h3>üì¶ INVENTORY <span id="inventoryCount">(0/8)</span></h3>
                <div class="inventory-grid" id="inventoryItems"></div>
                <div class="progress-container" style="margin-top: 25px;">
                    <p style="margin-bottom: 10px; color: #94a3b8;">ESCAPE PROGRESS</p>
                    <div class="progress-bar">
                        <div id="escapeProgress" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            
            <div id="objective">
                <h2>üîì PRIMARY OBJECTIVE</h2>
                <p id="objectiveText">ESCAPE THE MAXIMUM SECURITY PRISON FACILITY</p>
                <p id="objectiveSubtext" style="color: #ffd166;">Collect resources, avoid detection, and coordinate with your partner</p>
                <button onclick="hideObjective()" class="modern-btn" style="margin-top: 30px;">BEGIN OPERATION</button>
            </div>
            
            <div id="chat">
                <div id="chatMessages"></div>
                <input type="text" id="chatInput" placeholder="Secure communication channel... (Enter to send, Esc to close)">
            </div>
            
            <div id="escapeMenu">
                <h2 style="grid-column: span 2;">üöÄ ESCAPE PROTOCOLS</h2>
                <div class="escape-option" onclick="startEscape('tunnel')" id="escapeTunnel">
                    <h3>üöá TUNNEL NETWORK</h3>
                    <p>Excavate escape tunnel through drainage system</p>
                    <p><strong style="color: #ffd166;">Requires:</strong> Shovel, Flashlight</p>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #94a3b8;">üïí 15-20 minutes | Success: 65%</p>
                </div>
                <div class="escape-option" onclick="startEscape('disguise')" id="escapeDisguise">
                    <h3>üé≠ PERSONNEL IMPERSONATION</h3>
                    <p>Infiltrate guard forces using stolen identity</p>
                    <p><strong style="color: #ffd166;">Requires:</strong> Uniform, ID Card</p>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #94a3b8;">üïí 5-10 minutes | Success: 75%</p>
                </div>
                <div class="escape-option" onclick="startEscape('riot')" id="escapeRiot">
                    <h3>üî• DISTURBANCE PROTOCOL</h3>
                    <p>Create diversion during scheduled lockdown</p>
                    <p><strong style="color: #ffd166;">Requires:</strong> High Reputation (50+)</p>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #94a3b8;">üïí 10-15 minutes | Success: 55%</p>
                </div>
                <div class="escape-option" onclick="startEscape('parole')" id="escapeParole">
                    <h3>üìã LEGAL RELEASE</h3>
                    <p>Exploit legal loopholes for early release</p>
                    <p><strong style="color: #ffd166;">Requires:</strong> Clean Record, Documentation</p>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #94a3b8;">üïí 20-30 minutes | Success: 40%</p>
                </div>
                <button onclick="toggleEscapeMenu()" class="modern-btn" style="grid-column: span 2; margin-top: 20px;">CANCEL</button>
            </div>
            
            <!-- Mobile Controls -->
            <div id="mobileControls">
                <div class="mobile-joystick" id="joystickArea">
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
                <div class="mobile-action-buttons">
                    <div class="mobile-action-btn" ontouchstart="mobileAction('interact')">E</div>
                    <div class="mobile-action-btn jump" ontouchstart="mobileAction('jump')">‚¨Ü</div>
                    <div class="mobile-action-btn" ontouchstart="mobileAction('crouch')">‚áì</div>
                </div>
            </div>
            
            <div id="messageDisplay"></div>
            
            <div id="audioControls">
                <div class="audio-btn" onclick="toggleMusic()">‚ô™</div>
                <div class="audio-btn" onclick="toggleSFX()">üîä</div>
            </div>
        </div>

        <!-- Solitary Screen -->
        <div id="solitaryScreen" class="screen">
            <div class="ui-box">
                <h1 style="color: #ef4444;">‚õìÔ∏è SOLITARY CONFINEMENT ‚õìÔ∏è</h1>
                <div id="solitaryAnimation"></div>
                <h2 id="failReason" style="color: #ff6b6b;">SECURITY BREACH DETECTED</h2>
                <p id="funnyMessage" style="font-size: 1.3em; color: #ffd166; margin: 25px 0;"></p>
                <div style="margin: 40px 0;">
                    <button onclick="retryGame()" class="modern-btn">REATTEMPT ESCAPE</button>
                    <button onclick="returnToLobby()" class="modern-btn">ABORT MISSION</button>
                </div>
                <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 10px; margin-top: 30px;">
                    <p style="color: #ef4444;">‚ö†Ô∏è SECURITY ENHANCED: Prison layout has been reconfigured</p>
                    <p id="escapeHint" style="color: #4cc9f0; font-style: italic; margin-top: 15px;"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Audio elements -->
    <audio id="bgMusic" loop>
        <source src="https://assets.mixkit.co/music/preview/mixkit-tech-house-vibes-130.mp3" type="audio/mpeg">
    </audio>
    <audio id="sfxCollect">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" type="audio/mpeg">
    </audio>
    <audio id="sfxAlert">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-warning-alarm-buzzer-958.mp3" type="audio/mpeg">
    </audio>

    <script>
        // ============================================================================
        // ENHANCED SEEDABLE RNG WITH SIMPLEX NOISE
        // ============================================================================
        class EnhancedRandom {
            constructor(seed) {
                this.seed = seed || Date.now();
                this.current = this.seed;
                this.noise = new SimplexNoise(() => this.next());
            }
            
            next() {
                this.current = (this.current * 9301 + 49297) % 233280;
                return this.current / 233280;
            }
            
            random() {
                return this.next();
            }
            
            range(min, max) {
                return min + this.next() * (max - min);
            }
            
            int(min, max) {
                return Math.floor(this.range(min, max));
            }
            
            choice(array) {
                return array[this.int(0, array.length)];
            }
            
            noise2D(x, y) {
                return this.noise.noise2D(x, y);
            }
            
            weightedChoice(items) {
                const totalWeight = items.reduce((sum, item) => sum + item.weight, 0);
                let random = this.next() * totalWeight;
                
                for (const item of items) {
                    if (random < item.weight) return item.value;
                    random -= item.weight;
                }
                return items[items.length - 1].value;
            }
        }

        // ============================================================================
        // ENHANCED CONFIGURATION
        // ============================================================================
        const CONFIG = {
            PRISON_SIZE: 120,
            CELL_COUNT: 24,
            GUARD_COUNT: 8,
            INMATE_BOT_COUNT: 16,
            DAY_CYCLE: 600,
            ITEM_TYPES: [
                { id: 'shovel', name: 'Titanium Shovel', color: '#8B4513', icon: 'ü™ö', weight: 5 },
                { id: 'uniform', name: 'Guard Uniform', color: '#1a2b5f', icon: 'üëï', weight: 4 },
                { id: 'idcard', name: 'Security ID', color: '#ffd700', icon: 'ü™™', weight: 3 },
                { id: 'cigarettes', name: 'Cigarettes', color: '#f5f5f5', icon: 'üö¨', weight: 8 },
                { id: 'donut', name: 'Donut', color: '#ff69b4', icon: 'üç©', weight: 10 },
                { id: 'key', name: 'Master Key', color: '#ffd700', icon: 'üîë', weight: 2 },
                { id: 'crowbar', name: 'Titanium Crowbar', color: '#808080', icon: 'üîß', weight: 6 },
                { id: 'rope', name: 'Climbing Rope', color: '#8B4513', icon: 'ü™¢', weight: 7 },
                { id: 'flashlight', name: 'Night Vision Flashlight', color: '#333333', icon: 'üî¶', weight: 4 },
                { id: 'blueprints', name: 'Prison Blueprints', color: '#00ffff', icon: 'üó∫Ô∏è', weight: 2 },
                { id: 'radio', name: 'Walkie Talkie', color: '#0066cc', icon: 'üìª', weight: 3 },
                { id: 'medicine', name: 'Medkit', color: '#ff0000', icon: 'üíä', weight: 6 }
            ],
            ESCAPE_REQUIREMENTS: {
                tunnel: ['shovel', 'flashlight'],
                disguise: ['uniform', 'idcard'],
                riot: ['reputation_50'],
                parole: ['clean_record', 'blueprints']
            },
            ESCAPE_HINTS: {
                tunnel: "The maintenance tunnels near cell block C are poorly monitored during night shift.",
                disguise: "Laundry deliveries arrive daily at 14:00 near the eastern gate.",
                riot: "Maximum security inmates in block D can be persuaded with contraband.",
                parole: "The warden's computer in the administration building contains release forms."
            },
            GUARD_TYPES: [
                { type: 'rookie', color: 0x1e40af, speed: 0.04, alertness: 0.7, vision: 12 },
                { type: 'regular', color: 0x1e3a8a, speed: 0.035, alertness: 0.8, vision: 15 },
                { type: 'sergeant', color: 0x1c1917, speed: 0.03, alertness: 0.9, vision: 18 },
                { type: 'captain', color: 0x000000, speed: 0.025, alertness: 1.0, vision: 20 }
            ],
            INMATE_TYPES: [
                { type: 'lazy', color: 0xdc2626, activity: 0.1, helpfulness: 0.1 },
                { type: 'violent', color: 0x7f1d1d, activity: 0.3, helpfulness: 0.2 },
                { type: 'helpful', color: 0x166534, activity: 0.5, helpfulness: 0.8 },
                { type: 'schemer', color: 0x7c3aed, activity: 0.4, helpfulness: 0.6 },
                { type: 'loner', color: 0x475569, activity: 0.2, helpfulness: 0.3 }
            ]
        };

        // ============================================================================
        // ENHANCED GAME STATE
        // ============================================================================
        let gameState = {
            players: {},
            bots: [],
            items: [],
            prisonLayout: [],
            timeOfDay: 0.25,
            isNight: false,
            gameStarted: false,
            escapeInProgress: false,
            playerId: null,
            peer: null,
            dataChannel: null,
            isHost: false,
            roomCode: null,
            connectionEstablished: false,
            lastUpdate: 0,
            fps: 60,
            gameLoaded: false,
            prisonSeed: Date.now(),
            rng: null,
            audioEnabled: true,
            sfxEnabled: true,
            dayNightCycle: true,
            minimapEnabled: true,
            debugMode: false,
            performanceMode: false
        };

        // ============================================================================
        // THREE.JS VARIABLES
        // ============================================================================
        let scene, camera, renderer, controls;
        let playerMesh, otherPlayerMesh;
        let botMeshes = [], itemMeshes = [], wallMeshes = [], lightMeshes = [];
        let clock = new THREE.Clock();
        let moveSpeed = 0.18;
        let isRunning = false;
        let isCrouching = false;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // ============================================================================
        // INPUT STATE
        // ============================================================================
        const keys = {};
        const mouseState = { x: 0, y: 0, down: false };
        let touchState = {
            joystick: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 }
        };

        // ============================================================================
        // AUDIO SYSTEM
        // ============================================================================
        const audio = {
            bgMusic: document.getElementById('bgMusic'),
            sfxCollect: document.getElementById('sfxCollect'),
            sfxAlert: document.getElementById('sfxAlert'),
            
            play: function(sound, volume = 0.5) {
                if (!gameState.sfxEnabled) return;
                try {
                    sound.volume = volume;
                    sound.currentTime = 0;
                    sound.play().catch(e => console.log('Audio play failed:', e));
                } catch (e) {}
            },
            
            playMusic: function() {
                if (!gameState.audioEnabled) return;
                try {
                    this.bgMusic.volume = 0.3;
                    this.bgMusic.play().catch(e => console.log('Music play failed:', e));
                } catch (e) {}
            },
            
            stopMusic: function() {
                this.bgMusic.pause();
                this.bgMusic.currentTime = 0;
            }
        };

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('Cell Block Zero - Enhanced Edition Initializing');
            setLoadingText("Checking system compatibility...");
            updateLoadingProgress(10);
            
            // Load loading tips
            const tips = [
                "Tip: Work with your partner - coordination is key to success",
                "Tip: Different escape methods require different resources",
                "Tip: Guards are less alert during night hours",
                "Tip: Some inmates can provide valuable information",
                "Tip: Keep your contraband hidden from guards",
                "Tip: Use the environment to avoid security cameras"
            ];
            
            let tipIndex = 0;
            const tipElement = document.getElementById('loadingTips');
            setInterval(() => {
                if (tipElement) {
                    tipElement.innerHTML = `<p style="color: #94a3b8; margin-top: 20px;">${tips[tipIndex]}</p>`;
                    tipIndex = (tipIndex + 1) % tips.length;
                }
            }, 3000);
            
            // Check for WebRTC support
            if (!navigator.mediaDevices || !window.RTCPeerConnection) {
                showError("WebRTC not supported in this browser. Please use Chrome, Firefox, or Edge.");
                return;
            }
            
            updateLoadingProgress(30);
            
            // Check for Three.js
            if (typeof THREE === 'undefined') {
                showError("Three.js failed to load. Please check your internet connection.");
                return;
            }
            
            updateLoadingProgress(60);
            
            // Initialize RNG with current time
            gameState.rng = new EnhancedRandom(Date.now());
            
            updateLoadingProgress(80);
            
            // Initialize UI
            updateConnectionStatus('ready', 'Ready to establish connection');
            
            // Setup mobile controls
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                document.getElementById('mobileControls').style.display = 'flex';
                setupTouchControls();
            }
            
            updateLoadingProgress(100);
            
            console.log('Game initialized successfully');
            gameState.gameLoaded = true;
            
            // Auto-hide loading after 1 second
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                }, 500);
            }, 1000);
        });

        // ============================================================================
        // ENHANCED NETWORKING SYSTEM
        // ============================================================================
        function hostGame() {
            if (!gameState.gameLoaded) {
                showMessage("System still initializing...");
                return;
            }
            
            disableButtons(true);
            updateConnectionStatus('connecting', 'Establishing secure session...');
            
            gameState.isHost = true;
            gameState.playerId = 'host_' + generateRandomId();
            gameState.roomCode = generateRoomCode();
            gameState.prisonSeed = Date.now();
            gameState.rng = new EnhancedRandom(gameState.prisonSeed);
            
            // Enhanced peer connection with better configuration
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10,
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            };
            
            gameState.peer = new RTCPeerConnection(config);
            
            // Enhanced data channel configuration
            gameState.dataChannel = gameState.peer.createDataChannel('game', {
                ordered: true,
                maxRetransmits: 15,
                protocol: 'game-protocol'
            });
            
            setupDataChannel(gameState.dataChannel);
            
            // Enhanced ICE candidate handling
            gameState.peer.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidates = JSON.parse(localStorage.getItem('iceCandidates') || '[]');
                    candidates.push({
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    });
                    localStorage.setItem('iceCandidates', JSON.stringify(candidates));
                }
            };
            
            // Enhanced connection state handling
            gameState.peer.onconnectionstatechange = () => {
                console.log('Connection state:', gameState.peer.connectionState);
                const states = {
                    'connected': ['connected', 'Session established'],
                    'failed': ['disconnected', 'Connection failed'],
                    'disconnected': ['disconnected', 'Connection lost'],
                    'closed': ['disconnected', 'Connection closed']
                };
                
                if (states[gameState.peer.connectionState]) {
                    const [status, message] = states[gameState.peer.connectionState];
                    updateConnectionStatus(status, message);
                }
            };
            
            // ICE connection state
            gameState.peer.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', gameState.peer.iceConnectionState);
            };
            
            // Create and store offer
            gameState.peer.createOffer({
                offerToReceiveAudio: false,
                offerToReceiveVideo: false
            })
            .then(offer => {
                return gameState.peer.setLocalDescription(offer);
            })
            .then(() => {
                // Store comprehensive session data
                const sessionData = {
                    sdp: gameState.peer.localDescription,
                    roomCode: gameState.roomCode,
                    playerId: gameState.playerId,
                    prisonSeed: gameState.prisonSeed,
                    timestamp: Date.now(),
                    version: '2.0'
                };
                
                localStorage.setItem('hostOffer', JSON.stringify(sessionData));
                localStorage.setItem('iceCandidates', '[]');
                localStorage.setItem('playerAnswer', '');
                
                // Show room info
                document.getElementById('roomInfo').style.display = 'block';
                document.getElementById('displayCode').textContent = gameState.roomCode;
                updateConnectionStatus('connecting', `Awaiting partner... Code: ${gameState.roomCode}`);
                
                console.log('Host created enhanced session:', gameState.roomCode);
                
                // Start connection monitoring
                startConnectionMonitoring();
            })
            .catch(error => {
                console.error('Error creating offer:', error);
                updateConnectionStatus('disconnected', 'Session creation failed');
                showMessage("Failed to create session. Please try again.", "error");
                disableButtons(false);
            });
        }

        function startConnectionMonitoring() {
            if (!gameState.isHost || gameState.connectionEstablished) return;
            
            const checkInterval = setInterval(() => {
                if (gameState.connectionEstablished) {
                    clearInterval(checkInterval);
                    return;
                }
                
                try {
                    const playerAnswer = localStorage.getItem('playerAnswer');
                    if (playerAnswer) {
                        const answer = JSON.parse(playerAnswer);
                        if (answer.roomCode === gameState.roomCode && answer.timestamp > Date.now() - 120000) {
                            gameState.peer.setRemoteDescription(new RTCSessionDescription(answer.sdp))
                                .then(() => {
                                    // Add stored ICE candidates
                                    const candidates = JSON.parse(localStorage.getItem('iceCandidates') || '[]');
                                    candidates.forEach(candidate => {
                                        if (candidate) {
                                            gameState.peer.addIceCandidate(new RTCIceCandidate(candidate));
                                        }
                                    });
                                    
                                    localStorage.removeItem('playerAnswer');
                                    console.log('Connected to joiner');
                                })
                                .catch(console.error);
                        }
                    }
                } catch (e) {
                    console.error('Connection monitoring error:', e);
                }
            }, 1000);
        }

        function connectToHost() {
            const roomCodeInput = document.getElementById('roomCode');
            const roomCode = roomCodeInput.value.trim().toUpperCase();
            
            if (!roomCode || roomCode.length !== 6) {
                showMessage("Please enter a valid 6-digit session code", "error");
                roomCodeInput.focus();
                return;
            }
            
            disableButtons(true);
            updateConnectionStatus('connecting', 'Connecting to session...');
            
            gameState.isHost = false;
            gameState.playerId = 'joiner_' + generateRandomId();
            gameState.roomCode = roomCode;
            
            // Get host offer
            const hostData = localStorage.getItem('hostOffer');
            if (!hostData) {
                showMessage("Session not found. Ensure host has created a session first.", "error");
                disableButtons(false);
                return;
            }
            
            let hostOffer;
            try {
                hostOffer = JSON.parse(hostData);
                
                // Check session validity
                if (Date.now() - hostOffer.timestamp > 120000) {
                    showMessage("Session expired. Please request a new session code.", "error");
                    disableButtons(false);
                    return;
                }
                
                if (hostOffer.roomCode !== roomCode) {
                    showMessage("Invalid session code.", "error");
                    disableButtons(false);
                    return;
                }
                
                gameState.prisonSeed = hostOffer.prisonSeed || Date.now();
                gameState.rng = new EnhancedRandom(gameState.prisonSeed);
                
            } catch (e) {
                showMessage("Error reading session data.", "error");
                disableButtons(false);
                return;
            }
            
            // Create peer connection
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10
            };
            
            gameState.peer = new RTCPeerConnection(config);
            
            // Setup data channel listener
            gameState.peer.ondatachannel = (event) => {
                gameState.dataChannel = event.channel;
                setupDataChannel(gameState.dataChannel);
            };
            
            // ICE candidates
            gameState.peer.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidateData = {
                        type: 'iceCandidate',
                        candidate: event.candidate,
                        roomCode: roomCode
                    };
                    localStorage.setItem('playerIceCandidate', JSON.stringify(candidateData));
                }
            };
            
            // Set remote description
            gameState.peer.setRemoteDescription(new RTCSessionDescription(hostOffer.sdp))
                .then(() => gameState.peer.createAnswer())
                .then(answer => gameState.peer.setLocalDescription(answer))
                .then(() => {
                    // Store answer
                    localStorage.setItem('playerAnswer', JSON.stringify({
                        sdp: gameState.peer.localDescription,
                        roomCode: roomCode,
                        playerId: gameState.playerId,
                        timestamp: Date.now()
                    }));
                    
                    console.log('Joiner connected to session:', roomCode);
                    showMessage("Connected! Awaiting host to begin...", "success");
                })
                .catch(error => {
                    console.error('Connection error:', error);
                    updateConnectionStatus('disconnected', 'Connection failed');
                    showMessage("Connection failed. Verify session code and try again.", "error");
                    disableButtons(false);
                });
        }

        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('Data channel established');
                gameState.connectionEstablished = true;
                updateConnectionStatus('connected', 'Secure connection established');
                
                if (gameState.isHost) {
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('connectionCount').textContent = 'Partner connected! Ready to proceed.';
                    showMessage("Partner connected successfully!", "success");
                } else {
                    showMessage("Connected to host! Waiting for mission start...", "success");
                }
                
                // Send player info
                sendNetworkMessage('playerJoin', {
                    playerId: gameState.playerId,
                    name: `Operator ${gameState.isHost ? 'Alpha' : 'Beta'}`,
                    isHost: gameState.isHost
                });
            };
            
            channel.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleNetworkMessage(data);
                } catch (e) {
                    console.error('Network message error:', e);
                }
            };
            
            channel.onclose = () => {
                console.log('Data channel terminated');
                gameState.connectionEstablished = false;
                updateConnectionStatus('disconnected', 'Connection lost');
                
                if (gameState.gameStarted) {
                    showMessage("Partner connection lost!", "error");
                }
            };
            
            channel.onerror = (error) => {
                console.error('Data channel error:', error);
                showMessage("Network instability detected", "warning");
            };
        }

        function sendNetworkMessage(type, data) {
            if (gameState.dataChannel && gameState.dataChannel.readyState === 'open') {
                const message = {
                    type: type,
                    sender: gameState.playerId,
                    data: data,
                    timestamp: Date.now(),
                    sequence: Math.random().toString(36).substr(2, 9)
                };
                try {
                    gameState.dataChannel.send(JSON.stringify(message));
                } catch (e) {
                    console.error('Send error:', e);
                }
            }
        }

        function handleNetworkMessage(message) {
            const handlers = {
                'playerJoin': handlePlayerJoin,
                'playerUpdate': updatePlayer,
                'gameStart': startGameFromNetwork,
                'itemCollected': collectItemRemote,
                'botUpdate': updateBot,
                'escapeAttempt': handleEscapeAttempt,
                'chat': displayChatMessage,
                'gameOver': handleGameOver,
                'ping': () => sendNetworkMessage('pong', { timestamp: message.data.timestamp })
            };
            
            if (handlers[message.type]) {
                handlers[message.type](message);
            }
        }

        function handlePlayerJoin(message) {
            const { playerId, name, isHost } = message.data;
            
            if (playerId === gameState.playerId) return;
            
            if (!gameState.players[playerId]) {
                gameState.players[playerId] = {
                    id: playerId,
                    name: name,
                    position: { x: 15, y: 1, z: 0 },
                    health: 100,
                    contraband: 0,
                    reputation: 0,
                    inventory: [],
                    isLocal: false,
                    lastUpdate: Date.now()
                };
                
                document.getElementById('playerName2').textContent = ` (${name})`;
                updateConnectionStatus('connected', `Linked with ${name}`);
                
                if (gameState.isHost && !gameState.gameStarted) {
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('connectionCount').textContent = `${name} connected and ready`;
                }
            }
        }

        function updatePlayer(message) {
            const playerId = message.sender;
            const data = message.data;
            
            if (!gameState.players[playerId]) return;
            
            const player = gameState.players[playerId];
            
            // Update position if we have mesh
            if (!player.isLocal && player.mesh) {
                if (data.x !== undefined) player.mesh.position.x = data.x;
                if (data.y !== undefined) player.mesh.position.y = data.y;
                if (data.z !== undefined) player.mesh.position.z = data.z;
                if (data.ry !== undefined) player.mesh.rotation.y = data.ry;
            }
            
            // Update stats
            if (data.health !== undefined) player.health = data.health;
            if (data.contraband !== undefined) player.contraband = data.contraband;
            if (data.reputation !== undefined) player.reputation = data.reputation;
            if (data.inventory !== undefined) player.inventory = data.inventory;
            
            // Update position
            if (data.x !== undefined && data.y !== undefined && data.z !== undefined) {
                player.position = { x: data.x, y: data.y, z: data.z };
            }
            
            player.lastUpdate = Date.now();
            
            // Update UI for other player
            if (playerId !== gameState.playerId) {
                updatePlayerUI(2, player);
            }
        }

        // ============================================================================
        // ENHANCED PRISON GENERATION
        // ============================================================================
        function generateEnhancedPrison(seed) {
            console.log('Generating enhanced prison facility...');
            gameState.rng = new EnhancedRandom(seed);
            
            // Clear scene
            clearScene();
            
            // Create realistic terrain with noise
            createTerrain();
            
            // Create main prison structures
            createPrisonWalls();
            createCellBlocks();
            createAdministrationBuilding();
            createYardAndFacilities();
            createGuardTowers();
            createSecuritySystems();
            
            // Populate with items and bots
            populateItems();
            populateBots();
            
            // Add atmospheric effects
            addAtmosphericEffects();
            
            console.log('Prison facility generation complete');
        }

        function createTerrain() {
            const size = CONFIG.PRISON_SIZE * 1.5;
            const segments = 64;
            
            // Create terrain geometry with noise
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            const vertices = geometry.attributes.position.array;
            
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                
                // Use simplex noise for natural terrain
                const noise = gameState.rng.noise2D(x * 0.01, z * 0.01) * 5 +
                            gameState.rng.noise2D(x * 0.02, z * 0.02) * 2 +
                            gameState.rng.noise2D(x * 0.05, z * 0.05) * 1;
                
                vertices[i + 1] = noise;
            }
            
            geometry.computeVertexNormals();
            
            // Create realistic ground material
            const material = new THREE.MeshStandardMaterial({
                color: 0x2d5a27,
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
            wallMeshes.push(ground);
            
            // Add grass details
            for (let i = 0; i < 100; i++) {
                const x = gameState.rng.range(-size/2, size/2);
                const z = gameState.rng.range(-size/2, size/2);
                if (Math.abs(x) < CONFIG.PRISON_SIZE/2 && Math.abs(z) < CONFIG.PRISON_SIZE/2) continue;
                
                const grass = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.2, 0.5, 6),
                    new THREE.MeshStandardMaterial({ color: 0x3a7d34 })
                );
                grass.position.set(x, -1.5, z);
                grass.rotation.x = Math.random() * Math.PI;
                scene.add(grass);
            }
        }

        function createPrisonWalls() {
            const height = 12;
            const thickness = 4;
            const halfSize = CONFIG.PRISON_SIZE / 2;
            
            // Enhanced wall material
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                roughness: 0.8,
                metalness: 0.3,
                bumpScale: 0.05
            });
            
            // Main walls
            const walls = [
                // North
                { pos: [0, height/2, -halfSize], size: [CONFIG.PRISON_SIZE, height, thickness], rotation: 0 },
                // South
                { pos: [0, height/2, halfSize], size: [CONFIG.PRISON_SIZE, height, thickness], rotation: 0 },
                // East
                { pos: [halfSize, height/2, 0], size: [thickness, height, CONFIG.PRISON_SIZE], rotation: 0 },
                // West
                { pos: [-halfSize, height/2, 0], size: [thickness, height, CONFIG.PRISON_SIZE], rotation: 0 }
            ];
            
            walls.forEach(wall => {
                const geometry = new THREE.BoxGeometry(...wall.size);
                const mesh = new THREE.Mesh(geometry, wallMaterial);
                mesh.position.set(...wall.pos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { type: 'wall' };
                scene.add(mesh);
                wallMeshes.push(mesh);
            });
            
            // Add barbed wire on top
            const wireMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8, roughness: 0.2 });
            for (let x = -halfSize + 5; x < halfSize - 5; x += 3) {
                for (let side of [-1, 1]) {
                    const wire = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8),
                        wireMaterial
                    );
                    wire.position.set(x, height, side * (halfSize - 2));
                    scene.add(wire);
                    wallMeshes.push(wire);
                    
                    const wire2 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8),
                        wireMaterial
                    );
                    wire2.position.set(side * (halfSize - 2), height, x);
                    scene.add(wire2);
                    wallMeshes.push(wire2);
                }
            }
            
            // Main gate
            const gateMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6, roughness: 0.4 });
            const gate = new THREE.Mesh(
                new THREE.BoxGeometry(25, 10, 2),
                gateMaterial
            );
            gate.position.set(0, 5, halfSize - 1);
            gate.userData = { type: 'gate', open: false };
            scene.add(gate);
            wallMeshes.push(gate);
        }

        function createCellBlocks() {
            const blocks = 3;
            const cellsPerBlock = 8;
            const blockSpacing = 25;
            
            for (let block = 0; block < blocks; block++) {
                const blockX = (block - 1) * blockSpacing;
                
                for (let cell = 0; cell < cellsPerBlock; cell++) {
                    const cellZ = (cell - cellsPerBlock/2 + 0.5) * 7;
                    
                    // Cell structure
                    const cellMaterial = new THREE.MeshStandardMaterial({
                        color: 0x3a3a3a,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    
                    const cell = new THREE.Mesh(
                        new THREE.BoxGeometry(5, 4, 4),
                        cellMaterial
                    );
                    cell.position.set(blockX, 2, cellZ);
                    cell.castShadow = true;
                    cell.userData = { type: 'cell', block: String.fromCharCode(65 + block), number: cell + 1 };
                    scene.add(cell);
                    wallMeshes.push(cell);
                    
                    // Cell door
                    const door = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 3, 0.2),
                        new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5 })
                    );
                    door.position.set(blockX + 2.5, 1.5, cellZ);
                    door.userData = { type: 'door', locked: true };
                    scene.add(door);
                    wallMeshes.push(door);
                    
                    // Cell bed
                    const bed = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 0.3, 1.5),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    bed.position.set(blockX - 1, 0.15, cellZ);
                    scene.add(bed);
                    wallMeshes.push(bed);
                }
            }
        }

        function createAdministrationBuilding() {
            const adminMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a4a,
                roughness: 0.6,
                metalness: 0.2
            });
            
            const building = new THREE.Mesh(
                new THREE.BoxGeometry(30, 10, 20),
                adminMaterial
            );
            building.position.set(0, 5, -45);
            building.castShadow = true;
            building.receiveShadow = true;
            building.userData = { type: 'admin', name: 'Administration' };
            scene.add(building);
            wallMeshes.push(building);
            
            // Add windows
            for (let i = 0; i < 6; i++) {
                const window = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 3, 0.1),
                    new THREE.MeshStandardMaterial({ color: 0x87ceeb, emissive: 0x87ceeb, emissiveIntensity: 0.2 })
                );
                window.position.set(
                    -10 + i * 4,
                    6,
                    -45 + 10.1
                );
                scene.add(window);
                wallMeshes.push(window);
            }
        }

        function createYardAndFacilities() {
            // Prison yard
            const yardMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a7d34,
                roughness: 0.9,
                metalness: 0
            });
            
            const yard = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 80),
                yardMaterial
            );
            yard.rotation.x = -Math.PI / 2;
            yard.position.set(0, 0.1, 0);
            yard.receiveShadow = true;
            scene.add(yard);
            
            // Basketball court
            const court = new THREE.Mesh(
                new THREE.PlaneGeometry(15, 8),
                new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
            );
            court.rotation.x = -Math.PI / 2;
            court.position.set(20, 0.2, 10);
            scene.add(court);
            
            // Weight area
            for (let i = 0; i < 3; i++) {
                const weight = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8),
                    new THREE.MeshStandardMaterial({ color: 0x808080 })
                );
                weight.position.set(25, 0.2, -15 + i * 10);
                scene.add(weight);
            }
        }

        function createGuardTowers() {
            const positions = [
                [-55, 0, -55], [55, 0, -55],
                [-55, 0, 55], [55, 0, 55]
            ];
            
            positions.forEach(pos => {
                // Tower base
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 4, 20, 8),
                    new THREE.MeshStandardMaterial({ color: 0x555555 })
                );
                base.position.set(pos[0], 10, pos[1]);
                scene.add(base);
                wallMeshes.push(base);
                
                // Tower top
                const top = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 6, 8),
                    new THREE.MeshStandardMaterial({ color: 0x333333 })
                );
                top.position.set(pos[0], 23, pos[1]);
                scene.add(top);
                wallMeshes.push(top);
                
                // Search light
                const light = new THREE.SpotLight(0xffffcc, 1, 50, Math.PI/6);
                light.position.set(pos[0], 25, pos[1]);
                light.target.position.set(pos[0] + 20, 0, pos[1]);
                light.castShadow = true;
                scene.add(light);
                scene.add(light.target);
                lightMeshes.push(light);
            });
        }

        function createSecuritySystems() {
            // Security cameras
            const cameraPositions = [
                { x: 0, z: -40, y: 8 },
                { x: 0, z: 40, y: 8 },
                { x: -40, z: 0, y: 8 },
                { x: 40, z: 0, y: 8 }
            ];
            
            cameraPositions.forEach((pos, i) => {
                const camera = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshStandardMaterial({ color: 0x222222 })
                );
                camera.position.set(pos.x, pos.y, pos.z);
                camera.userData = {
                    type: 'camera',
                    id: i,
                    rotation: 0,
                    range: Math.PI/2,
                    speed: 0.5 + Math.random() * 0.5
                };
                scene.add(camera);
                wallMeshes.push(camera);
                
                // Camera lens
                const lens = new THREE.Mesh(
                    new THREE.CircleGeometry(0.3, 8),
                    new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000 })
                );
                lens.position.z = 0.6;
                lens.rotation.y = Math.PI;
                camera.add(lens);
            });
            
            // Motion sensors
            for (let i = 0; i < 8; i++) {
                const sensor = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.2 })
                );
                sensor.position.set(
                    gameState.rng.range(-40, 40),
                    3,
                    gameState.rng.range(-40, 40)
                );
                sensor.userData = { type: 'sensor', active: true };
                scene.add(sensor);
            }
        }

        function populateItems() {
            const itemCount = 15;
            
            for (let i = 0; i < itemCount; i++) {
                const itemType = gameState.rng.weightedChoice(CONFIG.ITEM_TYPES.map(item => ({
                    value: item,
                    weight: item.weight
                })));
                
                let position;
                let attempts = 0;
                
                // Find valid position
                do {
                    position = {
                        x: gameState.rng.range(-45, 45),
                        y: 0.5,
                        z: gameState.rng.range(-45, 45)
                    };
                    attempts++;
                } while (isPositionBlocked(position) && attempts < 100);
                
                if (attempts >= 100) continue;
                
                // Create item
                const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const material = new THREE.MeshStandardMaterial({
                    color: itemType.color,
                    roughness: 0.4,
                    metalness: 0.6,
                    emissive: itemType.color,
                    emissiveIntensity: 0.2
                });
                
                const item = new THREE.Mesh(geometry, material);
                item.position.set(position.x, position.y, position.z);
                item.castShadow = true;
                
                // Add glow for rare items
                if (itemType.weight <= 3) {
                    const glow = new THREE.PointLight(itemType.color, 0.5, 5);
                    item.add(glow);
                }
                
                item.userData = {
                    type: 'item',
                    id: itemType.id,
                    name: itemType.name,
                    collected: false,
                    index: i,
                    floatOffset: Math.random() * Math.PI * 2,
                    rotationSpeed: 0.5 + Math.random() * 1
                };
                
                scene.add(item);
                itemMeshes.push(item);
                
                gameState.items.push({
                    id: itemType.id,
                    name: itemType.name,
                    position: position,
                    collected: false,
                    mesh: item
                });
            }
        }

        function populateBots() {
            // Guards
            for (let i = 0; i < CONFIG.GUARD_COUNT; i++) {
                const guardType = gameState.rng.choice(CONFIG.GUARD_TYPES);
                const position = findValidBotPosition();
                
                const bot = createGuardBot(guardType, position, i);
                botMeshes.push(bot.mesh);
                
                gameState.bots.push({
                    type: 'guard',
                    guardType: guardType,
                    position: position,
                    patrolRoute: generatePatrolRoute(position),
                    patrolIndex: 0,
                    alertLevel: 0,
                    state: 'patrolling',
                    lastStateChange: 0,
                    mesh: bot.mesh,
                    visionCone: bot.visionCone
                });
            }
            
            // Inmates
            for (let i = 0; i < CONFIG.INMATE_BOT_COUNT; i++) {
                const inmateType = gameState.rng.choice(CONFIG.INMATE_TYPES);
                const position = findValidBotPosition();
                
                const bot = createInmateBot(inmateType, position);
                botMeshes.push(bot);
                
                gameState.bots.push({
                    type: 'inmate',
                    inmateType: inmateType,
                    position: position,
                    state: 'wandering',
                    activity: getRandomActivity(),
                    lastActivityChange: 0,
                    mesh: bot
                });
            }
        }

        function createGuardBot(guardType, position, id) {
            const group = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.7, 1.8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: guardType.color,
                roughness: 0.3,
                metalness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.9;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xf0c8a0,
                roughness: 0.8
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            group.add(head);
            
            // Hat for higher ranks
            if (guardType.type === 'sergeant' || guardType.type === 'captain') {
                const hatGeometry = new THREE.CylinderGeometry(0.5, 0.6, 0.2, 8);
                const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                hat.position.y = 1.95;
                head.add(hat);
            }
            
            group.position.set(position.x, position.y, position.z);
            group.castShadow = true;
            scene.add(group);
            
            // Vision cone (invisible)
            const coneGeometry = new THREE.ConeGeometry(guardType.vision, guardType.vision, 8);
            const coneMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.1,
                visible: gameState.debugMode
            });
            const visionCone = new THREE.Mesh(coneGeometry, coneMaterial);
            visionCone.rotation.x = Math.PI / 2;
            visionCone.position.y = 1;
            group.add(visionCone);
            
            return { mesh: group, visionCone: visionCone };
        }

        function addAtmosphericEffects() {
            // Fog
            scene.fog = new THREE.Fog(0x0a0a1a, 30, 150);
            
            // Ambient particles
            if (!gameState.performanceMode) {
                const particleCount = 500;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 200;
                    positions[i + 1] = Math.random() * 50;
                    positions[i + 2] = (Math.random() - 0.5) * 200;
                }
                
                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: 0x4cc9f0,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.5
                });
                
                const particleSystem = new THREE.Points(particles, particleMaterial);
                scene.add(particleSystem);
            }
        }

        function clearScene() {
            // Remove all meshes
            [wallMeshes, itemMeshes, botMeshes, lightMeshes].forEach(arr => {
                arr.forEach(mesh => {
                    if (mesh && mesh.parent) {
                        scene.remove(mesh);
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) {
                            if (Array.isArray(mesh.material)) {
                                mesh.material.forEach(m => m.dispose());
                            } else {
                                mesh.material.dispose();
                            }
                        }
                    }
                });
                arr.length = 0;
            });
            
            // Clear game state
            gameState.items = [];
            gameState.bots = [];
        }

        // ============================================================================
        // ENHANCED GAME LOOP
        // ============================================================================
        function initThreeJS() {
            console.log('Initializing enhanced graphics engine...');
            
            try {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a1a);
                
                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 20, 40);
                
                // Renderer with advanced settings
                const canvas = document.getElementById('gameCanvas');
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2;
                
                // Enhanced lighting
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                scene.add(ambientLight);
                
                // Main directional light (sun/moon)
                const mainLight = new THREE.DirectionalLight(0xffffff, 1);
                mainLight.position.set(100, 200, 100);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 4096;
                mainLight.shadow.mapSize.height = 4096;
                mainLight.shadow.camera.near = 0.5;
                mainLight.shadow.camera.far = 500;
                mainLight.shadow.camera.left = -100;
                mainLight.shadow.camera.right = 100;
                mainLight.shadow.camera.top = 100;
                mainLight.shadow.camera.bottom = -100;
                scene.add(mainLight);
                
                // Fill light
                const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.2);
                fillLight.position.set(-100, 50, -100);
                scene.add(fillLight);
                
                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.enablePan = false;
                controls.maxPolarAngle = Math.PI / 2;
                controls.minDistance = 5;
                controls.maxDistance = 50;
                
                // Setup resize handler
                window.addEventListener('resize', onWindowResize);
                
                console.log('Graphics engine initialized successfully');
                return true;
            } catch (error) {
                console.error('Failed to initialize graphics:', error);
                showError(`Graphics error: ${error.message}`);
                return false;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            if (!gameState.gameStarted) {
                requestAnimationFrame(animate);
                return;
            }
            
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const currentTime = Date.now();
            
            try {
                // Update controls
                controls.update();
                
                // Update game state
                updateGameState(deltaTime, currentTime);
                
                // Update time of day
                updateTimeOfDay(deltaTime);
                
                // Update animations
                updateAnimations(deltaTime);
                
                // Update security systems
                updateSecuritySystems(deltaTime);
                
                // Update bots
                updateBotsAI(deltaTime, currentTime);
                
                // Update items
                updateItems(deltaTime);
                
                // Check interactions
                checkInteractions();
                
                // Update minimap
                updateMinimap();
                
                // Update UI
                updateGameUI();
                
                // Render
                renderer.render(scene, camera);
                
            } catch (error) {
                console.error('Game loop error:', error);
            }
        }

        function updateGameState(deltaTime, currentTime) {
            // Update local player
            if (playerMesh) {
                updatePlayerMovement(deltaTime);
                updatePlayerAnimation(deltaTime);
                
                // Send update to partner
                if (currentTime - gameState.lastUpdate > 1000/30) { // 30 FPS updates
                    gameState.lastUpdate = currentTime;
                    sendPlayerUpdate();
                }
            }
            
            // Check win/lose conditions
            checkGameConditions();
        }

        function updatePlayerMovement(deltaTime) {
            const speed = isRunning ? moveSpeed * 2 : (isCrouching ? moveSpeed * 0.5 : moveSpeed);
            const moveVector = new THREE.Vector3(0, 0, 0);
            
            // Keyboard movement
            if (keys['w'] || keys['arrowup']) moveVector.z -= 1;
            if (keys['s'] || keys['arrowdown']) moveVector.z += 1;
            if (keys['a'] || keys['arrowleft']) moveVector.x -= 1;
            if (keys['d'] || keys['arrowright']) moveVector.x += 1;
            
            // Touch movement
            if (touchState.joystick.active) {
                const dx = touchState.joystick.currentX - touchState.joystick.startX;
                const dy = touchState.joystick.currentY - touchState.joystick.startY;
                const magnitude = Math.min(Math.sqrt(dx*dx + dy*dy), 50) / 50;
                
                if (magnitude > 0.1) {
                    const angle = Math.atan2(dy, dx);
                    moveVector.x += Math.cos(angle) * magnitude;
                    moveVector.z += Math.sin(angle) * magnitude;
                }
            }
            
            // Normalize and apply movement
            if (moveVector.length() > 0) {
                moveVector.normalize();
                const forward = camera.getWorldDirection(new THREE.Vector3());
                forward.y = 0;
                forward.normalize();
                
                const right = new THREE.Vector3();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                const moveDirection = new THREE.Vector3();
                moveDirection.addScaledVector(forward, moveVector.z);
                moveDirection.addScaledVector(right, moveVector.x);
                moveDirection.normalize();
                
                playerMesh.position.addScaledVector(moveDirection, speed);
                
                // Face movement direction
                if (moveDirection.length() > 0.1) {
                    playerMesh.lookAt(
                        playerMesh.position.x + moveDirection.x,
                        playerMesh.position.y,
                        playerMesh.position.z + moveDirection.z
                    );
                }
            }
            
            // Jump
            if (keys[' '] && playerMesh.position.y <= 1.1) {
                playerMesh.position.y += 0.3;
                audio.play(audio.sfxCollect, 0.3);
            }
            
            // Gravity
            if (playerMesh.position.y > 1) {
                playerMesh.position.y -= 0.15;
            }
            
            // Boundary check
            const halfSize = CONFIG.PRISON_SIZE / 2 - 3;
            playerMesh.position.x = THREE.MathUtils.clamp(playerMesh.position.x, -halfSize, halfSize);
            playerMesh.position.z = THREE.MathUtils.clamp(playerMesh.position.z, -halfSize, halfSize);
            
            // Update player state
            if (gameState.players[gameState.playerId]) {
                gameState.players[gameState.playerId].position = playerMesh.position;
            }
        }

        function sendPlayerUpdate() {
            if (!playerMesh || !gameState.connectionEstablished) return;
            
            const player = gameState.players[gameState.playerId];
            sendNetworkMessage('playerUpdate', {
                x: playerMesh.position.x,
                y: playerMesh.position.y,
                z: playerMesh.position.z,
                ry: playerMesh.rotation.y,
                health: player.health,
                contraband: player.contraband,
                reputation: player.reputation,
                inventory: player.inventory
            });
        }

        // ============================================================================
        // ENHANCED BOT AI SYSTEM
        // ============================================================================
        function updateBotsAI(deltaTime, currentTime) {
            gameState.bots.forEach((bot, index) => {
                if (!bot.mesh) return;
                
                switch(bot.type) {
                    case 'guard':
                        updateGuardAI(bot, deltaTime, currentTime);
                        break;
                    case 'inmate':
                        updateInmateAI(bot, deltaTime, currentTime);
                        break;
                }
                
                // Update mesh position
                bot.mesh.position.set(bot.position.x, bot.position.y, bot.position.z);
            });
        }

        function updateGuardAI(bot, deltaTime, currentTime) {
            const player = gameState.players[gameState.playerId];
            const playerPos = playerMesh ? playerMesh.position : null;
            
            switch(bot.state) {
                case 'patrolling':
                    updatePatrol(bot, deltaTime);
                    if (playerPos && checkLineOfSight(bot, playerPos)) {
                        bot.state = 'alerted';
                        bot.alertLevel = 50;
                        showMessage("Guard has spotted you!", "warning");
                        audio.play(audio.sfxAlert, 0.7);
                    }
                    break;
                    
                case 'alerted':
                    bot.alertLevel = Math.min(100, bot.alertLevel + deltaTime * 20);
                    if (playerPos) {
                        // Move towards player
                        const dx = playerPos.x - bot.position.x;
                        const dz = playerPos.z - bot.position.z;
                        const distance = Math.sqrt(dx*dx + dz*dz);
                        
                        if (distance > 2) {
                            bot.position.x += (dx / distance) * bot.guardType.speed * 1.5;
                            bot.position.z += (dz / distance) * bot.guardType.speed * 1.5;
                            bot.mesh.lookAt(playerPos.x, bot.position.y, playerPos.z);
                        } else {
                            // Caught player
                            sendToSolitary("Apprehended by guard patrol");
                        }
                    }
                    
                    // Alert other guards
                    if (bot.alertLevel > 70) {
                        alertNearbyGuards(bot.position);
                    }
                    
                    // Calm down if player escapes
                    if (!playerPos || !checkLineOfSight(bot, playerPos)) {
                        bot.alertLevel -= deltaTime * 10;
                        if (bot.alertLevel <= 20) {
                            bot.state = 'patrolling';
                            bot.alertLevel = 0;
                        }
                    }
                    break;
                    
                case 'investigating':
                    // Investigate suspicious activity
                    break;
            }
            
            // Update visual alert indicator
            updateGuardVisuals(bot);
        }

        function updatePatrol(bot, deltaTime) {
            if (!bot.patrolRoute || bot.patrolRoute.length === 0) return;
            
            const target = bot.patrolRoute[bot.patrolIndex];
            const dx = target.x - bot.position.x;
            const dz = target.z - bot.position.z;
            const distance = Math.sqrt(dx*dx + dz*dz);
            
            if (distance < 1) {
                bot.patrolIndex = (bot.patrolIndex + 1) % bot.patrolRoute.length;
            } else {
                bot.position.x += (dx / distance) * bot.guardType.speed;
                bot.position.z += (dz / distance) * bot.guardType.speed;
                bot.mesh.lookAt(target.x, bot.position.y, target.z);
            }
        }

        function checkLineOfSight(bot, targetPos) {
            const dx = targetPos.x - bot.position.x;
            const dz = targetPos.z - bot.position.z;
            const distance = Math.sqrt(dx*dx + dz*dz);
            
            // Check if within vision range
            if (distance > bot.guardType.vision) return false;
            
            // Check field of view
            const botForward = new THREE.Vector3(0, 0, -1);
            botForward.applyEuler(bot.mesh.rotation);
            const toTarget = new THREE.Vector3(dx, 0, dz).normalize();
            const angle = Math.acos(botForward.dot(toTarget));
            
            if (angle > Math.PI/3) return false; // 120 degree FOV
            
            // Simple raycast for obstacles (simplified)
            const direction = new THREE.Vector3(dx, 0, dz).normalize();
            raycaster.set(bot.position, direction);
            const intersects = raycaster.intersectObjects(wallMeshes);
            
            if (intersects.length > 0 && intersects[0].distance < distance) {
                return false;
            }
            
            return true;
        }

        function alertNearbyGuards(position) {
            gameState.bots.forEach((otherBot, index) => {
                if (otherBot.type === 'guard' && otherBot.state !== 'alerted') {
                    const dx = position.x - otherBot.position.x;
                    const dz = position.z - otherBot.position.z;
                    const distance = Math.sqrt(dx*dx + dz*dz);
                    
                    if (distance < 30) {
                        otherBot.state = 'alerted';
                        otherBot.alertLevel = 30;
                        sendNetworkMessage('botUpdate', {
                            index: index,
                            state: 'alerted',
                            alertLevel: 30
                        });
                    }
                }
            });
        }

        function updateGuardVisuals(bot) {
            if (!bot.mesh || !bot.mesh.children[0]) return;
            
            const body = bot.mesh.children[0];
            const baseColor = bot.guardType.color;
            const alertColor = 0xff0000;
            const intensity = bot.alertLevel / 100;
            
            const color = new THREE.Color().lerpColors(
                new THREE.Color(baseColor),
                new THREE.Color(alertColor),
                intensity
            );
            
            body.material.color = color;
            
            // Pulsing effect when alerted
            if (bot.alertLevel > 50) {
                const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.01);
                body.material.emissive = new THREE.Color(alertColor).multiplyScalar(pulse * intensity * 0.5);
            } else {
                body.material.emissive.setHex(0x000000);
            }
        }

        // ============================================================================
        // ENHANCED INTERACTION SYSTEM
        // ============================================================================
        function attemptInteraction() {
            if (!playerMesh) return;
            
            const player = gameState.players[gameState.playerId];
            const interactionRange = 3;
            
            // Check for items
            itemMeshes.forEach((item, index) => {
                if (item.userData.collected) return;
                
                const distance = playerMesh.position.distanceTo(item.position);
                if (distance < interactionRange) {
                    collectItem(item.userData.id, index);
                    return;
                }
            });
            
            // Check for bots
            gameState.bots.forEach((bot, index) => {
                const distance = playerMesh.position.distanceTo(bot.position);
                if (distance < interactionRange) {
                    if (bot.type === 'guard') {
                        interactWithGuard(bot, player);
                    } else if (bot.type === 'inmate') {
                        interactWithInmate(bot, player);
                    }
                }
            });
            
            // Check for interactive objects
            checkInteractiveObjects();
        }

        function collectItem(itemId, index) {
            const player = gameState.players[gameState.playerId];
            
            if (player.inventory.includes(itemId) || player.inventory.length >= 8) {
                showMessage("Inventory full or item already collected", "warning");
                return;
            }
            
            player.inventory.push(itemId);
            player.contraband++;
            
            // Visual feedback
            const item = itemMeshes[index];
            if (item) {
                item.userData.collected = true;
                
                // Collect animation
                const startPos = item.position.clone();
                const endPos = playerMesh.position.clone();
                endPos.y += 2;
                
                const duration = 0.5;
                const startTime = Date.now();
                
                const animateCollection = () => {
                    const elapsed = (Date.now() - startTime) / 1000;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Bezier curve
                    const t = progress;
                    const x = startPos.x * (1-t) + endPos.x * t;
                    const y = startPos.y * (1-t) + endPos.y * t + Math.sin(progress * Math.PI) * 2;
                    const z = startPos.z * (1-t) + endPos.z * t;
                    
                    item.position.set(x, y, z);
                    item.scale.setScalar(1 - progress * 0.5);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateCollection);
                    } else {
                        scene.remove(item);
                    }
                };
                
                animateCollection();
            }
            
            // Audio and visual feedback
            audio.play(audio.sfxCollect);
            showMessage(`Acquired: ${getItemName(itemId)}`, "success");
            
            // Network update
            sendNetworkMessage('itemCollected', { index, itemId });
            
            // UI update
            updateInventoryUI();
            updateEscapeOptions();
        }

        function interactWithGuard(bot, player) {
            if (bot.state === 'alerted') {
                showMessage("Guard is already alerted!", "warning");
                return;
            }
            
            // Check for bribery items
            if (player.inventory.includes('donut')) {
                player.inventory = player.inventory.filter(i => i !== 'donut');
                player.reputation += 15;
                bot.alertLevel = Math.max(0, bot.alertLevel - 40);
                showMessage("Guard bribed with donut! Reputation +15", "success");
                updateInventoryUI();
            } else if (player.inventory.includes('cigarettes')) {
                player.inventory = player.inventory.filter(i => i !== 'cigarettes');
                player.reputation += 10;
                bot.alertLevel = Math.max(0, bot.alertLevel - 20);
                showMessage("Guard bribed with cigarettes! Reputation +10", "success");
                updateInventoryUI();
            } else {
                // Random guard interaction
                const interactions = [
                    "Guard: 'Keep moving, inmate!'",
                    "Guard: 'No loitering in the yard!'",
                    "Guard: 'Back to your cell!'",
                    "Guard glares at you suspiciously.",
                    "Guard checks his watch and ignores you."
                ];
                showMessage(interactions[Math.floor(Math.random() * interactions.length)], "info");
            }
        }

        function interactWithInmate(bot, player) {
            const inmateType = bot.inmateType;
            const responses = {
                lazy: ["'Zzz... Leave me alone...'", "'I'm on break, come back later...'"],
                violent: ["'What you lookin' at?!'", "'You want trouble?! I'll give you trouble!'"],
                helpful: ["'Need something? I know this place like the back of my hand.'", "'I've been here 10 years. What do you need to know?'"],
                schemer: ["'I know a way out, but it'll cost you.'", "'Looking for opportunities? I know all the angles.'"],
                loner: ["*Ignores you*", "'I work alone. Go away.'"]
            };
            
            const response = gameState.rng.choice(responses[inmateType.type] || ["'...'"]);
            showMessage(`Inmate: "${response}"`, "info");
            
            // Helpful inmates provide tips
            if (inmateType.type === 'helpful' && player.contraband > 0) {
                const tips = [
                    "Tip: The laundry truck arrives at 2 PM daily at the east gate.",
                    "Tip: Night guards take 15 minute breaks at 1 AM and 4 AM.",
                    "Tip: There's a weak spot in the fence behind the maintenance shed.",
                    "Tip: The guard captain keeps spare uniforms in his office.",
                    "Tip: The ventilation shafts connect all major buildings."
                ];
                const tip = gameState.rng.choice(tips);
                showMessage(`üí° ${tip}`, "success");
                player.reputation += 10;
            }
            
            // Schemers offer trades
            if (inmateType.type === 'schemer' && player.inventory.length > 0) {
                showMessage("Schemmer offers to trade information for contraband...", "info");
            }
        }

        // ============================================================================
        // ENHANCED ESCAPE SYSTEM
        // ============================================================================
        function startEscape(method) {
            const player = gameState.players[gameState.playerId];
            const option = document.getElementById('escape' + method.charAt(0).toUpperCase() + method.slice(1));
            
            if (option.classList.contains('disabled')) {
                showMessage("Escape requirements not met!", "error");
                return;
            }
            
            if (!checkEscapeLocation(method)) {
                showMessage(`You must be at the correct location for ${method} escape!`, "warning");
                return;
            }
            
            toggleEscapeMenu();
            gameState.escapeInProgress = true;
            player.escapeMethod = method;
            player.escapeStartTime = Date.now();
            
            // Start escape sequence
            showMessage(`Initiating ${method.toUpperCase()} escape protocol...`, "info");
            
            // Network sync
            sendNetworkMessage('escapeAttempt', {
                method: method,
                playerId: gameState.playerId,
                timestamp: Date.now()
            });
            
            // Begin escape minigame
            const escapeTime = calculateEscapeTime(method);
            startEscapeMinigame(method, escapeTime);
        }

        function calculateEscapeTime(method) {
            const baseTimes = {
                tunnel: 20000,
                disguise: 15000,
                riot: 18000,
                parole: 25000
            };
            
            const player = gameState.players[gameState.playerId];
            let time = baseTimes[method] || 15000;
            
            // Partner reduces time
            if (Object.keys(gameState.players).length > 1) time *= 0.75;
            
            // Night reduces time
            if (gameState.isNight) time *= 0.9;
            
            // Items reduce time
            if (method === 'tunnel' && player.inventory.includes('crowbar')) time *= 0.8;
            if (method === 'disguise' && player.inventory.includes('radio')) time *= 0.9;
            
            return Math.max(10000, Math.min(30000, time));
        }

        function startEscapeMinigame(method, duration) {
            // Show progress UI
            const progressUI = document.createElement('div');
            progressUI.id = 'escapeProgressUI';
            progressUI.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                padding: 30px;
                border-radius: 15px;
                text-align: center;
                min-width: 400px;
                z-index: 1002;
            `;
            
            progressUI.innerHTML = `
                <h3 style="color: #4cc9f0;">ESCAPE IN PROGRESS</h3>
                <p style="margin: 20px 0; color: #ffd166;">${getEscapeDescription(method)}</p>
                <div class="progress-bar" style="width: 300px; margin: 20px auto;">
                    <div class="progress-fill" style="width: 0%"></div>
                </div>
                <p id="escapeTimer" style="color: white; font-size: 1.2em;">${(duration/1000).toFixed(1)}s</p>
            `;
            
            document.getElementById('gameContainer').appendChild(progressUI);
            
            // Start timer
            const startTime = Date.now();
            const timerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = (elapsed / duration) * 100;
                
                progressUI.querySelector('.progress-fill').style.width = `${progress}%`;
                progressUI.querySelector('#escapeTimer').textContent = `${((duration - elapsed)/1000).toFixed(1)}s`;
                
                if (elapsed >= duration) {
                    clearInterval(timerInterval);
                    progressUI.remove();
                    
                    // Calculate success
                    const success = calculateEscapeSuccess(method);
                    if (success) {
                        escapeSuccess(method);
                    } else {
                        escapeFailure(method);
                    }
                }
            }, 100);
            
            // Allow cancellation
            const cancelListener = (e) => {
                if (e.key === 'Escape') {
                    clearInterval(timerInterval);
                    progressUI.remove();
                    gameState.escapeInProgress = false;
                    showMessage("Escape cancelled", "warning");
                    window.removeEventListener('keydown', cancelListener);
                }
            };
            window.addEventListener('keydown', cancelListener);
        }

        function calculateEscapeSuccess(method) {
            const player = gameState.players[gameState.playerId];
            let successChance = 0.5;
            
            // Base chances
            const baseChances = { tunnel: 0.6, disguise: 0.7, riot: 0.5, parole: 0.4 };
            successChance = baseChances[method] || 0.5;
            
            // Reputation bonus for riot
            if (method === 'riot') successChance += player.reputation / 200;
            
            // Clean record bonus for parole
            if (method === 'parole' && player.contraband === 0) successChance += 0.3;
            
            // Partner bonus
            if (Object.keys(gameState.players).length > 1) successChance += 0.2;
            
            // Night bonus
            if (gameState.isNight) successChance += 0.15;
            
            // Alert level penalty
            const maxAlert = Math.max(...gameState.bots.filter(b => b.type === 'guard').map(b => b.alertLevel));
            successChance -= maxAlert / 200;
            
            return Math.random() < Math.min(0.95, Math.max(0.1, successChance));
        }

        function escapeSuccess(method) {
            const messages = {
                tunnel: [
                    "You emerge from the tunnel into freedom! The night air has never smelled sweeter.",
                    "The tunnel held, and you're finally free. Time to disappear."
                ],
                disguise: [
                    "The guards salute as you walk out the main gate. Perfect timing.",
                    "Your disguise was flawless. Welcome back to the outside world."
                ],
                riot: [
                    "In the chaos, nobody noticed you slip away. Freedom achieved.",
                    "The diversion worked perfectly. You're out and gone."
                ],
                parole: [
                    "The paperwork cleared. You're a free citizen again.",
                    "Legal loopholes for the win. Enjoy your freedom."
                ]
            };
            
            const message = gameState.rng.choice(messages[method]);
            const victoryScreen = `
                <div style="text-align: center; padding: 50px;">
                    <h1 style="color: #4ade80; font-size: 3em; margin-bottom: 30px;">üéâ MISSION ACCOMPLISHED üéâ</h1>
                    <p style="font-size: 1.5em; color: #ffd166; margin: 30px 0;">${message}</p>
                    <p style="color: #94a3b8;">Escape Method: ${method.toUpperCase()}</p>
                    <button onclick="location.reload()" class="modern-btn" style="margin-top: 40px;">NEW MISSION</button>
                </div>
            `;
            
            showFullScreenMessage(victoryScreen);
            audio.play(audio.sfxCollect, 1);
            
            sendNetworkMessage('gameOver', { success: true, method: method });
        }

        function escapeFailure(method) {
            const reasons = {
                tunnel: "The tunnel collapsed! Structural integrity compromised.",
                disguise: "Your cover was blown! The ID didn't scan properly.",
                riot: "The riot was contained too quickly! Security response was immediate.",
                parole: "The paperwork was rejected! New evidence came to light."
            };
            
            sendToSolitary(`${reasons[method]} ${method} escape failed.`);
            sendNetworkMessage('gameOver', { success: false, method: method });
        }

        // ============================================================================
        // ENHANCED UI SYSTEM
        // ============================================================================
        function updateGameUI() {
            const player = gameState.players[gameState.playerId];
            if (!player) return;
            
            // Update player 1 UI
            updatePlayerUI(1, player);
            
            // Update other players
            Object.keys(gameState.players).forEach(playerId => {
                if (playerId !== gameState.playerId) {
                    updatePlayerUI(2, gameState.players[playerId]);
                }
            });
            
            // Update time indicator
            if (document.getElementById('timeIndicator')) {
                document.getElementById('timeIndicator').style.display = 'block';
                document.getElementById('timeText').textContent = gameState.isNight ? 'NIGHT' : 'DAY';
                document.getElementById('timeProgress').style.width = `${gameState.timeOfDay * 100}%`;
            }
            
            // Update escape progress
            const progress = calculateEscapeProgress();
            document.getElementById('escapeProgress').style.width = `${progress}%`;
        }

        function updatePlayerUI(playerNum, player) {
            const num = playerNum === 1 ? '1' : '2';
            
            // Update health
            const healthElement = document.getElementById(`health${num}`);
            const healthBarElement = document.getElementById(`healthBar${num}`);
            if (healthElement) healthElement.textContent = Math.max(0, player.health);
            if (healthBarElement) healthBarElement.style.width = `${Math.max(0, player.health)}%`;
            
            // Update stats
            document.getElementById(`contraband${num}`).textContent = player.contraband;
            document.getElementById(`rep${num}`).textContent = player.reputation;
            
            // Update location text
            const posElement = document.getElementById(`pos${num}`);
            if (posElement && player.position) {
                const block = Math.floor((player.position.x + 60) / 40);
                const section = Math.floor((player.position.z + 60) / 40);
                posElement.textContent = `SECTOR ${String.fromCharCode(65 + block)}-${section + 1}`;
            }
        }

        function updateInventoryUI() {
            const player = gameState.players[gameState.playerId];
            const inventoryDiv = document.getElementById('inventoryItems');
            const countSpan = document.getElementById('inventoryCount');
            
            if (!inventoryDiv || !countSpan) return;
            
            inventoryDiv.innerHTML = '';
            countSpan.textContent = `(${player.inventory.length}/8)`;
            
            // Create inventory slots
            for (let i = 0; i < 8; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                
                if (i < player.inventory.length) {
                    const itemId = player.inventory[i];
                    const itemType = CONFIG.ITEM_TYPES.find(item => item.id === itemId);
                    if (itemType) {
                        slot.innerHTML = `
                            <div style="font-size: 28px;">${itemType.icon}</div>
                            <div class="item-count">1</div>
                        `;
                        slot.style.borderColor = itemType.color;
                    }
                } else {
                    slot.className += ' empty';
                }
                
                inventoryDiv.appendChild(slot);
            }
        }

        function calculateEscapeProgress() {
            const player = gameState.players[gameState.playerId];
            let progress = 0;
            
            // Items contribute
            progress += player.inventory.length * 8;
            
            // Reputation contributes
            progress += Math.min(player.reputation, 100) * 0.4;
            
            // Contraband penalty
            progress -= player.contraband * 2;
            
            return Math.max(0, Math.min(100, progress));
        }

        // ============================================================================
        // ENHANCED MESSAGE SYSTEM
        // ============================================================================
        function showMessage(text, type = 'info') {
            const messageDiv = document.getElementById('messageDisplay');
            if (!messageDiv) return;
            
            // Clear any existing timeout
            if (messageDiv.timeout) clearTimeout(messageDiv.timeout);
            
            // Set message
            messageDiv.textContent = text;
            messageDiv.style.display = 'block';
            
            // Style based on type
            const styles = {
                info: { borderColor: '#4cc9f0', color: '#4cc9f0' },
                success: { borderColor: '#4ade80', color: '#4ade80' },
                warning: { borderColor: '#fbbf24', color: '#fbbf24' },
                error: { borderColor: '#ef4444', color: '#ef4444' }
            };
            
            Object.assign(messageDiv.style, styles[type] || styles.info);
            
            // Auto-hide
            messageDiv.timeout = setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 4000);
        }

        function showFullScreenMessage(content) {
            const overlay = document.createElement('div');
            overlay.id = 'victoryOverlay';
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.95);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'ui-box';
            contentDiv.style.maxWidth = '600px';
            contentDiv.innerHTML = content;
            
            overlay.appendChild(contentDiv);
            document.getElementById('gameContainer').appendChild(overlay);
        }

        // ============================================================================
        // ENHANCED UTILITY FUNCTIONS
        // ============================================================================
        function generateRandomId() {
            return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
        }

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function updateLoadingProgress(percent) {
            const progressBar = document.getElementById('loadingProgress');
            if (progressBar) {
                progressBar.style.width = `${percent}%`;
            }
        }

        function setLoadingText(text) {
            const element = document.getElementById('loadingText');
            if (element) element.textContent = text;
        }

        function showLoadingScreen(show) {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = show ? 'flex' : 'none';
                if (show) loadingScreen.style.opacity = '1';
            }
        }

        function updateConnectionStatus(status, message) {
            const element = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            if (element && statusText) {
                element.className = `status-${status}`;
                statusText.textContent = message;
            }
        }

        function disableButtons(disabled) {
            ['hostBtn', 'joinBtn', 'tutorialBtn'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = disabled;
            });
        }

        function showError(message) {
            alert(`SYSTEM ERROR: ${message}\n\nPlease refresh and try again.`);
            console.error(message);
        }

        function getItemName(itemId) {
            const item = CONFIG.ITEM_TYPES.find(i => i.id === itemId);
            return item ? item.name : itemId;
        }

        function getEscapeDescription(method) {
            const descriptions = {
                tunnel: "Excavating escape tunnel... Keep quiet!",
                disguise: "Blending in with guard personnel... Stay calm!",
                riot: "Initiating disturbance protocol... Cause chaos!",
                parole: "Processing legal paperwork... Look innocent!"
            };
            return descriptions[method] || "Executing escape plan...";
        }

        // ============================================================================
        // GAME START FUNCTIONS
        // ============================================================================
        function startGame() {
            if (!gameState.isHost || !gameState.connectionEstablished) {
                showMessage("Awaiting partner connection...", "warning");
                return;
            }
            
            setLoadingText("Generating prison facility...");
            showLoadingScreen(true);
            updateLoadingProgress(0);
            
            // Initialize graphics
            if (!initThreeJS()) {
                showError("Graphics initialization failed");
                return;
            }
            
            updateLoadingProgress(30);
            
            // Generate prison
            setTimeout(() => {
                try {
                    generateEnhancedPrison(gameState.prisonSeed);
                    updateLoadingProgress(60);
                    
                    // Create player
                    createPlayer(gameState.playerId, true);
                    updateLoadingProgress(80);
                    
                    // Send start signal
                    sendNetworkMessage('gameStart', {
                        prisonSeed: gameState.prisonSeed,
                        playerPositions: {
                            [gameState.playerId]: { x: -15, y: 1, z: 0 }
                        },
                        timestamp: Date.now()
                    });
                    
                    updateLoadingProgress(100);
                    
                    // Start game
                    setTimeout(startGameLocal, 500);
                    
                } catch (error) {
                    console.error('Start game error:', error);
                    showMessage(`Generation error: ${error.message}`, "error");
                    showLoadingScreen(false);
                }
            }, 1000);
        }

        function startGameLocal() {
            try {
                // Hide screens
                document.getElementById('lobbyScreen').style.display = 'none';
                document.getElementById('gameScreen').style.display = 'block';
                showLoadingScreen(false);
                
                // Set game state
                gameState.gameStarted = true;
                
                // Start music
                audio.playMusic();
                
                // Show objective
                document.getElementById('objective').style.display = 'block';
                
                // Start game loop
                animate();
                
                console.log('Game started successfully!');
                
            } catch (error) {
                console.error('Start local error:', error);
                showMessage(`Start error: ${error.message}`, "error");
            }
        }

        // ============================================================================
        // INPUT HANDLING
        // ============================================================================
        function setupTouchControls() {
            const joystickArea = document.getElementById('joystickArea');
            const joystickKnob = document.getElementById('joystickKnob');
            
            if (!joystickArea || !joystickKnob) return;
            
            let isTouching = false;
            
            joystickArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                
                touchState.joystick.active = true;
                touchState.joystick.startX = touch.clientX - rect.left;
                touchState.joystick.startY = touch.clientY - rect.top;
                touchState.joystick.currentX = touchState.joystick.startX;
                touchState.joystick.currentY = touchState.joystick.startY;
                
                joystickKnob.style.transition = 'none';
                updateJoystickVisual();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!touchState.joystick.active) return;
                
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                
                touchState.joystick.currentX = touch.clientX - rect.left;
                touchState.joystick.currentY = touch.clientY - rect.top;
                
                // Limit to joystick area
                const dx = touchState.joystick.currentX - touchState.joystick.startX;
                const dy = touchState.joystick.currentY - touchState.joystick.startY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const maxDistance = 40;
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(dy, dx);
                    touchState.joystick.currentX = touchState.joystick.startX + Math.cos(angle) * maxDistance;
                    touchState.joystick.currentY = touchState.joystick.startY + Math.sin(angle) * maxDistance;
                }
                
                updateJoystickVisual();
            });
            
            document.addEventListener('touchend', (e) => {
                if (touchState.joystick.active) {
                    touchState.joystick.active = false;
                    joystickKnob.style.transition = 'transform 0.2s';
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                }
            });
        }
        
        function updateJoystickVisual() {
            const joystickKnob = document.getElementById('joystickKnob');
            if (!joystickKnob) return;
            
            const dx = touchState.joystick.currentX - touchState.joystick.startX;
            const dy = touchState.joystick.currentY - touchState.joystick.startY;
            
            joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        }
        
        function mobileAction(action) {
            switch(action) {
                case 'interact':
                    attemptInteraction();
                    break;
                case 'jump':
                    keys[' '] = true;
                    setTimeout(() => keys[' '] = false, 100);
                    break;
                case 'crouch':
                    isCrouching = !isCrouching;
                    break;
            }
        }

        // ============================================================================
        // ADDITIONAL ENHANCEMENTS
        // ============================================================================
        function updateMinimap() {
            if (!gameState.minimapEnabled) return;
            
            const minimap = document.getElementById('minimap');
            if (!minimap || minimap.style.display === 'none') return;
            
            // This would require a separate canvas for minimap rendering
            // For now, just show/hide based on player preference
        }

        function toggleMusic() {
            gameState.audioEnabled = !gameState.audioEnabled;
            if (gameState.audioEnabled) {
                audio.playMusic();
                showMessage("Audio enabled", "success");
            } else {
                audio.stopMusic();
                showMessage("Audio disabled", "info");
            }
        }

        function toggleSFX() {
            gameState.sfxEnabled = !gameState.sfxEnabled;
            showMessage(gameState.sfxEnabled ? "SFX enabled" : "SFX disabled", "info");
        }

        function updateTimeOfDay(deltaTime) {
            if (!gameState.dayNightCycle) return;
            
            gameState.timeOfDay += deltaTime / CONFIG.DAY_CYCLE;
            if (gameState.timeOfDay >= 1) gameState.timeOfDay = 0;
            
            gameState.isNight = gameState.timeOfDay < 0.25 || gameState.timeOfDay > 0.75;
            
            // Update lighting
            const intensity = Math.sin(gameState.timeOfDay * Math.PI) * 0.5 + 0.5;
            const color = gameState.isNight ? 0x87ceeb : 0xffffff;
            
            scene.traverse(child => {
                if (child.isLight && child !== scene.children.find(c => c.type === 'AmbientLight')) {
                    child.intensity = intensity * (child.userData.baseIntensity || 1);
                    if (child.color) child.color.setHex(color);
                }
            });
        }

        // ============================================================================
        // MISSING FUNCTION IMPLEMENTATIONS
        // ============================================================================
        
        // These functions were referenced but not defined in the enhanced version:
        
        function isPositionBlocked(position) {
            // Check if position is inside walls or other blocked areas
            const halfSize = CONFIG.PRISON_SIZE / 2;
            if (Math.abs(position.x) > halfSize - 2 || Math.abs(position.z) > halfSize - 2) {
                return true;
            }
            
            // Check against buildings
            const buildings = [
                { x: 0, z: -45, size: 15 }, // Admin building
                { x: -35, z: -30, size: 10 }, // Cafeteria
                { x: 35, z: -30, size: 8 }, // Infirmary
                { x: 35, z: 30, size: 6 }  // Library
            ];
            
            for (const building of buildings) {
                const dx = position.x - building.x;
                const dz = position.z - building.z;
                if (Math.sqrt(dx*dx + dz*dz) < building.size) {
                    return true;
                }
            }
            
            return false;
        }
        
        function findValidBotPosition() {
            let position;
            let attempts = 0;
            
            do {
                position = {
                    x: gameState.rng.range(-40, 40),
                    y: 1,
                    z: gameState.rng.range(-40, 40)
                };
                attempts++;
            } while (isPositionBlocked(position) && attempts < 100);
            
            return position;
        }
        
        function generatePatrolRoute(startPos) {
            const route = [];
            const points = 4 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < points; i++) {
                route.push({
                    x: startPos.x + gameState.rng.range(-15, 15),
                    z: startPos.z + gameState.rng.range(-15, 15)
                });
            }
            
            return route;
        }
        
        function createInmateBot(inmateType, position) {
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshStandardMaterial({
                color: inmateType.color,
                roughness: 0.7
            });
            
            const inmate = new THREE.Mesh(geometry, material);
            inmate.position.set(position.x, position.y, position.z);
            inmate.castShadow = true;
            
            scene.add(inmate);
            return inmate;
        }
        
        function getRandomActivity() {
            const activities = ['wandering', 'sitting', 'exercising', 'talking'];
            return activities[Math.floor(Math.random() * activities.length)];
        }
        
        function updateAnimations(deltaTime) {
            // Update item floating animations
            itemMeshes.forEach((item, index) => {
                if (item && !item.userData.collected) {
                    item.userData.floatOffset += deltaTime;
                    item.position.y = 0.5 + Math.sin(item.userData.floatOffset) * 0.2;
                    item.rotation.y += deltaTime * item.userData.rotationSpeed;
                }
            });
            
            // Update inmate animations
            gameState.bots.forEach((bot, index) => {
                if (bot.type === 'inmate') {
                    // Simple idle animation
                    if (bot.state === 'wandering') {
                        bot.mesh.position.y = 1 + Math.sin(Date.now() * 0.001 + index) * 0.05;
                    }
                }
            });
        }
        
        function updateSecuritySystems(deltaTime) {
            // Update camera rotations
            wallMeshes.forEach(mesh => {
                if (mesh.userData && mesh.userData.type === 'camera') {
                    mesh.userData.rotation += deltaTime * mesh.userData.speed;
                    mesh.rotation.y = Math.sin(mesh.userData.rotation) * mesh.userData.range;
                }
            });
            
            // Update search lights
            lightMeshes.forEach(light => {
                if (light.isSpotLight) {
                    light.target.position.x = light.position.x + Math.sin(Date.now() * 0.0005) * 30;
                    light.target.position.z = light.position.z + Math.cos(Date.now() * 0.0005) * 30;
                }
            });
        }
        
        function checkInteractiveObjects() {
            // Check for doors, switches, etc.
            wallMeshes.forEach(mesh => {
                if (mesh.userData && mesh.userData.type === 'door') {
                    const distance = playerMesh.position.distanceTo(mesh.position);
                    if (distance < 2) {
                        showMessage("Press E to open door", "info");
                    }
                }
            });
        }
        
        function checkGameConditions() {
            const player = gameState.players[gameState.playerId];
            
            // Health check
            if (player.health <= 0) {
                sendToSolitary("Health depleted");
                return;
            }
            
            // Check if caught by guard
            gameState.bots.forEach(bot => {
                if (bot.type === 'guard' && bot.state === 'alerted') {
                    const distance = playerMesh.position.distanceTo(bot.position);
                    if (distance < 2) {
                        sendToSolitary("Apprehended by security");
                    }
                }
            });
        }
        
        function checkEscapeLocation(method) {
            if (!playerMesh) return false;
            
            const pos = playerMesh.position;
            const halfSize = CONFIG.PRISON_SIZE / 2;
            
            switch(method) {
                case 'tunnel':
                    return Math.abs(pos.x) > halfSize - 10 || Math.abs(pos.z) > halfSize - 10;
                case 'disguise':
                    return pos.z > halfSize - 15 && Math.abs(pos.x) < 15;
                case 'riot':
                    return Math.abs(pos.x) < 30 && Math.abs(pos.z) < 30; // Yard area
                case 'parole':
                    return Math.abs(pos.x) < 15 && pos.z < -35; // Near admin building
            }
            
            return false;
        }
        
        function createPlayer(playerId, isLocal) {
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshStandardMaterial({
                color: isLocal ? 0xef4444 : 0x4cc9f0,
                roughness: 0.5,
                metalness: 0.3,
                emissive: isLocal ? 0xef4444 : 0x4cc9f0,
                emissiveIntensity: 0.1
            });
            
            const player = new THREE.Mesh(geometry, material);
            player.castShadow = true;
            player.receiveShadow = true;
            
            if (isLocal) {
                playerMesh = player;
                playerMesh.position.set(-15, 1, 0);
            } else {
                otherPlayerMesh = player;
                otherPlayerMesh.position.set(15, 1, 0);
            }
            
            scene.add(player);
            
            // Initialize player state
            if (!gameState.players[playerId]) {
                gameState.players[playerId] = {
                    id: playerId,
                    name: isLocal ? 'You' : 'Partner',
                    position: player.position,
                    health: 100,
                    contraband: 0,
                    reputation: 0,
                    inventory: [],
                    isLocal: isLocal,
                    mesh: player
                };
            }
            
            return player;
        }
        
        function updatePlayerAnimation(deltaTime) {
            if (!playerMesh) return;
            
            // Simple walking animation
            if (keys['w'] || keys['a'] || keys['s'] || keys['d'] ||
                keys['arrowup'] || keys['arrowleft'] || keys['arrowdown'] || keys['arrowright'] ||
                touchState.joystick.active) {
                
                const bobSpeed = isRunning ? 0.02 : 0.01;
                playerMesh.position.y = 1 + Math.sin(Date.now() * bobSpeed) * 0.1;
            } else {
                playerMesh.position.y = 1;
            }
        }
        
        function updateItems(deltaTime) {
            // Additional item behaviors can be added here
        }
        
        function updateBot(message) {
            const { index, state, alertLevel } = message.data;
            
            if (gameState.bots[index]) {
                const bot = gameState.bots[index];
                if (state) bot.state = state;
                if (alertLevel !== undefined) bot.alertLevel = alertLevel;
                
                updateGuardVisuals(bot);
            }
        }
        
        function collectItemRemote(message) {
            const { index, itemId } = message.data;
            
            if (itemMeshes[index]) {
                itemMeshes[index].userData.collected = true;
                scene.remove(itemMeshes[index]);
            }
            
            showMessage(`Partner acquired: ${getItemName(itemId)}`, "info");
        }
        
        function displayChatMessage(message) {
            const { sender, data } = message;
            displayChatMessageUI(sender === gameState.playerId ? 'You' : 'Partner', data, sender === gameState.playerId);
        }
        
        function displayChatMessageUI(sender, message, isLocal) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isLocal ? 'you' : 'partner'}`;
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function handleEscapeAttempt(message) {
            const { method, playerId } = message.data;
            showMessage(`Partner initiating ${method} escape...`, "info");
        }
        
        function handleGameOver(message) {
            const { success, method } = message.data;
            if (success) {
                showMessage(`Partner escaped via ${method}!`, "success");
            } else {
                showMessage(`Partner's ${method} escape failed`, "warning");
            }
        }
        
        function sendToSolitary(reason) {
            gameState.gameStarted = false;
            
            // Reset input
            keys = {};
            isRunning = false;
            isCrouching = false;
            
            // Show solitary screen
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('solitaryScreen').style.display = 'flex';
            
            // Set failure message
            document.getElementById('failReason').textContent = reason;
            
            // Random funny message
            const messages = [
                "The guards are enjoying coffee while you're in here...",
                "Solitary: where dreams go to get some rest!",
                "At least the view is consistent... all four walls!",
                "You had time to reconsider your life choices... still worth it!",
                "The warden sends his regards... and a bill for property damage.",
                "Even the cockroaches have more freedom than you right now.",
                "Welcome to your complimentary 'quiet time' vacation package!",
                "The only thing escaping now is your sanity!"
            ];
            
            document.getElementById('funnyMessage').textContent = gameState.rng.choice(messages);
            
            // Show hint
            const hints = Object.values(CONFIG.ESCAPE_HINTS);
            document.getElementById('escapeHint').textContent = gameState.rng.choice(hints);
            
            // Animate
            animateSolitaryScene();
        }
        
        function animateSolitaryScene() {
            const animationDiv = document.getElementById('solitaryAnimation');
            if (!animationDiv) return;
            
            // Create simple animation
            animationDiv.innerHTML = `
                <div style="width: 100%; height: 100%; position: relative; background: #111;">
                    <div id="solitaryCell" style="position: absolute; top: 50px; left: 50px; right: 50px; bottom: 50px; border: 5px solid #333;"></div>
                    <div id="solitaryInmate" style="position: absolute; bottom: 60px; left: 50%; width: 40px; height: 60px; background: #ef4444; border-radius: 10px; transform: translateX(-50%);"></div>
                </div>
            `;
        }
        
        function retryGame() {
            // Clean up
            if (scene) {
                while(scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
            }
            
            if (renderer) {
                renderer.dispose();
            }
            
            // Reset state
            gameState.gameStarted = false;
            gameState.escapeInProgress = false;
            gameState.timeOfDay = 0.25;
            gameState.prisonSeed = Date.now() + Math.floor(Math.random() * 1000);
            
            // Clear arrays
            playerMesh = null;
            otherPlayerMesh = null;
            botMeshes = [];
            itemMeshes = [];
            wallMeshes = [];
            lightMeshes = [];
            
            // Return to game
            document.getElementById('solitaryScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            try {
                initThreeJS();
                generateEnhancedPrison(gameState.prisonSeed);
                createPlayer(gameState.playerId, true);
                
                const player = gameState.players[gameState.playerId];
                if (player) {
                    player.health = 100;
                    player.contraband = 0;
                    player.reputation = 0;
                    player.inventory = [];
                }
                
                gameState.gameStarted = true;
                animate();
                
                showMessage("New attempt! Good luck!", "success");
                
            } catch (e) {
                console.error('Retry error:', e);
                returnToLobby();
            }
        }
        
        function returnToLobby() {
            if (gameState.peer) {
                gameState.peer.close();
            }
            
            gameState.gameStarted = false;
            
            document.getElementById('solitaryScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'flex';
            
            disableButtons(false);
            updateConnectionStatus('disconnected', 'Ready to connect');
        }
        
        function toggleEscapeMenu() {
            const menu = document.getElementById('escapeMenu');
            if (menu.style.display === 'grid') {
                menu.style.display = 'none';
            } else {
                menu.style.display = 'grid';
                updateEscapeOptions();
            }
        }
        
        function hideObjective() {
            document.getElementById('objective').style.display = 'none';
        }
        
        function showTutorial() {
            document.getElementById('tutorialSection').style.display = 'block';
        }
        
        function hideTutorial() {
            document.getElementById('tutorialSection').style.display = 'none';
        }
        
        function cancelJoin() {
            document.getElementById('joinSection').style.display = 'none';
            disableButtons(false);
        }
        
        function cancelHost() {
            if (gameState.peer) {
                gameState.peer.close();
            }
            
            localStorage.removeItem('hostOffer');
            localStorage.removeItem('iceCandidates');
            
            document.getElementById('roomInfo').style.display = 'none';
            disableButtons(false);
            updateConnectionStatus('disconnected', 'Ready to connect');
        }

        // ============================================================================
        // KEYBOARD EVENT LISTENERS
        // ============================================================================
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            switch(key) {
                case 'shift':
                    isRunning = true;
                    break;
                case 'control':
                    isCrouching = true;
                    break;
                case 'e':
                    if (!gameState.escapeInProgress) attemptInteraction();
                    break;
                case 'f':
                    if (!gameState.escapeInProgress) attemptFight();
                    break;
                case 'tab':
                    toggleInventory();
                    e.preventDefault();
                    break;
                case 'c':
                    toggleChat();
                    e.preventDefault();
                    break;
                case 'm':
                    if (!gameState.escapeInProgress) toggleEscapeMenu();
                    e.preventDefault();
                    break;
                case 'enter':
                    if (document.getElementById('chat').style.display === 'block') {
                        sendChatMessage();
                        e.preventDefault();
                    }
                    break;
                case 'escape':
                    const chat = document.getElementById('chat');
                    const escapeMenu = document.getElementById('escapeMenu');
                    const inventory = document.getElementById('inventory');
                    
                    if (chat.style.display === 'block') {
                        toggleChat();
                    } else if (escapeMenu.style.display === 'grid') {
                        toggleEscapeMenu();
                    } else if (inventory.style.display === 'block') {
                        toggleInventory();
                    }
                    e.preventDefault();
                    break;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = false;
            
            if (key === 'shift') isRunning = false;
            if (key === 'control') isCrouching = false;
        });
        
        // Chat input handling
        document.getElementById('chatInput')?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });
        
        // ============================================================================
        // INITIALIZATION COMPLETE
        // ============================================================================
        console.log('Cell Block Zero - Enhanced Edition fully loaded and ready!');
        
        // Global error handling
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            showMessage(`Error: ${event.message}`, "error");
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            showMessage('Network error occurred', "error");
        });
        
        // Cleanup on exit
        window.addEventListener('beforeunload', () => {
            if (gameState.peer) {
                gameState.peer.close();
            }
            if (renderer) {
                renderer.dispose();
            }
            // Clean localStorage
            localStorage.removeItem('hostOffer');
            localStorage.removeItem('iceCandidates');
            localStorage.removeItem('playerAnswer');
            localStorage.removeItem('playerIceCandidate');
        });

    </script>
</body>
</html>
