<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER RUNNER 2077 | WebGL Parkour FPS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', 'Arial Narrow', sans-serif;
            background: #000;
            color: #0ff;
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #uiOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s;
        }
        
        .cyberpunk-logo {
            font-size: 4rem;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px #ff00ff;
            margin-bottom: 30px;
            animation: glitch 3s infinite;
        }
        
        .loading-bar-container {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            border-radius: 2px;
            transition: width 0.3s;
        }
        
        .loading-text {
            color: #0ff;
            font-size: 1.2rem;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        /* Main HUD */
        .hud {
            padding: 20px;
        }
        
        .top-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .mission-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-left: 3px solid #ff00ff;
            max-width: 400px;
        }
        
        .mission-title {
            color: #ff00ff;
            font-size: 1.2rem;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .mission-objective {
            color: #0ff;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .stats-container {
            display: flex;
            gap: 30px;
        }
        
        .stat-box {
            text-align: center;
            min-width: 100px;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #0ff;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
        }
        
        /* Health and Energy Bars */
        .bars-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 300px;
        }
        
        .bar {
            margin-bottom: 15px;
        }
        
        .bar-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .bar-name {
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }
        
        .bar-value {
            color: #ff00ff;
            font-weight: bold;
        }
        
        .bar-track {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s;
            position: relative;
        }
        
        .health-bar .bar-fill {
            background: linear-gradient(90deg, #ff0000, #ff3300);
            box-shadow: 0 0 10px #ff3300;
        }
        
        .energy-bar .bar-fill {
            background: linear-gradient(90deg, #00ffff, #0088ff);
            box-shadow: 0 0 10px #00ffff;
        }
        
        /* Weapons */
        .weapon-hud {
            position: fixed;
            bottom: 30px;
            right: 30px;
            text-align: right;
        }
        
        .weapon-name {
            color: #ff00ff;
            font-size: 1.5rem;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .ammo-count {
            color: #0ff;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .ammo-type {
            color: rgba(0, 255, 255, 0.5);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Crosshair */
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        .crosshair-inner {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .crosshair-line {
            position: absolute;
            background: #00ffff;
            box-shadow: 0 0 5px #00ffff;
        }
        
        .crosshair-line.top {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
        }
        
        .crosshair-line.bottom {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
        }
        
        .crosshair-line.left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 2px;
        }
        
        .crosshair-line.right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 2px;
        }
        
        /* Abilities HUD */
        .abilities-hud {
            position: fixed;
            bottom: 150px;
            right: 30px;
            display: flex;
            gap: 15px;
        }
        
        .ability-slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .ability-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .ability-key {
            position: absolute;
            bottom: 5px;
            font-size: 0.8rem;
            color: #ff00ff;
        }
        
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 0, 255, 0.5);
            transition: height 0.1s;
        }
        
        /* Minimap */
        .minimap-container {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            overflow: hidden;
            padding: 10px;
        }
        
        .minimap-title {
            color: #ff00ff;
            text-align: center;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .minimap {
            width: 100%;
            height: calc(100% - 30px);
            background: rgba(0, 20, 40, 0.9);
            position: relative;
        }
        
        /* Objective Marker */
        .objective-marker {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff00ff;
            text-align: center;
            pointer-events: none;
            animation: pulse 2s infinite;
        }
        
        .objective-distance {
            font-size: 1.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ff00ff;
        }
        
        .objective-text {
            font-size: 1rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        /* Damage Indicator */
        .damage-indicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 10;
        }
        
        /* Messages */
        .message-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            text-align: center;
            width: 80%;
        }
        
        .message {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00ff;
            padding: 20px 40px;
            margin-bottom: 10px;
            color: #0ff;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
        }
        
        .message.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Pause Menu */
        #pauseMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        
        .pause-title {
            font-size: 4rem;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 50px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        
        .pause-menu {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 300px;
        }
        
        .pause-button {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #0ff;
            padding: 20px;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .pause-button:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #ff00ff;
            transform: scale(1.05);
        }
        
        /* Tutorial */
        .tutorial-hint {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            padding: 15px 30px;
            color: #0ff;
            text-align: center;
            max-width: 500px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tutorial-hint.show {
            opacity: 1;
        }
        
        /* Animations */
        @keyframes glitch {
            0% { transform: translate(0); }
            2% { transform: translate(-2px, 2px); }
            4% { transform: translate(-2px, -2px); }
            6% { transform: translate(2px, 2px); }
            8% { transform: translate(2px, -2px); }
            10% { transform: translate(0); }
            100% { transform: translate(0); }
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
        }
        
        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        
        /* Grid Overlay */
        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 1;
        }
        
        /* Scanline Effect */
        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            pointer-events: none;
            z-index: 3;
            animation: scanline 2s linear infinite;
        }
        
        @keyframes scanline {
            0% { top: 0; }
            100% { top: 100%; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="cyberpunk-logo">CYBER RUNNER 2077</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">INITIALIZING NEURAL LINK...</div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameContainer"></canvas>

    <!-- UI Overlay -->
    <div id="uiOverlay">
        <!-- Grid Overlay -->
        <div class="grid-overlay"></div>
        
        <!-- Scanline -->
        <div class="scanline"></div>
        
        <!-- HUD -->
        <div class="hud">
            <div class="top-bar">
                <div class="mission-info">
                    <div class="mission-title" id="missionTitle">INFILTRATE MEGACORP TOWER</div>
                    <div class="mission-objective" id="missionObjective">Upload virus to central server ‚Ä¢ Eliminate security</div>
                </div>
                <div class="stats-container">
                    <div class="stat-box">
                        <div class="stat-value" id="scoreValue">0</div>
                        <div class="stat-label">CREDITS</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="killCount">0</div>
                        <div class="stat-label">ELIMINATIONS</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="timeValue">00:00</div>
                        <div class="stat-label">MISSION TIME</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Health and Energy Bars -->
        <div class="bars-container">
            <div class="bar health-bar">
                <div class="bar-label">
                    <div class="bar-name">NEURAL INTEGRITY</div>
                    <div class="bar-value" id="healthValue">100%</div>
                </div>
                <div class="bar-track">
                    <div class="bar-fill" id="healthBar" style="width: 100%"></div>
                </div>
            </div>
            <div class="bar energy-bar">
                <div class="bar-label">
                    <div class="bar-name">CYBERNETIC ENERGY</div>
                    <div class="bar-value" id="energyValue">100%</div>
                </div>
                <div class="bar-track">
                    <div class="bar-fill" id="energyBar" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <!-- Weapon HUD -->
        <div class="weapon-hud">
            <div class="weapon-name" id="weaponName">PLASMA RIFLE</div>
            <div class="ammo-count" id="ammoCount">‚àû/‚àû</div>
            <div class="ammo-type" id="ammoType">ENERGY CELLS</div>
        </div>

        <!-- Abilities -->
        <div class="abilities-hud">
            <div class="ability-slot" id="ability1">
                <div class="ability-icon">‚ö°</div>
                <div class="ability-key">Q</div>
                <div class="ability-cooldown" id="ability1Cooldown"></div>
            </div>
            <div class="ability-slot" id="ability2">
                <div class="ability-icon">üëÅÔ∏è</div>
                <div class="ability-key">E</div>
                <div class="ability-cooldown" id="ability2Cooldown"></div>
            </div>
            <div class="ability-slot" id="ability3">
                <div class="ability-icon">üåÄ</div>
                <div class="ability-key">SHIFT</div>
                <div class="ability-cooldown" id="ability3Cooldown"></div>
            </div>
        </div>

        <!-- Minimap -->
        <div class="minimap-container">
            <div class="minimap-title">TACTICAL DISPLAY</div>
            <div class="minimap" id="minimap"></div>
        </div>

        <!-- Crosshair -->
        <div class="crosshair">
            <div class="crosshair-inner">
                <div class="crosshair-dot"></div>
                <div class="crosshair-line top"></div>
                <div class="crosshair-line bottom"></div>
                <div class="crosshair-line left"></div>
                <div class="crosshair-line right"></div>
            </div>
        </div>

        <!-- Objective Marker -->
        <div class="objective-marker" id="objectiveMarker">
            <div class="objective-distance">50m</div>
            <div class="objective-text">UPLOAD POINT</div>
        </div>

        <!-- Damage Indicator -->
        <div class="damage-indicator" id="damageIndicator"></div>

        <!-- Messages -->
        <div class="message-container" id="messageContainer"></div>

        <!-- Tutorial Hint -->
        <div class="tutorial-hint" id="tutorialHint">
            Use <span style="color:#ff00ff">WASD</span> to move ‚Ä¢ <span style="color:#ff00ff">MOUSE</span> to aim ‚Ä¢ <span style="color:#ff00ff">SPACE</span> to jump
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu">
        <div class="pause-title">PAUSED</div>
        <div class="pause-menu">
            <div class="pause-button" id="resumeButton">RESUME MISSION</div>
            <div class="pause-button" id="restartButton">RESTART LEVEL</div>
            <div class="pause-button" id="settingsButton">NEURAL SETTINGS</div>
            <div class="pause-button" id="quitButton">DISCONNECT</div>
        </div>
    </div>

    <script>
        // ================================
        // GAME CONFIGURATION
        // ================================
        const CONFIG = {
            // Graphics
            BLOOM_STRENGTH: 1.5,
            BLOOM_RADIUS: 0.4,
            BLOOM_THRESHOLD: 0.85,
            FOG_DENSITY: 0.002,
            FOG_COLOR: 0x000022,
            
            // Player
            PLAYER_SPEED: 5,
            PLAYER_JUMP_FORCE: 8,
            PLAYER_SPRINT_MULTIPLIER: 1.8,
            PLAYER_HEALTH: 100,
            PLAYER_ENERGY: 100,
            PLAYER_ENERGY_REGEN: 0.5,
            
            // Gameplay
            GRAVITY: -20,
            ENEMY_COUNT: 15,
            OBJECTIVE_DISTANCE: 200,
            TIME_LIMIT: 600, // 10 minutes
            
            // Weapons
            WEAPONS: {
                plasma: {
                    name: 'PLASMA RIFLE',
                    damage: 25,
                    fireRate: 10,
                    energyCost: 5,
                    accuracy: 0.95,
                    ammoType: 'ENERGY CELLS'
                },
                railgun: {
                    name: 'RAILGUN',
                    damage: 75,
                    fireRate: 2,
                    energyCost: 20,
                    accuracy: 1.0,
                    ammoType: 'KINETIC ROUNDS'
                }
            },
            
            // Abilities
            ABILITIES: {
                dash: {
                    name: 'CYBER DASH',
                    cooldown: 3,
                    energyCost: 15,
                    duration: 0.3,
                    speedMultiplier: 5
                },
                scan: {
                    name: 'NEURAL SCAN',
                    cooldown: 8,
                    energyCost: 10,
                    duration: 5,
                    revealRadius: 50
                },
                timeWarp: {
                    name: 'TIME DILATION',
                    cooldown: 15,
                    energyCost: 30,
                    duration: 4,
                    slowFactor: 0.3
                }
            }
        };

        // ================================
        // GAME STATE
        // ================================
        let game = {
            // Core
            scene: null,
            camera: null,
            renderer: null,
            composer: null,
            clock: null,
            
            // Player
            player: {
                mesh: null,
                body: null,
                position: new THREE.Vector3(0, 10, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: new THREE.Euler(0, 0, 0),
                health: CONFIG.PLAYER_HEALTH,
                energy: CONFIG.PLAYER_ENERGY,
                score: 0,
                kills: 0,
                weapon: 'plasma',
                abilities: {
                    dash: { active: false, cooldown: 0 },
                    scan: { active: false, cooldown: 0 },
                    timeWarp: { active: false, cooldown: 0 }
                }
            },
            
            // World
            world: {
                platforms: [],
                enemies: [],
                pickups: [],
                buildings: [],
                lights: [],
                particles: []
            },
            
            // Game State
            state: 'loading',
            timeElapsed: 0,
            objectiveComplete: false,
            gameOver: false,
            
            // Input
            keys: {},
            mouse: { x: 0, y: 0, buttons: {} },
            
            // UI
            ui: {
                tutorialShown: false,
                lastMessageTime: 0,
                damageFlash: 0
            }
        };

        // ================================
        // INITIALIZATION
        // ================================
        async function init() {
            try {
                // Initialize Three.js
                initThreeJS();
                
                // Create game world
                await createWorld();
                
                // Set up player
                createPlayer();
                
                // Set up enemies
                createEnemies();
                
                // Set up pickups
                createPickups();
                
                // Set up lighting
                setupLighting();
                
                // Set up post-processing
                setupPostProcessing();
                
                // Set up event listeners
                setupEventListeners();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        game.state = 'playing';
                        showMessage('INFILTRATION PROTOCOL ACTIVE', 'Get to the upload point');
                        showTutorialHint();
                    }, 1000);
                }, 500);
                
                // Start game loop
                game.clock = new THREE.Clock();
                animate();
                
            } catch (error) {
                console.error('Failed to initialize game:', error);
                showMessage('SYSTEM ERROR', 'Failed to initialize neural interface');
            }
        }

        function initThreeJS() {
            // Scene
            game.scene = new THREE.Scene();
            game.scene.fog = new THREE.Fog(CONFIG.FOG_COLOR, 10, 1000);
            
            // Camera
            game.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            game.camera.position.set(0, 10, 20);
            
            // Renderer
            game.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameContainer'),
                antialias: true,
                alpha: true
            });
            game.renderer.setSize(window.innerWidth, window.innerHeight);
            game.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            game.renderer.shadowMap.enabled = true;
            game.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            game.renderer.outputEncoding = THREE.sRGBEncoding;
        }

        async function createWorld() {
            // Skybox
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000033,
                side: THREE.BackSide
            });
            const skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            game.scene.add(skybox);
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x111122,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.position.y = -5;
            game.scene.add(ground);
            
            // Create cyberpunk cityscape
            createCityscape();
            
            // Create platforms for parkour
            createParkourCourse();
            
            // Add decorative particles
            createParticles();
        }

        function createCityscape() {
            // Create futuristic buildings
            const buildingColors = [0x222233, 0x333344, 0x223355, 0x334466];
            const buildingHeights = [50, 75, 100, 125, 150];
            
            for (let i = 0; i < 20; i++) {
                const width = 15 + Math.random() * 20;
                const depth = 15 + Math.random() * 20;
                const height = buildingHeights[Math.floor(Math.random() * buildingHeights.length)];
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: 0x000011
                });
                const building = new THREE.Mesh(geometry, material);
                
                // Position buildings around the edges
                const angle = (i / 20) * Math.PI * 2;
                const radius = 150 + Math.random() * 100;
                building.position.x = Math.cos(angle) * radius;
                building.position.z = Math.sin(angle) * radius;
                building.position.y = height / 2 - 5;
                
                building.castShadow = true;
                building.receiveShadow = true;
                
                game.scene.add(building);
                game.world.buildings.push(building);
                
                // Add windows
                addWindows(building, width, height, depth);
            }
            
            // Create main tower (objective)
            const towerGeometry = new THREE.CylinderGeometry(20, 30, 300, 8);
            const towerMaterial = new THREE.MeshStandardMaterial({
                color: 0xaa00ff,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x220044
            });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.set(0, 150, -CONFIG.OBJECTIVE_DISTANCE);
            tower.castShadow = true;
            game.scene.add(tower);
            
            // Add glow to tower
            const towerLight = new THREE.PointLight(0xff00ff, 2, 200);
            towerLight.position.copy(tower.position);
            towerLight.position.y += 150;
            game.scene.add(towerLight);
        }

        function addWindows(building, width, height, depth) {
            const windowCount = Math.floor(height / 10);
            const windowColor = 0x00ffff;
            
            for (let i = 0; i < windowCount; i++) {
                const windowGeometry = new THREE.PlaneGeometry(3, 5);
                const windowMaterial = new THREE.MeshBasicMaterial({
                    color: windowColor,
                    transparent: true,
                    opacity: 0.7,
                    emissive: windowColor
                });
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                
                // Randomly place windows on building faces
                const face = Math.floor(Math.random() * 4);
                const y = (i / windowCount) * height - height / 2 + 2.5;
                
                switch(face) {
                    case 0: // Front
                        window.position.set(0, y, depth / 2 + 0.1);
                        break;
                    case 1: // Back
                        window.position.set(0, y, -depth / 2 - 0.1);
                        window.rotation.y = Math.PI;
                        break;
                    case 2: // Left
                        window.position.set(-width / 2 - 0.1, y, 0);
                        window.rotation.y = Math.PI / 2;
                        break;
                    case 3: // Right
                        window.position.set(width / 2 + 0.1, y, 0);
                        window.rotation.y = -Math.PI / 2;
                        break;
                }
                
                building.add(window);
            }
        }

        function createParkourCourse() {
            // Create a series of platforms for parkour
            const platformColors = [0x00aaff, 0xff00aa, 0xaa00ff, 0x00ffaa];
            const platformTypes = ['box', 'cylinder', 'platform', 'bridge'];
            
            let lastPosition = new THREE.Vector3(0, 5, 0);
            
            for (let i = 0; i < 30; i++) {
                const type = platformTypes[Math.floor(Math.random() * platformTypes.length)];
                const color = platformColors[Math.floor(Math.random() * platformColors.length)];
                
                let platform;
                
                switch(type) {
                    case 'box':
                        platform = createBoxPlatform(lastPosition, color);
                        break;
                    case 'cylinder':
                        platform = createCylinderPlatform(lastPosition, color);
                        break;
                    case 'platform':
                        platform = createThinPlatform(lastPosition, color);
                        break;
                    case 'bridge':
                        platform = createBridge(lastPosition, color);
                        break;
                }
                
                if (platform) {
                    game.scene.add(platform);
                    game.world.platforms.push(platform);
                    
                    // Update last position for next platform
                    lastPosition.x += (Math.random() - 0.5) * 40;
                    lastPosition.y += (Math.random() - 0.5) * 15;
                    lastPosition.z -= 15 + Math.random() * 20;
                    
                    // Ensure minimum height
                    lastPosition.y = Math.max(5, lastPosition.y);
                    
                    // Add some obstacles
                    if (Math.random() > 0.7) {
                        addObstacles(platform.position);
                    }
                }
            }
        }

        function createBoxPlatform(position, color) {
            const geometry = new THREE.BoxGeometry(15, 2, 15);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.6,
                emissive: color,
                emissiveIntensity: 0.2
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.copy(position);
            platform.castShadow = true;
            platform.receiveShadow = true;
            
            // Add edge glow
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x00ffff })
            );
            platform.add(line);
            
            return platform;
        }

        function createCylinderPlatform(position, color) {
            const geometry = new THREE.CylinderGeometry(8, 8, 2, 8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.6,
                emissive: color,
                emissiveIntensity: 0.2
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.copy(position);
            platform.castShadow = true;
            platform.receiveShadow = true;
            return platform;
        }

        function createThinPlatform(position, color) {
            const geometry = new THREE.BoxGeometry(30, 0.5, 8);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.6,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.copy(position);
            platform.castShadow = true;
            platform.receiveShadow = true;
            return platform;
        }

        function createBridge(position, color) {
            const geometry = new THREE.BoxGeometry(40, 0.5, 6);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.6,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.copy(position);
            platform.castShadow = true;
            platform.receiveShadow = true;
            return platform;
        }

        function addObstacles(position) {
            // Create laser fences or energy barriers
            const obstacleTypes = ['laser', 'energy', 'spike'];
            const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            
            switch(type) {
                case 'laser':
                    createLaserFence(position);
                    break;
                case 'energy':
                    createEnergyBarrier(position);
                    break;
                case 'spike':
                    createSpikeTrap(position);
                    break;
            }
        }

        function createLaserFence(position) {
            const count = 3 + Math.floor(Math.random() * 3);
            const spacing = 4;
            
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.CylinderGeometry(0.2, 0.2, 15, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8
                });
                const laser = new THREE.Mesh(geometry, material);
                
                laser.position.copy(position);
                laser.position.x += (i - (count - 1) / 2) * spacing;
                laser.position.y += 7.5;
                
                game.scene.add(laser);
                game.world.platforms.push(laser);
            }
        }

        function createEnergyBarrier(position) {
            const geometry = new THREE.PlaneGeometry(20, 15);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                emissive: 0x00ffff
            });
            const barrier = new THREE.Mesh(geometry, material);
            
            barrier.position.copy(position);
            barrier.position.y += 7.5;
            barrier.rotation.y = Math.random() * Math.PI;
            
            game.scene.add(barrier);
            game.world.platforms.push(barrier);
        }

        function createSpikeTrap(position) {
            const count = 9;
            const spacing = 3;
            
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.ConeGeometry(0.5, 2, 4);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xff3300,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.5
                });
                const spike = new THREE.Mesh(geometry, material);
                
                spike.position.copy(position);
                spike.position.x += (Math.floor(i / 3) - 1) * spacing;
                spike.position.z += (i % 3 - 1) * spacing;
                spike.position.y += 1;
                
                game.scene.add(spike);
                game.world.platforms.push(spike);
            }
        }

        function createParticles() {
            // Create floating energy particles
            for (let i = 0; i < 100; i++) {
                const geometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.3);
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0x00ffff : 0xff00ff,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.set(
                    (Math.random() - 0.5) * 300,
                    20 + Math.random() * 100,
                    (Math.random() - 0.5) * 300
                );
                
                particle.userData = {
                    speed: 0.1 + Math.random() * 0.3,
                    amplitude: 5 + Math.random() * 10,
                    offset: Math.random() * Math.PI * 2
                };
                
                game.scene.add(particle);
                game.world.particles.push(particle);
            }
        }

        function createPlayer() {
            // Create player capsule
            const geometry = new THREE.CapsuleGeometry(1, 3, 8, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x002244
            });
            game.player.mesh = new THREE.Mesh(geometry, material);
            game.player.mesh.position.copy(game.player.position);
            game.player.mesh.castShadow = true;
            game.scene.add(game.player.mesh);
            
            // Create player weapon
            createWeapon();
        }

        function createWeapon() {
            const weaponGroup = new THREE.Group();
            
            // Weapon body
            const bodyGeometry = new THREE.BoxGeometry(3, 0.8, 0.8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                roughness: 0.2,
                metalness: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            weaponGroup.add(body);
            
            // Weapon barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
            const barrelMaterial = new THREE.MeshStandardMaterial({
                color: 0x888899,
                roughness: 0.1,
                metalness: 0.9
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.z = -1.5;
            weaponGroup.add(barrel);
            
            // Energy core
            const coreGeometry = new THREE.SphereGeometry(0.3);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.z = 0.5;
            weaponGroup.add(core);
            
            weaponGroup.position.set(1, -0.5, -2);
            game.player.mesh.add(weaponGroup);
        }

        function createEnemies() {
            const enemyTypes = ['drone', 'sentry', 'guard'];
            
            for (let i = 0; i < CONFIG.ENEMY_COUNT; i++) {
                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                const enemy = createEnemy(type);
                
                // Position enemy on a platform
                if (game.world.platforms.length > 0) {
                    const platform = game.world.platforms[Math.floor(Math.random() * game.world.platforms.length)];
                    enemy.position.copy(platform.position);
                    enemy.position.y += 5;
                    enemy.position.x += (Math.random() - 0.5) * 10;
                    enemy.position.z += (Math.random() - 0.5) * 10;
                }
                
                game.scene.add(enemy);
                game.world.enemies.push({
                    mesh: enemy,
                    health: 100,
                    type: type,
                    lastShot: 0,
                    target: null,
                    state: 'patrol'
                });
            }
        }

        function createEnemy(type) {
            let enemy;
            
            switch(type) {
                case 'drone':
                    enemy = createDrone();
                    break;
                case 'sentry':
                    enemy = createSentry();
                    break;
                case 'guard':
                    enemy = createGuard();
                    break;
            }
            
            return enemy;
        }

        function createDrone() {
            const group = new THREE.Group();
            
            // Drone body
            const bodyGeometry = new THREE.SphereGeometry(1.5, 8, 6);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                emissive: 0x331100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            
            // Drone wings
            const wingGeometry = new THREE.BoxGeometry(4, 0.2, 1);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444
            });
            
            for (let i = 0; i < 4; i++) {
                const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                wing.rotation.y = (i / 4) * Math.PI * 2;
                group.add(wing);
            }
            
            // Red eye
            const eyeGeometry = new THREE.SphereGeometry(0.4);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                emissive: 0xff0000
            });
            const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eye.position.z = 1.5;
            group.add(eye);
            
            return group;
        }

        function createSentry() {
            const group = new THREE.Group();
            
            // Sentry base
            const baseGeometry = new THREE.CylinderGeometry(2, 3, 1, 6);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x666677
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            group.add(base);
            
            // Sentry turret
            const turretGeometry = new THREE.BoxGeometry(1.5, 1.5, 2);
            const turretMaterial = new THREE.MeshStandardMaterial({
                color: 0x888899
            });
            const turret = new THREE.Mesh(turretGeometry, turretMaterial);
            turret.position.y = 1.5;
            group.add(turret);
            
            // Gun barrels
            const barrelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
            const barrelMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333
            });
            
            const leftBarrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            leftBarrel.position.set(-0.5, 1.5, -1);
            group.add(leftBarrel);
            
            const rightBarrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            rightBarrel.position.set(0.5, 1.5, -1);
            group.add(rightBarrel);
            
            return group;
        }

        function createGuard() {
            const group = new THREE.Group();
            
            // Guard body
            const bodyGeometry = new THREE.CapsuleGeometry(1, 3, 4, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x334455
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            
            // Guard head
            const headGeometry = new THREE.SphereGeometry(1);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0x223344
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.5;
            group.add(head);
            
            // Weapon
            const weaponGeometry = new THREE.BoxGeometry(2, 0.5, 0.5);
            const weaponMaterial = new THREE.MeshStandardMaterial({
                color: 0x666677
            });
            const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            weapon.position.set(1, 1, 0);
            group.add(weapon);
            
            return group;
        }

        function createPickups() {
            const pickupTypes = ['health', 'energy', 'ammo', 'score'];
            
            for (let i = 0; i < 20; i++) {
                const type = pickupTypes[Math.floor(Math.random() * pickupTypes.length)];
                const pickup = createPickup(type);
                
                // Position pickup
                pickup.position.set(
                    (Math.random() - 0.5) * 200,
                    5 + Math.random() * 20,
                    (Math.random() - 0.5) * 200 - 100
                );
                
                game.scene.add(pickup);
                game.world.pickups.push({
                    mesh: pickup,
                    type: type,
                    value: type === 'score' ? 100 : 25,
                    collected: false
                });
            }
        }

        function createPickup(type) {
            const group = new THREE.Group();
            let color, icon;
            
            switch(type) {
                case 'health':
                    color = 0xff0000;
                    icon = '‚ù§Ô∏è';
                    break;
                case 'energy':
                    color = 0x00ffff;
                    icon = '‚ö°';
                    break;
                case 'ammo':
                    color = 0xffff00;
                    icon = 'üîã';
                    break;
                case 'score':
                    color = 0x00ff00;
                    icon = 'üíé';
                    break;
            }
            
            // Create floating crystal
            const geometry = new THREE.OctahedronGeometry(1);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const crystal = new THREE.Mesh(geometry, material);
            group.add(crystal);
            
            return group;
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x222233, 0.3);
            game.scene.add(ambientLight);
            
            // Main directional light (moonlight)
            const directionalLight = new THREE.DirectionalLight(0x4466ff, 0.5);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            game.scene.add(directionalLight);
            
            // Neon lights
            for (let i = 0; i < 10; i++) {
                const color = Math.random() > 0.5 ? 0xff00ff : 0x00ffff;
                const light = new THREE.PointLight(color, 1, 30);
                light.position.set(
                    (Math.random() - 0.5) * 200,
                    10 + Math.random() * 20,
                    (Math.random() - 0.5) * 200
                );
                game.scene.add(light);
                game.world.lights.push(light);
            }
        }

        function setupPostProcessing() {
            game.composer = new THREE.EffectComposer(game.renderer);
            
            // Render pass
            const renderPass = new THREE.RenderPass(game.scene, game.camera);
            game.composer.addPass(renderPass);
            
            // Bloom pass
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.BLOOM_STRENGTH,
                CONFIG.BLOOM_RADIUS,
                CONFIG.BLOOM_THRESHOLD
            );
            game.composer.addPass(bloomPass);
            
            // Copy pass
            const copyPass = new THREE.ShaderPass(THREE.CopyShader);
            copyPass.renderToScreen = true;
            game.composer.addPass(copyPass);
        }

        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                game.keys[e.code] = true;
                
                if (e.code === 'Escape') {
                    togglePause();
                }
                
                if (e.code === 'KeyQ') {
                    activateAbility('dash');
                }
                
                if (e.code === 'KeyE') {
                    activateAbility('scan');
                }
                
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                    activateAbility('timeWarp');
                }
                
                if (e.code === 'KeyR') {
                    reloadWeapon();
                }
                
                if (e.code === 'Digit1') {
                    switchWeapon('plasma');
                }
                
                if (e.code === 'Digit2') {
                    switchWeapon('railgun');
                }
            });
            
            document.addEventListener('keyup', (e) => {
                game.keys[e.code] = false;
            });
            
            // Mouse events
            document.addEventListener('mousedown', (e) => {
                game.mouse.buttons[e.button] = true;
                if (e.button === 0 && game.state === 'playing') { // Left click
                    shoot();
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                game.mouse.buttons[e.button] = false;
            });
            
            document.addEventListener('mousemove', (e) => {
                game.mouse.x = e.clientX;
                game.mouse.y = e.clientY;
                
                if (document.pointerLockElement === document.getElementById('gameContainer')) {
                    updatePlayerRotation(e.movementX, e.movementY);
                }
            });
            
            // Pointer lock
            document.getElementById('gameContainer').addEventListener('click', () => {
                if (game.state === 'playing') {
                    document.getElementById('gameContainer').requestPointerLock();
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                game.camera.aspect = window.innerWidth / window.innerHeight;
                game.camera.updateProjectionMatrix();
                game.renderer.setSize(window.innerWidth, window.innerHeight);
                game.composer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Pause menu buttons
            document.getElementById('resumeButton').addEventListener('click', () => {
                togglePause();
            });
            
            document.getElementById('restartButton').addEventListener('click', () => {
                location.reload();
            });
            
            document.getElementById('settingsButton').addEventListener('click', () => {
                showMessage('SETTINGS', 'Neural interface settings coming in next update');
            });
            
            document.getElementById('quitButton').addEventListener('click', () => {
                window.close();
            });
        }

        // ================================
        // GAME LOGIC
        // ================================
        function updatePlayerRotation(deltaX, deltaY) {
            const sensitivity = 0.002;
            
            // Update player rotation
            game.player.rotation.y -= deltaX * sensitivity;
            game.player.rotation.x -= deltaY * sensitivity;
            
            // Clamp vertical rotation
            game.player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, game.player.rotation.x));
            
            // Apply rotation to mesh
            game.player.mesh.rotation.y = game.player.rotation.y;
        }

        function updatePlayer(deltaTime) {
            // Calculate movement direction
            const moveDirection = new THREE.Vector3(0, 0, 0);
            
            if (game.keys['KeyW']) moveDirection.z -= 1;
            if (game.keys['KeyS']) moveDirection.z += 1;
            if (game.keys['KeyA']) moveDirection.x -= 1;
            if (game.keys['KeyD']) moveDirection.x += 1;
            
            // Normalize movement
            if (moveDirection.length() > 0) {
                moveDirection.normalize();
                
                // Apply rotation to movement direction
                const yaw = game.player.rotation.y;
                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                
                const rotatedX = moveDirection.x * cosYaw - moveDirection.z * sinYaw;
                const rotatedZ = moveDirection.x * sinYaw + moveDirection.z * cosYaw;
                
                moveDirection.x = rotatedX;
                moveDirection.z = rotatedZ;
                
                // Calculate speed
                let speed = CONFIG.PLAYER_SPEED;
                if (game.keys['ShiftLeft'] || game.keys['ShiftRight']) {
                    speed *= CONFIG.PLAYER_SPRINT_MULTIPLIER;
                }
                
                if (game.player.abilities.dash.active) {
                    speed *= CONFIG.ABILITIES.dash.speedMultiplier;
                }
                
                // Apply movement
                game.player.velocity.x = moveDirection.x * speed;
                game.player.velocity.z = moveDirection.z * speed;
            } else {
                // Slow down when not moving
                game.player.velocity.x *= 0.9;
                game.player.velocity.z *= 0.9;
            }
            
            // Jump
            if (game.keys['Space'] && game.player.velocity.y === 0) {
                game.player.velocity.y = CONFIG.PLAYER_JUMP_FORCE;
            }
            
            // Apply gravity
            game.player.velocity.y += CONFIG.GRAVITY * deltaTime;
            
            // Apply velocity
            game.player.position.x += game.player.velocity.x * deltaTime;
            game.player.position.y += game.player.velocity.y * deltaTime;
            game.player.position.z += game.player.velocity.z * deltaTime;
            
            // Ground collision
            if (game.player.position.y < 1) {
                game.player.position.y = 1;
                game.player.velocity.y = 0;
            }
            
            // Update player mesh position
            game.player.mesh.position.copy(game.player.position);
            
            // Update camera position (first-person)
            const cameraOffset = new THREE.Vector3(0, 1, 0);
            cameraOffset.applyEuler(game.player.rotation);
            game.camera.position.copy(game.player.position).add(cameraOffset);
            game.camera.rotation.copy(game.player.rotation);
            
            // Regenerate energy
            if (game.player.energy < CONFIG.PLAYER_ENERGY) {
                game.player.energy += CONFIG.PLAYER_ENERGY_REGEN * deltaTime;
                game.player.energy = Math.min(game.player.energy, CONFIG.PLAYER_ENERGY);
                updateEnergyBar();
            }
            
            // Update ability cooldowns
            updateAbilities(deltaTime);
        }

        function updateEnemies(deltaTime) {
            const now = Date.now();
            
            for (const enemy of game.world.enemies) {
                if (enemy.health <= 0) continue;
                
                // Calculate distance to player
                const distanceToPlayer = enemy.mesh.position.distanceTo(game.player.position);
                
                switch(enemy.state) {
                    case 'patrol':
                        // Random patrol movement
                        if (!enemy.target || Math.random() < 0.01) {
                            enemy.target = new THREE.Vector3(
                                enemy.mesh.position.x + (Math.random() - 0.5) * 20,
                                enemy.mesh.position.y,
                                enemy.mesh.position.z + (Math.random() - 0.5) * 20
                            );
                        }
                        
                        // Move toward target
                        const direction = enemy.target.clone().sub(enemy.mesh.position).normalize();
                        enemy.mesh.position.add(direction.multiplyScalar(2 * deltaTime));
                        
                        // Face movement direction
                        if (direction.length() > 0) {
                            enemy.mesh.lookAt(enemy.mesh.position.clone().add(direction));
                        }
                        
                        // Switch to attack if player is close
                        if (distanceToPlayer < 30) {
                            enemy.state = 'attack';
                        }
                        break;
                        
                    case 'attack':
                        // Face player
                        const lookAtPlayer = game.player.position.clone().sub(enemy.mesh.position).normalize();
                        enemy.mesh.lookAt(enemy.mesh.position.clone().add(lookAtPlayer));
                        
                        // Shoot at player
                        if (now - enemy.lastShot > 1000 && distanceToPlayer < 50) {
                            shootEnemy(enemy);
                            enemy.lastShot = now;
                        }
                        
                        // Retreat if too close
                        if (distanceToPlayer < 10) {
                            const retreatDirection = enemy.mesh.position.clone().sub(game.player.position).normalize();
                            enemy.mesh.position.add(retreatDirection.multiplyScalar(5 * deltaTime));
                        }
                        
                        // Return to patrol if player is far
                        if (distanceToPlayer > 40) {
                            enemy.state = 'patrol';
                        }
                        break;
                }
                
                // Enemy shooting logic
                if (now - enemy.lastShot > 2000 && Math.random() < 0.01) {
                    shootEnemy(enemy);
                    enemy.lastShot = now;
                }
            }
        }

        function shootEnemy(enemy) {
            // Create projectile
            const projectileGeometry = new THREE.SphereGeometry(0.3);
            const projectileMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                emissive: 0xff0000
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            
            // Position projectile at enemy
            projectile.position.copy(enemy.mesh.position);
            projectile.position.y += 1;
            
            // Calculate direction to player
            const direction = game.player.position.clone().sub(projectile.position).normalize();
            
            // Add velocity
            projectile.userData = {
                velocity: direction.multiplyScalar(50),
                damage: 10,
                lifetime: 3
            };
            
            game.scene.add(projectile);
            game.world.particles.push(projectile);
            
            // Muzzle flash
            createMuzzleFlash(enemy.mesh.position);
        }

        function createMuzzleFlash(position) {
            const flashGeometry = new THREE.SphereGeometry(0.5);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.copy(position);
            flash.position.y += 1;
            
            flash.userData = {
                lifetime: 0.1,
                maxLifetime: 0.1
            };
            
            game.scene.add(flash);
            game.world.particles.push(flash);
        }

        function updateParticles(deltaTime) {
            for (let i = game.world.particles.length - 1; i >= 0; i--) {
                const particle = game.world.particles[i];
                
                if (particle.userData.lifetime !== undefined) {
                    // Timed particle (muzzle flash, etc.)
                    particle.userData.lifetime -= deltaTime;
                    if (particle.userData.lifetime <= 0) {
                        game.scene.remove(particle);
                        game.world.particles.splice(i, 1);
                        continue;
                    }
                    
                    // Fade out
                    if (particle.material.opacity !== undefined) {
                        particle.material.opacity = particle.userData.lifetime / particle.userData.maxLifetime;
                    }
                }
                
                if (particle.userData.velocity) {
                    // Projectile movement
                    particle.position.add(particle.userData.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Check collision with player
                    if (particle.position.distanceTo(game.player.position) < 1) {
                        takeDamage(particle.userData.damage || 10);
                        game.scene.remove(particle);
                        game.world.particles.splice(i, 1);
                    }
                } else if (particle.userData.speed) {
                    // Floating particle animation
                    particle.position.y += Math.sin(Date.now() * 0.001 + particle.userData.offset) * 0.1;
                    particle.rotation.y += 0.01;
                }
            }
        }

        function updatePickups() {
            for (let i = game.world.pickups.length - 1; i >= 0; i--) {
                const pickup = game.world.pickups[i];
                
                if (pickup.collected) continue;
                
                // Rotate pickup
                pickup.mesh.rotation.y += 0.02;
                pickup.mesh.position.y += Math.sin(Date.now() * 0.002 + i) * 0.05;
                
                // Check collision with player
                if (pickup.mesh.position.distanceTo(game.player.position) < 2) {
                    collectPickup(pickup, i);
                }
            }
        }

        function collectPickup(pickup, index) {
            pickup.collected = true;
            
            switch(pickup.type) {
                case 'health':
                    game.player.health = Math.min(CONFIG.PLAYER_HEALTH, game.player.health + pickup.value);
                    updateHealthBar();
                    showMessage('NEURAL INTEGRITY RESTORED', '+25 integrity');
                    break;
                case 'energy':
                    game.player.energy = Math.min(CONFIG.PLAYER_ENERGY, game.player.energy + pickup.value);
                    updateEnergyBar();
                    showMessage('ENERGY RESTORED', '+25 cybernetic energy');
                    break;
                case 'ammo':
                    // Add ammo (infinite ammo in this version)
                    showMessage('AMMO CACHE FOUND', 'Weapons recharged');
                    break;
                case 'score':
                    game.player.score += pickup.value;
                    updateScore();
                    showMessage('CREDITS ACQUIRED', '+100 credits');
                    break;
            }
            
            // Visual effect
            createPickupEffect(pickup.mesh.position, pickup.type);
            
            // Remove pickup
            game.scene.remove(pickup.mesh);
            game.world.pickups.splice(index, 1);
        }

        function createPickupEffect(position, type) {
            // Create particle burst
            const particleCount = 20;
            const color = type === 'health' ? 0xff0000 :
                         type === 'energy' ? 0x00ffff :
                         type === 'ammo' ? 0xffff00 : 0x00ff00;
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.2);
                const material = new THREE.MeshBasicMaterial({ color: color });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                
                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 10
                );
                
                particle.userData = {
                    velocity: velocity,
                    lifetime: 1,
                    maxLifetime: 1
                };
                
                game.scene.add(particle);
                game.world.particles.push(particle);
            }
        }

        function updateAbilities(deltaTime) {
            const now = Date.now();
            
            for (const [name, ability] of Object.entries(game.player.abilities)) {
                if (ability.cooldown > 0) {
                    ability.cooldown -= deltaTime;
                    updateAbilityCooldown(name, ability.cooldown / CONFIG.ABILITIES[name].cooldown);
                }
                
                if (ability.active) {
                    ability.duration -= deltaTime;
                    if (ability.duration <= 0) {
                        deactivateAbility(name);
                    }
                }
            }
        }

        function activateAbility(name) {
            const ability = game.player.abilities[name];
            const config = CONFIG.ABILITIES[name];
            
            if (ability.cooldown > 0 || game.player.energy < config.energyCost) {
                return;
            }
            
            ability.active = true;
            ability.duration = config.duration;
            ability.cooldown = config.cooldown;
            game.player.energy -= config.energyCost;
            
            updateEnergyBar();
            updateAbilityCooldown(name, 1);
            
            // Ability effects
            switch(name) {
                case 'dash':
                    showMessage('CYBER DASH ACTIVATED', 'Movement speed increased');
                    break;
                case 'scan':
                    showMessage('NEURAL SCAN ACTIVE', 'Enemies highlighted');
                    break;
                case 'timeWarp':
                    showMessage('TIME DILATION', 'Enemy movement slowed');
                    break;
            }
        }

        function deactivateAbility(name) {
            const ability = game.player.abilities[name];
            ability.active = false;
            
            switch(name) {
                case 'dash':
                    showMessage('CYBER DASH DEPLETED', 'Systems recharging');
                    break;
                case 'scan':
                    showMessage('SCAN CONCLUDED', 'Enemy positions lost');
                    break;
                case 'timeWarp':
                    showMessage('TIME STREAM NORMALIZED', 'Reality stabilized');
                    break;
            }
        }

        function shoot() {
            const weapon = CONFIG.WEAPONS[game.player.weapon];
            
            if (game.player.energy < weapon.energyCost) {
                return;
            }
            
            game.player.energy -= weapon.energyCost;
            updateEnergyBar();
            
            // Create projectile
            const geometry = new THREE.SphereGeometry(0.2);
            const material = new THREE.MeshBasicMaterial({
                color: game.player.weapon === 'plasma' ? 0x00ffff : 0xff00ff,
                emissive: game.player.weapon === 'plasma' ? 0x00ffff : 0xff00ff
            });
            const projectile = new THREE.Mesh(geometry, material);
            
            // Position at camera
            projectile.position.copy(game.camera.position);
            
            // Calculate direction
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyEuler(game.camera.rotation);
            
            // Add some spread based on accuracy
            const spread = (1 - weapon.accuracy) * 0.1;
            direction.x += (Math.random() - 0.5) * spread;
            direction.y += (Math.random() - 0.5) * spread;
            direction.z += (Math.random() - 0.5) * spread;
            direction.normalize();
            
            projectile.userData = {
                velocity: direction.multiplyScalar(100),
                damage: weapon.damage,
                lifetime: 2
            };
            
            game.scene.add(projectile);
            game.world.particles.push(projectile);
            
            // Muzzle flash
            createMuzzleFlash(game.camera.position);
            
            // Recoil
            game.camera.rotation.x += (Math.random() - 0.5) * 0.01;
            game.camera.rotation.y += (Math.random() - 0.5) * 0.01;
            
            // Check hits
            checkHit(projectile);
        }

        function checkHit(projectile) {
            for (let i = game.world.enemies.length - 1; i >= 0; i--) {
                const enemy = game.world.enemies[i];
                
                if (enemy.health <= 0) continue;
                
                // Simple sphere collision
                const distance = projectile.position.distanceTo(enemy.mesh.position);
                const hitRadius = 3; // Approximate enemy size
                
                if (distance < hitRadius) {
                    // Hit enemy
                    enemy.health -= projectile.userData.damage;
                    
                    // Create hit effect
                    createHitEffect(enemy.mesh.position);
                    
                    // Remove projectile
                    game.scene.remove(projectile);
                    const particleIndex = game.world.particles.indexOf(projectile);
                    if (particleIndex > -1) {
                        game.world.particles.splice(particleIndex, 1);
                    }
                    
                    // Check if enemy died
                    if (enemy.health <= 0) {
                        enemyKilled(enemy, i);
                    }
                    
                    break;
                }
            }
        }

        function createHitEffect(position) {
            // Blood/energy splatter
            const particleCount = 10;
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.3);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff3300
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position);
                
                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 5,
                    (Math.random() - 0.5) * 5
                );
                
                particle.userData = {
                    velocity: velocity,
                    lifetime: 0.5,
                    maxLifetime: 0.5
                };
                
                game.scene.add(particle);
                game.world.particles.push(particle);
            }
        }

        function enemyKilled(enemy, index) {
            // Add score
            game.player.score += 100;
            game.player.kills++;
            
            updateScore();
            updateKillCount();
            
            // Show message
            showMessage('TARGET ELIMINATED', '+100 credits');
            
            // Death effect
            createDeathEffect(enemy.mesh.position);
            
            // Remove enemy
            game.scene.remove(enemy.mesh);
            game.world.enemies.splice(index, 1);
            
            // Check objective
            checkObjective();
        }

        function createDeathEffect(position) {
            // Explosion effect
            const geometry = new THREE.SphereGeometry(3);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff3300,
                transparent: true,
                opacity: 0.5
            });
            const explosion = new THREE.Mesh(geometry, material);
            explosion.position.copy(position);
            
            explosion.userData = {
                lifetime: 0.3,
                maxLifetime: 0.3,
                scale: 1
            };
            
            game.scene.add(explosion);
            game.world.particles.push(explosion);
        }

        function takeDamage(amount) {
            game.player.health -= amount;
            updateHealthBar();
            
            // Damage indicator
            game.ui.damageFlash = 1;
            
            // Check death
            if (game.player.health <= 0) {
                gameOver();
            }
        }

        function checkObjective() {
            // Check if all enemies are dead
            if (game.world.enemies.length === 0 && !game.objectiveComplete) {
                game.objectiveComplete = true;
                showMessage('OBJECTIVE COMPLETE', 'All hostiles eliminated. Proceed to extraction.');
            }
            
            // Check if player reached the tower
            const distanceToTower = game.player.position.distanceTo(new THREE.Vector3(0, 150, -CONFIG.OBJECTIVE_DISTANCE));
            if (distanceToTower < 50 && !game.objectiveComplete) {
                game.objectiveComplete = true;
                showMessage('SERVER REACHED', 'Uploading virus... Complete. Mission successful!');
                
                // Add bonus score
                game.player.score += 1000;
                updateScore();
            }
        }

        function switchWeapon(weaponType) {
            if (game.player.weapon !== weaponType) {
                game.player.weapon = weaponType;
                updateWeaponHUD();
                showMessage('WEAPON SWITCHED', CONFIG.WEAPONS[weaponType].name + ' equipped');
            }
        }

        function reloadWeapon() {
            // In this game, weapons use energy instead of ammo
            if (game.player.energy < CONFIG.PLAYER_ENERGY) {
                showMessage('ENERGY TRANSFER', 'Cybernetic systems recharged');
                game.player.energy = CONFIG.PLAYER_ENERGY;
                updateEnergyBar();
            }
        }

        // ================================
        // UI FUNCTIONS
        // ================================
        function updateHealthBar() {
            const percent = (game.player.health / CONFIG.PLAYER_HEALTH) * 100;
            document.getElementById('healthBar').style.width = percent + '%';
            document.getElementById('healthValue').textContent = Math.round(percent) + '%';
        }

        function updateEnergyBar() {
            const percent = (game.player.energy / CONFIG.PLAYER_ENERGY) * 100;
            document.getElementById('energyBar').style.width = percent + '%';
            document.getElementById('energyValue').textContent = Math.round(percent) + '%';
        }

        function updateScore() {
            document.getElementById('scoreValue').textContent = game.player.score;
        }

        function updateKillCount() {
            document.getElementById('killCount').textContent = game.player.kills;
        }

        function updateTime() {
            game.timeElapsed += 1;
            const minutes = Math.floor(game.timeElapsed / 60);
            const seconds = game.timeElapsed % 60;
            document.getElementById('timeValue').textContent = 
                minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
        }

        function updateWeaponHUD() {
            const weapon = CONFIG.WEAPONS[game.player.weapon];
            document.getElementById('weaponName').textContent = weapon.name;
            document.getElementById('ammoType').textContent = weapon.ammoType;
            
            // Infinite ammo in this version
            document.getElementById('ammoCount').textContent = '‚àû/‚àû';
        }

        function updateAbilityCooldown(abilityName, cooldownPercent) {
            const element = document.getElementById(abilityName + 'Cooldown');
            if (element) {
                element.style.height = (cooldownPercent * 100) + '%';
            }
        }

        function showMessage(title, text) {
            const messageContainer = document.getElementById('messageContainer');
            const message = document.createElement('div');
            message.className = 'message show';
            message.innerHTML = `
                <div style="color:#ff00ff; margin-bottom:5px;">${title}</div>
                <div style="color:#00ffff; font-size:0.9rem;">${text}</div>
            `;
            
            messageContainer.appendChild(message);
            
            // Remove after delay
            setTimeout(() => {
                message.classList.remove('show');
                setTimeout(() => {
                    if (message.parentNode) {
                        message.parentNode.removeChild(message);
                    }
                }, 300);
            }, 3000);
        }

        function showTutorialHint() {
            if (!game.ui.tutorialShown) {
                const hint = document.getElementById('tutorialHint');
                hint.classList.add('show');
                
                setTimeout(() => {
                    hint.classList.remove('show');
                    game.ui.tutorialShown = true;
                }, 5000);
            }
        }

        function togglePause() {
            if (game.state === 'playing') {
                game.state = 'paused';
                document.getElementById('pauseMenu').style.display = 'flex';
                document.exitPointerLock();
            } else if (game.state === 'paused') {
                game.state = 'playing';
                document.getElementById('pauseMenu').style.display = 'none';
            }
        }

        function gameOver() {
            game.state = 'gameOver';
            showMessage('NEURAL INTEGRITY CRITICAL', 'Mission failed. Disconnecting...');
            
            setTimeout(() => {
                location.reload();
            }, 3000);
        }

        // ================================
        // GAME LOOP
        // ================================
        function animate() {
            requestAnimationFrame(animate);
            
            if (game.state === 'loading') return;
            
            const deltaTime = game.clock.getDelta();
            
            if (game.state === 'playing') {
                // Update game logic
                updatePlayer(deltaTime);
                updateEnemies(deltaTime);
                updateParticles(deltaTime);
                updatePickups();
                
                // Update time every second
                if (Date.now() - game.ui.lastMessageTime > 1000) {
                    updateTime();
                    game.ui.lastMessageTime = Date.now();
                }
                
                // Update damage indicator
                if (game.ui.damageFlash > 0) {
                    document.getElementById('damageIndicator').style.opacity = game.ui.damageFlash;
                    document.getElementById('damageIndicator').style.background = 
                        `radial-gradient(circle, rgba(255,0,0,${game.ui.damageFlash}) 0%, transparent 70%)`;
                    game.ui.damageFlash -= deltaTime * 2;
                }
                
                // Update objective marker
                const distanceToTower = game.player.position.distanceTo(new THREE.Vector3(0, 150, -CONFIG.OBJECTIVE_DISTANCE));
                document.getElementById('objectiveMarker').style.display = distanceToTower > 100 ? 'block' : 'none';
                document.getElementById('objectiveMarker').querySelector('.objective-distance').textContent = 
                    Math.round(distanceToTower) + 'm';
            }
            
            // Render
            if (game.composer) {
                game.composer.render();
            } else {
                game.renderer.render(game.scene, game.camera);
            }
        }

        // ================================
        // LOADING PROGRESS
        // ================================
        function updateLoadingProgress(progress, text) {
            document.getElementById('loadingBar').style.width = progress + '%';
            document.getElementById('loadingText').textContent = text;
        }

        // Simulate loading
        const loadingSteps = [
            { progress: 10, text: 'INITIALIZING NEURAL LINK...' },
            { progress: 25, text: 'LOADING CYBERNETIC ENHANCEMENTS...' },
            { progress: 40, text: 'CALIBRATING OPTICS...' },
            { progress: 60, text: 'SYNCHRONIZING WEAPONS SYSTEMS...' },
            { progress: 80, text: 'GENERATING ENVIRONMENT...' },
            { progress: 95, text: 'FINALIZING INFILTRATION PROTOCOL...' },
            { progress: 100, text: 'READY FOR DEPLOYMENT' }
        ];

        let currentStep = 0;
        const loadingInterval = setInterval(() => {
            if (currentStep < loadingSteps.length) {
                updateLoadingProgress(
                    loadingSteps[currentStep].progress,
                    loadingSteps[currentStep].text
                );
                currentStep++;
            } else {
                clearInterval(loadingInterval);
                init();
            }
        }, 500);

        // Start the game when page loads
        window.addEventListener('load', () => {
            // Already started by loading simulation
        });
    </script>
</body>
</html>
