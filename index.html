<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cell Block Zero - Cooperative Prison Escape</title>
    
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Load Howler.js for Audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', 'Courier New', monospace;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
            font-family: 'Orbitron', sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap');

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        /* Cyberpunk Glow Effects */
        .cyber-glow {
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
        }

        .cyber-border {
            position: relative;
            border: 2px solid transparent;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e) padding-box,
                        linear-gradient(45deg, #00ff00, #00ccff, #ff00ff) border-box;
            border-radius: 10px;
        }

        /* UI Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, rgba(10, 10, 26, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        #lobbyScreen {
            display: flex;
        }

        #gameScreen {
            display: none;
        }

        #solitaryScreen {
            display: none;
            background: radial-gradient(circle at center, #000000 0%, #1a001a 100%);
        }

        #loadingScreen {
            display: none;
            background: linear-gradient(135deg, #000000 0%, #001020 100%);
        }

        /* UI Elements */
        .ui-box {
            background: rgba(0, 20, 10, 0.85);
            border: 3px solid #00ff00;
            border-radius: 15px;
            padding: 30px;
            max-width: 800px;
            width: 95%;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.4),
                        inset 0 0 20px rgba(0, 255, 0, 0.1);
            backdrop-filter: blur(10px);
            animation: pulse-glow 3s infinite alternate;
        }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 40px rgba(0, 255, 0, 0.4); }
            100% { box-shadow: 0 0 60px rgba(0, 255, 0, 0.6); }
        }

        h1 {
            color: #ff0066;
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0066,
                         0 0 40px #ff0066,
                         0 0 60px #ff0066;
            letter-spacing: 4px;
            font-weight: 900;
            background: linear-gradient(45deg, #ff0066, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            color: #00ccff;
            margin: 25px 0;
            font-size: 2.2em;
            text-shadow: 0 0 10px #00ccff;
        }

        h3 {
            color: #ffcc00;
            margin: 20px 0;
            font-size: 1.5em;
        }

        p {
            margin: 15px 0;
            line-height: 1.6;
            font-size: 1.1em;
            color: #aaffaa;
        }

        button {
            background: linear-gradient(135deg, #003322 0%, #001111 100%);
            color: #00ff88;
            border: 2px solid #00ff88;
            padding: 18px 35px;
            margin: 15px;
            font-size: 1.3em;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            min-width: 200px;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.2), transparent);
            transition: 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            background: linear-gradient(135deg, #006633 0%, #003322 100%);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.6);
            color: #ffffff;
        }

        button:active {
            transform: translateY(0) scale(1);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(50%);
        }

        input {
            background: rgba(0, 0, 0, 0.7);
            color: #00ff88;
            border: 2px solid #00ccff;
            padding: 15px;
            margin: 15px;
            border-radius: 8px;
            font-size: 1.2em;
            width: 300px;
            text-align: center;
            letter-spacing: 3px;
            font-weight: bold;
            transition: all 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
            transform: scale(1.05);
        }

        /* Room Code Display */
        .room-code-display {
            font-size: 3em;
            font-weight: 900;
            color: #ff0066;
            letter-spacing: 10px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            border: 3px solid #ff0066;
            text-shadow: 0 0 20px #ff0066;
            display: inline-block;
            min-width: 300px;
        }

        /* Copy Button */
        .copy-btn {
            background: linear-gradient(135deg, #0066cc 0%, #003366 100%);
            border-color: #00ccff;
            padding: 12px 25px;
            font-size: 1em;
            min-width: auto;
        }

        /* Game UI */
        #connectionStatus {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px 25px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ff00;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1.1em;
            z-index: 100;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-connected .status-indicator {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .status-connecting .status-indicator {
            background: #ffcc00;
            box-shadow: 0 0 10px #ffcc00;
            animation: pulse 1s infinite;
        }

        .status-disconnected .status-indicator {
            background: #ff3300;
            box-shadow: 0 0 10px #ff3300;
        }

        #gameUI {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            gap: 20px;
        }

        .player-info {
            background: rgba(0, 30, 15, 0.9);
            border: 2px solid;
            padding: 20px;
            min-width: 280px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            transition: transform 0.3s;
        }

        .player-info:hover {
            transform: translateY(-5px);
        }

        .player1 {
            border-color: #ff0066;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.3);
        }

        .player2 {
            border-color: #00ccff;
            box-shadow: 0 0 20px rgba(0, 204, 255, 0.3);
        }

        .health-bar {
            height: 20px;
            background: #330000;
            border: 1px solid #666;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff9900, #00ff00);
            transition: width 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            border-radius: 10px;
        }

        .health-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 50%, rgba(255, 255, 255, 0.1) 50%);
            background-size: 10px 100%;
            pointer-events: none;
        }

        /* Inventory */
        #inventory {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ffcc00;
            padding: 25px;
            border-radius: 15px;
            display: none;
            min-width: 250px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.4);
        }

        .inventory-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
            padding: 10px;
            background: rgba(255, 204, 0, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: transform 0.2s;
        }

        .inventory-item:hover {
            transform: translateX(5px);
            background: rgba(255, 204, 0, 0.2);
        }

        .inventory-icon {
            width: 40px;
            height: 40px;
            margin-right: 20px;
            border: 2px solid #ffcc00;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
        }

        /* Objective */
        #objective {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 10, 20, 0.95);
            border: 4px solid #ff0066;
            padding: 50px;
            text-align: center;
            display: none;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(255, 0, 102, 0.6);
            max-width: 700px;
            width: 90%;
            z-index: 1001;
            backdrop-filter: blur(10px);
        }

        /* Chat */
        #chat {
            position: absolute;
            bottom: 150px;
            left: 30px;
            width: 350px;
            max-height: 300px;
            background: rgba(0, 20, 40, 0.95);
            border: 2px solid #00ccff;
            padding: 20px;
            border-radius: 15px;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(5px);
        }

        #chatMessages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 30, 60, 0.5);
            border-radius: 8px;
            max-height: 200px;
            border: 1px solid rgba(0, 204, 255, 0.3);
        }

        .chat-message {
            margin: 8px 0;
            padding: 10px;
            border-radius: 8px;
            word-break: break-word;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chat-message.you {
            background: linear-gradient(135deg, rgba(0, 100, 0, 0.4) 0%, rgba(0, 50, 0, 0.4) 100%);
            border-left: 3px solid #00ff00;
        }

        .chat-message.partner {
            background: linear-gradient(135deg, rgba(0, 50, 100, 0.4) 0%, rgba(0, 25, 50, 0.4) 100%);
            border-left: 3px solid #00ccff;
        }

        /* Escape Menu */
        #escapeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 30, 15, 0.97);
            border: 4px solid #ff0066;
            padding: 40px;
            display: none;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            border-radius: 20px;
            box-shadow: 0 0 60px rgba(255, 0, 102, 0.7);
            min-width: 750px;
            backdrop-filter: blur(10px);
        }

        .escape-option {
            padding: 25px;
            border: 3px solid #00ccff;
            cursor: pointer;
            text-align: center;
            background: rgba(0, 50, 100, 0.3);
            border-radius: 15px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .escape-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        .escape-option:hover::before {
            transform: translateX(100%);
        }

        .escape-option:hover {
            background: rgba(0, 100, 100, 0.6);
            transform: scale(1.08);
            border-color: #00ff00;
            box-shadow: 0 10px 30px rgba(0, 255, 0, 0.4);
        }

        .escape-option.ready {
            border-color: #00ff00;
            background: linear-gradient(135deg, rgba(0, 100, 0, 0.4) 0%, rgba(0, 50, 0, 0.4) 100%);
            animation: ready-pulse 2s infinite;
        }

        @keyframes ready-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.4); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 0, 0.8); }
        }

        .escape-option.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
            filter: grayscale(70%);
        }

        /* Solitary Screen */
        #solitaryAnimation {
            width: 100%;
            height: 300px;
            background: #000;
            border: 5px solid #333;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
            border-radius: 15px;
            background: linear-gradient(135deg, #111 0%, #222 100%);
        }

        /* Loading Screen */
        .spinner {
            width: 80px;
            height: 80px;
            border: 6px solid rgba(0, 255, 0, 0.3);
            border-radius: 50%;
            border-top-color: #00ff00;
            border-right-color: #00ccff;
            border-bottom-color: #ff0066;
            animation: spin 1.5s linear infinite;
            margin: 40px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: none;
            gap: 15px;
            pointer-events: none;
            flex-direction: column;
            align-items: center;
        }

        .mobile-control-group {
            display: flex;
            gap: 15px;
        }

        .mobile-btn {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, rgba(0, 100, 0, 0.8) 0%, rgba(0, 50, 0, 0.8) 100%);
            border: 3px solid #00ff00;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 28px;
            font-weight: bold;
            pointer-events: auto;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.1s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .mobile-btn:active {
            background: radial-gradient(circle, rgba(0, 200, 0, 0.8) 0%, rgba(0, 100, 0, 0.8) 100%);
            transform: scale(0.95);
        }

        .mobile-btn.special {
            background: radial-gradient(circle, rgba(100, 0, 100, 0.8) 0%, rgba(50, 0, 50, 0.8) 100%);
            border-color: #ff00ff;
        }

        /* Message Display */
        #messageDisplay {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 20, 0, 0.9) 0%, rgba(0, 10, 20, 0.9) 100%);
            border: 2px solid #00ff00;
            padding: 20px 40px;
            border-radius: 15px;
            display: none;
            z-index: 1002;
            text-align: center;
            max-width: 80%;
            word-break: break-word;
            backdrop-filter: blur(10px);
            animation: slideDown 0.5s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translate(-50%, -30px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        /* Progress Bar */
        .progress-bar {
            height: 15px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
            margin: 15px 0;
            border: 1px solid #666;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ccff, #ff00ff);
            transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 30%, rgba(255, 255, 255, 0.2) 50%, transparent 70%);
            background-size: 200% 100%;
            animation: shine 2s infinite;
        }

        @keyframes shine {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        /* Waiting Overlay */
        #waitingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.95) 0%, rgba(10, 0, 20, 0.98) 100%);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .waiting-box {
            background: linear-gradient(135deg, rgba(0, 20, 0, 0.95) 0%, rgba(0, 10, 20, 0.95) 100%);
            border: 3px solid #00ccff;
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            max-width: 600px;
            animation: pulse 2s infinite;
            backdrop-filter: blur(5px);
        }

        /* Particle Background */
        .particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        /* Timer Display */
        #timerDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ccff;
            border-radius: 10px;
            font-size: 1.5em;
            font-weight: bold;
            color: #00ccff;
            display: none;
            backdrop-filter: blur(5px);
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            h1 { font-size: 3em; }
            h2 { font-size: 1.8em; }
            button { padding: 15px 25px; font-size: 1.1em; min-width: 180px; }
            .ui-box { padding: 20px; }
            #gameUI { flex-direction: column; gap: 15px; }
            .player-info { min-width: auto; width: 100%; }
            #escapeMenu { 
                grid-template-columns: 1fr; 
                min-width: 90%;
                padding: 30px;
            }
            #mobileControls { display: flex; }
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.5em; }
            .room-code-display { font-size: 2em; letter-spacing: 5px; min-width: 250px; }
            input { width: 250px; }
            #chat { width: 300px; left: 15px; bottom: 180px; }
            .mobile-btn { width: 70px; height: 70px; font-size: 24px; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 2em; }
            .room-code-display { font-size: 1.8em; padding: 15px; min-width: 200px; }
            button { padding: 12px 20px; font-size: 1em; min-width: 160px; margin: 10px; }
            .player-info { padding: 15px; }
            #chat { width: 90%; left: 5%; }
            .mobile-btn { width: 60px; height: 60px; font-size: 20px; }
        }

        /* Animation Classes */
        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .glitch {
            animation: glitch 0.5s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        /* Audio Controls */
        #audioControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }

        .audio-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ccff;
            color: #00ccff;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .audio-btn:hover {
            background: rgba(0, 100, 100, 0.7);
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <!-- Particle Background -->
    <canvas id="particles" class="particles"></canvas>
    
    <div id="gameContainer">
        <!-- Loading Screen -->
        <div id="loadingScreen" class="screen">
            <div class="ui-box">
                <h1>CELL BLOCK ZERO</h1>
                <div class="spinner"></div>
                <h2 id="loadingText">INITIALIZING PRISON SYSTEM...</h2>
                <p class="pulse">Establishing secure connection...</p>
                <div class="progress-bar">
                    <div id="loadingProgress" class="progress-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Waiting Overlay -->
        <div id="waitingOverlay">
            <div class="waiting-box">
                <h2>üîó CONNECTING TO HOST...</h2>
                <div class="spinner"></div>
                <p id="waitingMessage">Establishing secure peer-to-peer connection...</p>
                <div class="progress-bar">
                    <div id="connectionProgress" class="progress-fill" style="width: 50%"></div>
                </div>
                <p class="pulse" style="margin-top: 20px;">This may take a few seconds...</p>
                <button onclick="cancelWaiting()" style="margin-top: 30px;">CANCEL CONNECTION</button>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobbyScreen" class="screen">
            <div class="ui-box">
                <h1 class="glitch">CELL BLOCK ZERO</h1>
                <h2>MAXIMUM SECURITY ESCAPE</h2>
                <p>Two inmates. One prison. Countless guard bots. Work together or rot forever.</p>
                
                <div id="connectionStatus" class="status-disconnected">
                    <span class="status-indicator"></span>
                    <span id="statusText">SYSTEM OFFLINE</span>
                </div>
                
                <div style="margin: 40px 0;">
                    <button onclick="hostGame()" id="hostBtn">üöÄ HOST NEW GAME</button>
                    <button onclick="joinGame()" id="joinBtn">üîó JOIN GAME</button>
                    <button onclick="showTutorial()" id="tutorialBtn">üìñ TUTORIAL</button>
                    <button onclick="toggleAudio()" id="audioToggleBtn">üîä SOUND ON</button>
                </div>
                
                <div id="joinSection" style="display: none; margin: 30px 0;">
                    <h3>ENTER ROOM CODE</h3>
                    <input type="text" id="roomCode" placeholder="XXXX" maxlength="4" pattern="[A-Z0-9]{4}" 
                           oninput="this.value = this.value.toUpperCase()" autocomplete="off">
                    <div style="margin: 20px;">
                        <button onclick="connectToHost()" id="connectBtn">üîì CONNECT</button>
                        <button onclick="cancelJoin()">‚úñ CANCEL</button>
                    </div>
                    <p id="connectStatus" style="color: #ffcc00; min-height: 24px;"></p>
                </div>
                
                <div id="roomInfo" style="display: none; margin: 30px 0;">
                    <h3>SHARE THIS CODE WITH YOUR PARTNER</h3>
                    <div class="room-code-display" id="displayCode">XXXX</div>
                    <button onclick="copyRoomCode()" class="copy-btn">üìã COPY CODE</button>
                    <p id="connectionCount" style="margin: 20px 0;">‚è≥ Waiting for partner to connect...</p>
                    <div style="margin: 30px 0;">
                        <button onclick="startGame()" id="startBtn" disabled>‚ö° START ESCAPE</button>
                        <button onclick="cancelHost()">‚úñ CANCEL</button>
                    </div>
                    <p style="color: #00ccff;">‚ö†Ô∏è Room will expire in <span id="roomTimer">2:00</span></p>
                </div>
                
                <div id="tutorialSection" style="display: none; margin: 30px 0; text-align: left;">
                    <h3>üìñ HOW TO ESCAPE:</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div class="cyber-border" style="padding: 15px;">
                            <h4>üéÆ CONTROLS</h4>
                            <p><strong>WASD:</strong> Move</p>
                            <p><strong>E:</strong> Interact/Use</p>
                            <p><strong>F:</strong> Fight/Attack</p>
                            <p><strong>SPACE:</strong> Jump</p>
                            <p><strong>SHIFT:</strong> Run/Sprint</p>
                        </div>
                        <div class="cyber-border" style="padding: 15px;">
                            <h4>üéØ OBJECTIVES</h4>
                            <p>1. Collect escape items</p>
                            <p>2. Avoid guard detection</p>
                            <p>3. Coordinate with partner</p>
                            <p>4. Choose escape method</p>
                            <p>5. Execute escape plan</p>
                        </div>
                    </div>
                    <button onclick="hideTutorial()" style="margin-top: 20px;">BACK TO LOBBY</button>
                </div>
                
                <div style="margin-top: 40px; border-top: 2px solid #00ff00; padding-top: 20px;">
                    <h3>üéÆ CONTROLS</h3>
                    <p><strong>WASD/Arrows:</strong> Move | <strong>E:</strong> Interact | <strong>F:</strong> Fight</p>
                    <p><strong>TAB:</strong> Inventory | <strong>C:</strong> Chat | <strong>M:</strong> Escape Menu</p>
                    <p><strong>ESC:</strong> Pause Menu | <strong>ENTER:</strong> Send Chat</p>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="screen">
            <canvas id="gameCanvas"></canvas>
            
            <div id="connectionStatus" class="status-connected">
                <span class="status-indicator"></span>
                <span>CONNECTED ‚Ä¢ READY FOR ESCAPE</span>
            </div>
            
            <div id="timerDisplay">TIME: <span id="gameTimer">00:00</span></div>
            
            <div id="gameUI">
                <div class="player-info player1">
                    <h3>üë§ PLAYER 1 <span id="playerName1">(YOU)</span></h3>
                    <p>‚ù§Ô∏è HEALTH: <span id="health1">100</span>%</p>
                    <div class="health-bar">
                        <div id="healthBar1" class="health-fill" style="width: 100%"></div>
                    </div>
                    <p>üì¶ CONTRABAND: <span id="contraband1">0</span></p>
                    <p>‚≠ê REPUTATION: <span id="rep1">0</span></p>
                    <p>üìç POSITION: <span id="pos1">Cell Block A</span></p>
                    <p>üéØ STATUS: <span id="status1">Idle</span></p>
                </div>
                
                <div class="player-info player2">
                    <h3>üë• PLAYER 2 <span id="playerName2">(PARTNER)</span></h3>
                    <p>‚ù§Ô∏è HEALTH: <span id="health2">100</span>%</p>
                    <div class="health-bar">
                        <div id="healthBar2" class="health-fill" style="width: 100%"></div>
                    </div>
                    <p>üì¶ CONTRABAND: <span id="contraband2">0</span></p>
                    <p>‚≠ê REPUTATION: <span id="rep2">0</span></p>
                    <p>üìç POSITION: <span id="pos2">Cell Block B</span></p>
                    <p>üéØ STATUS: <span id="status2">Connecting...</span></p>
                </div>
            </div>
            
            <div id="inventory">
                <h3>üéí INVENTORY <span id="inventoryCount">(0/8)</span></h3>
                <div id="inventoryItems"></div>
                <div class="progress-bar">
                    <div id="escapeProgress" class="progress-fill" style="width: 0%"></div>
                </div>
                <p>ESCAPE PREPARATION</p>
            </div>
            
            <div id="objective">
                <h2>‚ö†Ô∏è PRIMARY OBJECTIVE</h2>
                <p id="objectiveText">ESCAPE THE MAXIMUM SECURITY PRISON WITH YOUR PARTNER!</p>
                <p id="objectiveSubtext">Collect items, avoid guard detection, and coordinate your escape plan.</p>
                <p style="color: #ffcc00; margin: 20px 0;">üéØ Current Goal: Find the prison layout map</p>
                <button onclick="hideObjective()">BEGIN ESCAPE</button>
            </div>
            
            <div id="chat">
                <div id="chatMessages"></div>
                <input type="text" id="chatInput" placeholder="Type message... (Enter to send, ESC to close)" 
                       onkeypress="if(event.key === 'Enter') sendChatMessage()">
            </div>
            
            <div id="escapeMenu">
                <h2 style="grid-column: span 2;">üöÄ ESCAPE METHODS</h2>
                <div class="escape-option" onclick="startEscape('tunnel')" id="escapeTunnel">
                    <h3>üï≥Ô∏è TUNNEL DIGGING</h3>
                    <p>Dig a tunnel under the prison walls</p>
                    <p><strong>Requires:</strong> Shovel + Crowbar</p>
                    <p class="pulse">Success Chance: 65%</p>
                </div>
                <div class="escape-option" onclick="startEscape('disguise')" id="escapeDisguise">
                    <h3>üëÆ GUARD DISGUISE</h3>
                    <p>Disguise as a guard and walk out</p>
                    <p><strong>Requires:</strong> Uniform + ID Card</p>
                    <p class="pulse">Success Chance: 75%</p>
                </div>
                <div class="escape-option" onclick="startEscape('riot')" id="escapeRiot">
                    <h3>üî• RIOT CHAOS</h3>
                    <p>Start a riot and escape in chaos</p>
                    <p><strong>Requires:</strong> Reputation 50+</p>
                    <p class="pulse">Success Chance: 55%</p>
                </div>
                <div class="escape-option" onclick="startEscape('parole')" id="escapeParole">
                    <h3>üìù LEGAL PAROLE</h3>
                    <p>Get released "legally"</p>
                    <p><strong>Requires:</strong> Clean Record + Documents</p>
                    <p class="pulse">Success Chance: 80%</p>
                </div>
                <button onclick="toggleEscapeMenu()" style="grid-column: span 2; margin-top: 30px;">RETURN TO GAME</button>
            </div>
            
            <!-- Mobile Controls -->
            <div id="mobileControls">
                <div class="mobile-control-group">
                    <div class="mobile-btn" ontouchstart="mobileKeyDown('w')" ontouchend="mobileKeyUp('w')">‚Üë</div>
                </div>
                <div class="mobile-control-group">
                    <div class="mobile-btn" ontouchstart="mobileKeyDown('a')" ontouchend="mobileKeyUp('a')">‚Üê</div>
                    <div class="mobile-btn" ontouchstart="mobileKeyDown('s')" ontouchend="mobileKeyUp('s')">‚Üì</div>
                    <div class="mobile-btn" ontouchstart="mobileKeyDown('d')" ontouchend="mobileKeyUp('d')">‚Üí</div>
                </div>
                <div class="mobile-control-group">
                    <div class="mobile-btn" ontouchstart="mobileKeyDown('e')" ontouchend="mobileKeyUp('e')">E</div>
                    <div class="mobile-btn special" ontouchstart="mobileKeyDown('f')" ontouchend="mobileKeyUp('f')">F</div>
                    <div class="mobile-btn" ontouchstart="mobileKeyDown(' ')" ontouchend="mobileKeyUp(' ')">‚§¥Ô∏è</div>
                </div>
            </div>
            
            <div id="messageDisplay"></div>
            
            <!-- Pause Menu -->
            <div id="pauseMenu" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                  background: rgba(0, 20, 0, 0.95); padding: 40px; border-radius: 20px; border: 3px solid #ff0066; text-align: center;">
                <h2>‚è∏Ô∏è GAME PAUSED</h2>
                <div style="margin: 30px;">
                    <button onclick="togglePause()">‚ñ∂Ô∏è RESUME</button>
                    <button onclick="returnToLobby()">üè† MAIN MENU</button>
                </div>
            </div>
        </div>

        <!-- Solitary Screen -->
        <div id="solitaryScreen" class="screen">
            <div class="ui-box">
                <h1>üîí SOLITARY CONFINEMENT</h1>
                <div id="solitaryAnimation"></div>
                <h2 id="failReason">ESCAPE ATTEMPT FAILED!</h2>
                <p id="funnyMessage" style="font-size: 1.3em; color: #ff9900;"></p>
                <div style="margin: 40px 0;">
                    <button onclick="retryGame()">üîÑ RETRY ESCAPE</button>
                    <button onclick="returnToLobby()">üè† MAIN MENU</button>
                </div>
                <div style="border-top: 2px solid #ff0066; padding-top: 20px;">
                    <h3>üí° ESCAPE HINT</h3>
                    <p id="escapeHint" style="color: #00ccff; font-size: 1.2em;"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Audio Controls -->
    <div id="audioControls" style="display: none;">
        <button class="audio-btn" onclick="toggleAudio()">üîä</button>
    </div>

    <script>
        // ============================================================================
        // ENHANCED RNG SYSTEM
        // ============================================================================
        class EnhancedRandom {
            constructor(seed = Date.now()) {
                this.seed = seed;
                this.current = seed;
                this.mod = 233280;
                this.mult = 9301;
                this.inc = 49297;
            }
            
            next() {
                this.current = (this.current * this.mult + this.inc) % this.mod;
                return this.current / this.mod;
            }
            
            random() {
                return this.next();
            }
            
            range(min, max) {
                return min + this.next() * (max - min);
            }
            
            int(min, max) {
                return Math.floor(this.range(min, max));
            }
            
            choice(array) {
                return array[this.int(0, array.length)];
            }
            
            weightedChoice(items) {
                const total = items.reduce((sum, item) => sum + item.weight, 0);
                let random = this.next() * total;
                for (const item of items) {
                    random -= item.weight;
                    if (random <= 0) return item.value;
                }
                return items[items.length - 1].value;
            }
        }

        // ============================================================================
        // ENHANCED GAME CONFIGURATION
        // ============================================================================
        const CONFIG = {
            PRISON_SIZE: 150,
            CELL_COUNT: 25,
            GUARD_COUNT: 8,
            INMATE_BOT_COUNT: 15,
            DAY_CYCLE: 240,
            MAX_PLAYERS: 2,
            ROOM_EXPIRE_TIME: 120000,
            
            ITEM_TYPES: [
                { id: 'shovel', name: 'Heavy Shovel', color: '#8B4513', icon: 'ü™ö', weight: 0.8, rarity: 'common' },
                { id: 'uniform', name: 'Guard Uniform', color: '#0000ff', icon: 'üëï', weight: 0.5, rarity: 'rare' },
                { id: 'idcard', name: 'Security ID', color: '#ffff00', icon: 'ü™™', weight: 0.3, rarity: 'epic' },
                { id: 'cigarettes', name: 'Cigarettes', color: '#f5f5f5', icon: 'üö¨', weight: 0.2, rarity: 'common' },
                { id: 'donut', name: 'Fresh Donut', color: '#ff69b4', icon: 'üç©', weight: 0.2, rarity: 'common' },
                { id: 'key', name: 'Master Key', color: '#ffd700', icon: 'üîë', weight: 0.1, rarity: 'legendary' },
                { id: 'crowbar', name: 'Titanium Crowbar', color: '#808080', icon: 'üîß', weight: 0.6, rarity: 'uncommon' },
                { id: 'rope', name: 'Climbing Rope', color: '#8B4513', icon: 'ü™¢', weight: 0.4, rarity: 'uncommon' },
                { id: 'map', name: 'Prison Map', color: '#00ff00', icon: 'üó∫Ô∏è', weight: 0.1, rarity: 'rare' },
                { id: 'walkietalkie', name: 'Walkie Talkie', color: '#008080', icon: 'üìª', weight: 0.3, rarity: 'epic' },
                { id: 'wrench', name: 'Wrench', color: '#a0522d', icon: 'üîß', weight: 0.5, rarity: 'common' },
                { id: 'documents', name: 'Legal Documents', color: '#ffffff', icon: 'üìÑ', weight: 0.1, rarity: 'epic' }
            ],
            
            ESCAPE_REQUIREMENTS: {
                tunnel: ['shovel', 'crowbar'],
                disguise: ['uniform', 'idcard'],
                riot: ['reputation_50'],
                parole: ['clean_record', 'documents']
            },
            
            ESCAPE_HINTS: [
                "Guards patrol in predictable patterns - observe them carefully.",
                "The laundry room often has spare uniforms if you're sneaky.",
                "Night shift guards are lazier than day shift.",
                "Make friends with inmate bots to gain reputation.",
                "The western wall has weaker security near the old generator.",
                "Some guards can be bribed with contraband items.",
                "Check behind the cafeteria for hidden items.",
                "Coordinate timing with your partner for better success.",
                "Use the ventilation system to move undetected.",
                "The warden's office has valuable escape materials."
            ],
            
            FAILURE_MESSAGES: [
                "The guards found your tunnel! Better luck next time.",
                "Your disguise was convincing... until you tripped over your own feet.",
                "The riot fizzled out faster than a wet firecracker.",
                "The warden laughed at your parole request. Try again.",
                "Security caught you red-handed! Back to solitary.",
                "The guard dogs found your scent. Game over.",
                "Your escape rope snapped! Gravity is not your friend.",
                "The security cameras caught every move.",
                "You forgot the guard's coffee - he's not happy.",
                "The other inmates ratted you out!"
            ]
        };

        // ============================================================================
        // ENHANCED GAME STATE
        // ============================================================================
        let gameState = {
            players: {},
            bots: [],
            items: [],
            prisonLayout: [],
            timeOfDay: 0.3,
            isNight: true,
            gameStarted: false,
            escapeInProgress: false,
            playerId: null,
            peer: null,
            dataChannel: null,
            isHost: false,
            roomCode: null,
            connectionEstablished: false,
            lastUpdate: 0,
            fps: 60,
            gameLoaded: false,
            prisonSeed: Date.now(),
            rng: null,
            connectionCheckInterval: null,
            gameTime: 0,
            isPaused: false,
            audioEnabled: true,
            pingInterval: null,
            lastPing: 0,
            latency: 0,
            localPlayer: null
        };

        // ============================================================================
        // AUDIO SYSTEM
        // ============================================================================
        const AudioSystem = {
            sounds: {},
            music: null,
            volume: 0.5,
            
            init() {
                // Background Music
                this.music = new Howl({
                    src: ['https://assets.mixkit.co/music/preview/mixkit-game-show-suspense-waiting-667.mp3'],
                    volume: this.volume,
                    loop: true,
                    autoplay: false
                });
                
                // Sound Effects
                this.sounds = {
                    collect: new Howl({ src: ['https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3'], volume: 0.3 }),
                    guardAlert: new Howl({ src: ['https://assets.mixkit.co/sfx/preview/mixkit-warning-alarm-buzzer-1558.mp3'], volume: 0.4 }),
                    escapeStart: new Howl({ src: ['https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3'], volume: 0.5 }),
                    success: new Howl({ src: ['https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3'], volume: 0.6 }),
                    failure: new Howl({ src: ['https://assets.mixkit.co/sfx/preview/mixkit-cartoon-falling-whistle-392.mp3'], volume: 0.5 }),
                    hit: new Howl({ src: ['https://assets.mixkit.co/sfx/preview/mixkit-boxing-punch-2051.mp3'], volume: 0.3 }),
                    chat: new Howl({ src: ['https://assets.mixkit.co/sfx/preview/mixkit-plastic-bubble-click-1124.mp3'], volume: 0.2 }),
                    button: new Howl({ src: ['https://assets.mixkit.co/sfx/preview/mixkit-select-click-1109.mp3'], volume: 0.2 })
                };
            },
            
            play(soundName) {
                if (!gameState.audioEnabled || !this.sounds[soundName]) return;
                this.sounds[soundName].play();
            },
            
            toggle() {
                gameState.audioEnabled = !gameState.audioEnabled;
                const newVolume = gameState.audioEnabled ? 0.5 : 0;
                this.music.volume(newVolume);
                Object.values(this.sounds).forEach(sound => sound.volume(gameState.audioEnabled ? sound._volume : 0));
                
                const btn = document.getElementById('audioToggleBtn');
                if (btn) btn.textContent = gameState.audioEnabled ? 'üîä SOUND ON' : 'üîá SOUND OFF';
                
                return gameState.audioEnabled;
            },
            
            startMusic() {
                if (gameState.audioEnabled && this.music && !this.music.playing()) {
                    this.music.play();
                }
            },
            
            stopMusic() {
                if (this.music && this.music.playing()) {
                    this.music.stop();
                }
            }
        };

        // ============================================================================
        // THREE.JS VARIABLES
        // ============================================================================
        let scene, camera, renderer;
        let playerMesh, otherPlayerMesh;
        let botMeshes = [], itemMeshes = [], wallMeshes = [], cellMeshes = [];
        let clock = new THREE.Clock();
        let moveSpeed = 0.2;
        let isRunning = false;

        // ============================================================================
        // INPUT STATE
        // ============================================================================
        const keys = {};
        const mouse = { x: 0, y: 0, down: false };
        let touchControls = {};

        // ============================================================================
        // PARTICLE SYSTEM
        // ============================================================================
        class ParticleSystem {
            constructor() {
                this.canvas = document.getElementById('particles');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.init();
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            init() {
                for (let i = 0; i < 50; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 1,
                        speed: Math.random() * 0.5 + 0.2,
                        color: `rgba(0, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.5)`
                    });
                }
            }
            
            update() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let particle of this.particles) {
                    particle.y -= particle.speed;
                    if (particle.y < 0) {
                        particle.y = this.canvas.height;
                        particle.x = Math.random() * this.canvas.width;
                    }
                    
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Glow effect
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = particle.color;
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
            }
        }

        // ============================================================================
        // LOBBY FUNCTIONS - ENHANCED
        // ============================================================================

        function joinGame() {
            AudioSystem.play('button');
            document.getElementById('joinSection').style.display = 'block';
            document.getElementById('hostBtn').disabled = true;
            document.getElementById('joinBtn').disabled = true;
            document.getElementById('tutorialBtn').disabled = true;
            document.getElementById('roomCode').focus();
            showMessage("Enter the 4-digit room code from your partner", "info");
        }

        function showTutorial() {
            AudioSystem.play('button');
            document.getElementById('tutorialSection').style.display = 'block';
        }

        function hideTutorial() {
            AudioSystem.play('button');
            document.getElementById('tutorialSection').style.display = 'none';
        }

        function cancelJoin() {
            AudioSystem.play('button');
            document.getElementById('joinSection').style.display = 'none';
            document.getElementById('hostBtn').disabled = false;
            document.getElementById('joinBtn').disabled = false;
            document.getElementById('tutorialBtn').disabled = false;
            document.getElementById('connectStatus').textContent = '';
            updateConnectionStatus('disconnected', 'Ready to play');
        }

        function cancelHost() {
            AudioSystem.play('button');
            if (gameState.peer) {
                gameState.peer.close();
            }
            if (gameState.connectionCheckInterval) {
                clearInterval(gameState.connectionCheckInterval);
            }
            localStorage.removeItem('cbz_hostOffer');
            localStorage.removeItem('cbz_iceCandidates');
            localStorage.removeItem('cbz_roomInfo');
            document.getElementById('roomInfo').style.display = 'none';
            document.getElementById('hostBtn').disabled = false;
            document.getElementById('joinBtn').disabled = false;
            document.getElementById('tutorialBtn').disabled = false;
            updateConnectionStatus('disconnected', 'Ready to play');
            showMessage("Room cancelled", "info");
        }

        function cancelWaiting() {
            AudioSystem.play('button');
            document.getElementById('waitingOverlay').style.display = 'none';
            if (gameState.peer) {
                gameState.peer.close();
            }
            if (gameState.pingInterval) {
                clearInterval(gameState.pingInterval);
            }
            gameState.connectionEstablished = false;
            updateConnectionStatus('disconnected', 'Connection cancelled');
            showMessage("Connection cancelled", "info");
        }

        function copyRoomCode() {
            const code = document.getElementById('displayCode').textContent;
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(code).then(() => {
                    showMessage("Room code copied to clipboard! ‚úì", "success");
                }).catch(() => {
                    fallbackCopy(code);
                });
            } else {
                fallbackCopy(code);
            }
        }

        function fallbackCopy(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.opacity = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                showMessage("Room code copied! ‚úì", "success");
            } catch (err) {
                showMessage("Failed to copy code", "error");
            }
            document.body.removeChild(textArea);
        }

        // ============================================================================
        // INITIALIZATION - ENHANCED
        // ============================================================================
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ Cell Block Zero - Enhanced Edition Initializing');
            
            // Initialize Audio
            AudioSystem.init();
            
            // Initialize Particle System
            new ParticleSystem();
            
            // Check for WebRTC support
            if (!navigator.mediaDevices || !window.RTCPeerConnection) {
                showMessage("‚ùå WebRTC not supported. Please use Chrome, Firefox, or Edge.", "error");
                return;
            }
            
            // Check for Three.js
            if (typeof THREE === 'undefined') {
                showMessage("‚ùå Three.js failed to load. Please check connection.", "error");
                return;
            }
            
            // Initialize RNG
            gameState.rng = new EnhancedRandom(Date.now());
            
            // Initialize UI
            updateConnectionStatus('ready', 'System Online');
            
            // Show mobile controls for mobile devices
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                document.getElementById('mobileControls').style.display = 'flex';
                document.getElementById('audioControls').style.display = 'block';
            }
            
            // Start background music
            setTimeout(() => AudioSystem.startMusic(), 1000);
            
            console.log('‚úÖ Game initialized successfully');
            gameState.gameLoaded = true;
            simulateLoading();
        });

        function simulateLoading() {
            const loadingText = document.getElementById('loadingText');
            const loadingProgress = document.getElementById('loadingProgress');
            const steps = [
                "Initializing prison security system...",
                "Loading guard patrol patterns...",
                "Generating prison layout...",
                "Calibrating escape protocols...",
                "Establishing secure channels...",
                "Ready for escape sequence..."
            ];
            
            let step = 0;
            const interval = setInterval(() => {
                if (step < steps.length) {
                    loadingText.textContent = steps[step];
                    loadingProgress.style.width = `${(step + 1) * (100 / steps.length)}%`;
                    step++;
                } else {
                    clearInterval(interval);
                    showLoadingScreen(false);
                }
            }, 500);
        }

        function updateConnectionStatus(status, message) {
            const element = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            if (element) {
                element.className = `status-${status}`;
                if (statusText) statusText.textContent = message;
            }
        }

        function showWaitingScreen(message) {
            document.getElementById('waitingOverlay').style.display = 'flex';
            document.getElementById('waitingMessage').textContent = message;
            
            // Animate connection progress
            const progress = document.getElementById('connectionProgress');
            let width = 0;
            const interval = setInterval(() => {
                if (width >= 100 || gameState.connectionEstablished) {
                    clearInterval(interval);
                    if (gameState.connectionEstablished) {
                        progress.style.width = '100%';
                    }
                } else {
                    width += 5;
                    progress.style.width = width + '%';
                }
            }, 500);
        }

        function hideWaitingScreen() {
            document.getElementById('waitingOverlay').style.display = 'none';
        }

        // ============================================================================
        // ENHANCED NETWORKING SYSTEM
        // ============================================================================

        function hostGame() {
            if (!gameState.gameLoaded) {
                showMessage("System still initializing...", "warning");
                return;
            }
            
            AudioSystem.play('button');
            
            document.getElementById('hostBtn').disabled = true;
            document.getElementById('joinBtn').disabled = true;
            document.getElementById('tutorialBtn').disabled = true;
            updateConnectionStatus('connecting', 'Creating secure room...');
            
            gameState.isHost = true;
            gameState.playerId = 'host_' + generateSecureId();
            gameState.roomCode = generateRoomCode();
            gameState.prisonSeed = Date.now();
            gameState.rng = new EnhancedRandom(gameState.prisonSeed);
            
            // Create enhanced peer connection
            gameState.peer = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' },
                    { urls: 'stun:stun.voip.blackberry.com:3478' },
                    { urls: 'turn:global.turn.twilio.com:3478?transport=udp',
                      username: 'c2967c35bdd57f9a3a12e9533e6e5d648bb03a8d6198ed8ed36c2b76a6f5d7e7',
                      credential: 'q7D3f7kE9aLnS1MbK/bqF1kyMIs=' },
                    { urls: 'turn:global.turn.twilio.com:3478?transport=tcp',
                      username: 'c2967c35bdd57f9a3a12e9533e6e5d648bb03a8d6198ed8ed36c2b76a6f5d7e7',
                      credential: 'q7D3f7kE9aLnS1MbK/bqF1kyMIs=' }
                ],
                iceCandidatePoolSize: 10,
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            });
            
            // Create reliable data channel
            gameState.dataChannel = gameState.peer.createDataChannel('cellblockzero', {
                ordered: true,
                maxPacketLifeTime: 3000,
                maxRetransmits: 10
            });
            
            setupDataChannel(gameState.dataChannel);
            
            // Enhanced ICE candidate handling
            gameState.peer.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidates = JSON.parse(localStorage.getItem('cbz_iceCandidates') || '[]');
                    candidates.push({
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        usernameFragment: event.candidate.usernameFragment,
                        timestamp: Date.now()
                    });
                    localStorage.setItem('cbz_iceCandidates', JSON.stringify(candidates));
                }
            };
            
            // Enhanced connection state handling
            gameState.peer.onconnectionstatechange = () => {
                console.log('Connection state:', gameState.peer.connectionState);
                switch(gameState.peer.connectionState) {
                    case 'connected':
                        updateConnectionStatus('connected', 'Partner connected!');
                        document.getElementById('startBtn').disabled = false;
                        document.getElementById('connectionCount').textContent = '‚úÖ Partner connected! Ready to escape!';
                        showMessage("Partner connected! Ready to start escape!", "success");
                        break;
                    case 'disconnected':
                    case 'failed':
                        updateConnectionStatus('disconnected', 'Connection lost');
                        showMessage("Connection lost with partner", "error");
                        break;
                }
            };
            
            // Create and store offer with enhanced reliability
            gameState.peer.createOffer({
                offerToReceiveAudio: false,
                offerToReceiveVideo: false
            })
            .then(offer => {
                console.log('Host created offer');
                return gameState.peer.setLocalDescription(offer);
            })
            .then(() => {
                console.log('Host set local description');
                
                // Store enhanced offer data
                const roomData = {
                    sdp: gameState.peer.localDescription,
                    roomCode: gameState.roomCode,
                    playerId: gameState.playerId,
                    prisonSeed: gameState.prisonSeed,
                    timestamp: Date.now(),
                    expires: Date.now() + CONFIG.ROOM_EXPIRE_TIME,
                    version: '2.0'
                };
                
                localStorage.setItem('cbz_hostOffer', JSON.stringify(roomData));
                localStorage.setItem('cbz_roomInfo', JSON.stringify({
                    code: gameState.roomCode,
                    created: Date.now(),
                    host: gameState.playerId
                }));
                localStorage.setItem('cbz_iceCandidates', '[]');
                localStorage.removeItem('cbz_playerAnswer');
                localStorage.removeItem('cbz_playerIceCandidates');
                
                // Show room info
                document.getElementById('roomInfo').style.display = 'block';
                document.getElementById('displayCode').textContent = gameState.roomCode;
                updateConnectionStatus('connecting', `Waiting for partner... Code: ${gameState.roomCode}`);
                
                // Start room timer
                startRoomTimer();
                
                // Start enhanced connection polling
                startEnhancedConnectionPolling();
                
                console.log('‚úÖ Room created:', gameState.roomCode);
                showMessage(`Room created! Code: ${gameState.roomCode}`, "success");
            })
            .catch(error => {
                console.error('Error creating offer:', error);
                updateConnectionStatus('disconnected', 'Failed to create room');
                showMessage("Failed to create room. Please try again.", "error");
                resetLobbyButtons();
            });
        }

        function startRoomTimer() {
            const timerElement = document.getElementById('roomTimer');
            let timeLeft = CONFIG.ROOM_EXPIRE_TIME / 1000;
            
            const timer = setInterval(() => {
                if (!document.getElementById('roomInfo').style.display || 
                    document.getElementById('roomInfo').style.display === 'none') {
                    clearInterval(timer);
                    return;
                }
                
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    if (gameState.isHost && !gameState.connectionEstablished) {
                        showMessage("Room expired. No partner joined.", "warning");
                        cancelHost();
                    }
                }
            }, 1000);
        }

        function startEnhancedConnectionPolling() {
            if (gameState.connectionCheckInterval) {
                clearInterval(gameState.connectionCheckInterval);
            }
            
            let pollAttempts = 0;
            const maxPolls = 30; // 30 seconds max
            
            gameState.connectionCheckInterval = setInterval(() => {
                if (gameState.connectionEstablished) {
                    clearInterval(gameState.connectionCheckInterval);
                    return;
                }
                
                pollAttempts++;
                if (pollAttempts > maxPolls) {
                    clearInterval(gameState.connectionCheckInterval);
                    showMessage("Connection timeout. Please try again.", "warning");
                    return;
                }
                
                try {
                    // Check for answer from joiner
                    const playerAnswer = localStorage.getItem('cbz_playerAnswer');
                    if (playerAnswer) {
                        const answer = JSON.parse(playerAnswer);
                        console.log('Found answer from joiner:', answer);
                        
                        if (answer.roomCode === gameState.roomCode) {
                            console.log('Setting remote description from joiner');
                            gameState.peer.setRemoteDescription(new RTCSessionDescription(answer.sdp))
                                .then(() => {
                                    console.log('‚úÖ Remote description set');
                                    
                                    // Add ICE candidates from joiner
                                    const candidateData = localStorage.getItem('cbz_playerIceCandidates');
                                    if (candidateData) {
                                        const candidates = JSON.parse(candidateData);
                                        if (candidates.roomCode === gameState.roomCode && Array.isArray(candidates.candidates)) {
                                            candidates.candidates.forEach(candidateData => {
                                                const candidate = new RTCIceCandidate({
                                                    candidate: candidateData.candidate,
                                                    sdpMid: candidateData.sdpMid,
                                                    sdpMLineIndex: candidateData.sdpMLineIndex,
                                                    usernameFragment: candidateData.usernameFragment
                                                });
                                                gameState.peer.addIceCandidate(candidate).catch(e => console.warn('ICE candidate error:', e));
                                            });
                                        }
                                    }
                                    
                                    // Clear stored data
                                    localStorage.removeItem('cbz_playerAnswer');
                                    localStorage.removeItem('cbz_playerIceCandidates');
                                })
                                .catch(error => {
                                    console.error('Error setting remote description:', error);
                                });
                        }
                    }
                    
                    // Update connection status
                    document.getElementById('connectionCount').textContent = 
                        `‚åõ Waiting for partner... (${pollAttempts}/${maxPolls})`;
                        
                } catch (e) {
                    console.error('Polling error:', e);
                }
            }, 1000);
        }

        function connectToHost() {
            const roomCodeInput = document.getElementById('roomCode');
            const roomCode = roomCodeInput.value.trim().toUpperCase();
            const connectBtn = document.getElementById('connectBtn');
            const connectStatus = document.getElementById('connectStatus');
            
            if (!roomCode || roomCode.length !== 4 || !/^[A-Z0-9]{4}$/.test(roomCode)) {
                showMessage("Please enter a valid 4-character code (A-Z, 0-9)", "error");
                roomCodeInput.focus();
                return;
            }
            
            AudioSystem.play('button');
            
            connectBtn.disabled = true;
            connectBtn.textContent = 'CONNECTING...';
            connectStatus.textContent = 'üîç Searching for room...';
            updateConnectionStatus('connecting', 'Connecting to host...');
            
            gameState.isHost = false;
            gameState.playerId = 'joiner_' + generateSecureId();
            gameState.roomCode = roomCode;
            
            // Clear any old data
            localStorage.removeItem('cbz_playerAnswer');
            localStorage.removeItem('cbz_playerIceCandidates');
            
            showWaitingScreen("Connecting to host... Please wait");
            
            // Start connection attempt with enhanced reliability
            attemptConnection();
        }

        function attemptConnection() {
            const connectStatus = document.getElementById('connectStatus');
            let attempts = 0;
            const maxAttempts = 20;
            
            function tryConnect() {
                attempts++;
                const statusMsg = `Searching for room... (Attempt ${attempts}/${maxAttempts})`;
                connectStatus.textContent = statusMsg;
                document.getElementById('waitingMessage').textContent = statusMsg;
                
                // Check for host offer
                const hostData = localStorage.getItem('cbz_hostOffer');
                
                if (!hostData) {
                    if (attempts < maxAttempts) {
                        setTimeout(tryConnect, 1000);
                    } else {
                        connectionFailed("Room not found. Make sure host created a room first.");
                    }
                    return;
                }
                
                let hostOffer;
                try {
                    hostOffer = JSON.parse(hostData);
                    
                    // Validate room code and expiration
                    if (hostOffer.roomCode !== gameState.roomCode) {
                        if (attempts < maxAttempts) {
                            setTimeout(tryConnect, 1000);
                        } else {
                            connectionFailed("Invalid room code. Please check and try again.");
                        }
                        return;
                    }
                    
                    if (Date.now() > hostOffer.expires) {
                        connectionFailed("Room has expired. Ask host to create a new room.");
                        return;
                    }
                    
                    gameState.prisonSeed = hostOffer.prisonSeed || Date.now();
                    gameState.rng = new EnhancedRandom(gameState.prisonSeed);
                    
                    // Proceed with connection
                    setupJoinerConnection(hostOffer);
                    
                } catch (e) {
                    console.error('Error parsing host data:', e);
                    connectionFailed("Error reading room data. Please try again.");
                }
            }
            
            tryConnect();
        }

        function setupJoinerConnection(hostOffer) {
            console.log('Setting up joiner connection...');
            
            // Create peer connection with enhanced settings
            gameState.peer = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' },
                    { urls: 'stun:stun.voip.blackberry.com:3478' }
                ],
                iceCandidatePoolSize: 10,
                iceTransportPolicy: 'all'
            });
            
            // Set up data channel listener
            gameState.peer.ondatachannel = (event) => {
                console.log('Data channel received from host');
                gameState.dataChannel = event.channel;
                setupDataChannel(gameState.dataChannel);
            };
            
            // Handle ICE candidates
            const joinerIceCandidates = [];
            gameState.peer.onicecandidate = (event) => {
                if (event.candidate) {
                    joinerIceCandidates.push({
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        usernameFragment: event.candidate.usernameFragment,
                        timestamp: Date.now()
                    });
                }
            };
            
            // Handle connection state
            gameState.peer.onconnectionstatechange = () => {
                const state = gameState.peer.connectionState;
                console.log('Joiner connection state:', state);
                
                switch(state) {
                    case 'connected':
                        updateConnectionStatus('connected', 'Connected to host!');
                        document.getElementById('connectStatus').textContent = '‚úÖ Connected!';
                        showMessage("Successfully connected to host!", "success");
                        hideWaitingScreen();
                        break;
                    case 'failed':
                        updateConnectionStatus('disconnected', 'Connection failed');
                        showMessage("Connection failed. Please try again.", "error");
                        hideWaitingScreen();
                        break;
                }
            };
            
            // Set remote description and create answer
            gameState.peer.setRemoteDescription(new RTCSessionDescription(hostOffer.sdp))
                .then(() => {
                    console.log('Remote description set, creating answer...');
                    return gameState.peer.createAnswer();
                })
                .then(answer => {
                    console.log('Answer created, setting local description...');
                    return gameState.peer.setLocalDescription(answer);
                })
                .then(() => {
                    console.log('Local description set, storing answer...');
                    
                    // Store answer for host
                    localStorage.setItem('cbz_playerAnswer', JSON.stringify({
                        sdp: gameState.peer.localDescription,
                        roomCode: gameState.roomCode,
                        playerId: gameState.playerId,
                        timestamp: Date.now()
                    }));
                    
                    // Store ICE candidates
                    localStorage.setItem('cbz_playerIceCandidates', JSON.stringify({
                        roomCode: gameState.roomCode,
                        candidates: joinerIceCandidates,
                        timestamp: Date.now()
                    }));
                    
                    // Add any stored ICE candidates from host
                    const hostCandidates = JSON.parse(localStorage.getItem('cbz_iceCandidates') || '[]');
                    hostCandidates.forEach(candidateData => {
                        const candidate = new RTCIceCandidate({
                            candidate: candidateData.candidate,
                            sdpMid: candidateData.sdpMid,
                            sdpMLineIndex: candidateData.sdpMLineIndex,
                            usernameFragment: candidateData.usernameFragment
                        });
                        gameState.peer.addIceCandidate(candidate).catch(e => console.warn('ICE candidate error:', e));
                    });
                    
                    console.log('‚úÖ Joiner connection established');
                    
                })
                .catch(error => {
                    console.error('Connection error:', error);
                    connectionFailed("Connection failed. Please check room code and try again.");
                });
        }

        function connectionFailed(message) {
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('connectBtn').textContent = 'CONNECT';
            document.getElementById('connectStatus').textContent = message;
            updateConnectionStatus('disconnected', 'Connection failed');
            showMessage(message, "error");
            hideWaitingScreen();
        }

        function setupDataChannel(channel) {
            console.log('Setting up data channel communication...');
            
            channel.onopen = () => {
                console.log('‚úÖ Data channel opened!');
                gameState.connectionEstablished = true;
                updateConnectionStatus('connected', 'Secure channel established');
                
                if (gameState.isHost) {
                    showMessage("Partner connected successfully!", "success");
                } else {
                    showMessage("Connected to host! Waiting for game start...", "success");
                }
                
                // Start ping-pong for connection monitoring
                startPingPong();
                
                // Send player info
                sendNetworkMessage('playerJoin', {
                    playerId: gameState.playerId,
                    name: `Player ${gameState.isHost ? '1' : '2'}`,
                    isHost: gameState.isHost,
                    timestamp: Date.now()
                });
            };
            
            channel.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleNetworkMessage(data);
                } catch (e) {
                    console.error('Error parsing network message:', e);
                }
            };
            
            channel.onclose = () => {
                console.log('Data channel closed');
                gameState.connectionEstablished = false;
                updateConnectionStatus('disconnected', 'Disconnected from partner');
                
                if (gameState.gameStarted) {
                    showMessage("Partner disconnected!", "error");
                } else {
                    hideWaitingScreen();
                }
                
                if (gameState.pingInterval) {
                    clearInterval(gameState.pingInterval);
                }
            };
        }

        function startPingPong() {
            if (gameState.pingInterval) {
                clearInterval(gameState.pingInterval);
            }
            
            gameState.pingInterval = setInterval(() => {
                if (gameState.dataChannel && gameState.dataChannel.readyState === 'open') {
                    gameState.lastPing = Date.now();
                    sendNetworkMessage('ping', { timestamp: gameState.lastPing });
                }
            }, 5000);
        }

        function sendNetworkMessage(type, data) {
            if (gameState.dataChannel && gameState.dataChannel.readyState === 'open') {
                try {
                    const message = {
                        type: type,
                        sender: gameState.playerId,
                        data: data,
                        timestamp: Date.now(),
                        seq: Math.random().toString(36).substr(2, 9)
                    };
                    gameState.dataChannel.send(JSON.stringify(message));
                } catch (e) {
                    console.error('Error sending network message:', e);
                }
            }
        }

        function handleNetworkMessage(message) {
            switch (message.type) {
                case 'playerJoin':
                    handlePlayerJoin(message);
                    break;
                case 'playerUpdate':
                    updatePlayer(message.sender, message.data);
                    break;
                case 'gameStart':
                    startGameFromNetwork(message.data);
                    break;
                case 'itemCollected':
                    collectItemRemote(message.data);
                    break;
                case 'botUpdate':
                    updateBot(message.data);
                    break;
                case 'escapeAttempt':
                    handleEscapeAttempt(message.data);
                    break;
                case 'chat':
                    displayChatMessage(message.sender, message.data.text, false, message.data.type);
                    break;
                case 'gameOver':
                    handleGameOver(message.data);
                    break;
                case 'ping':
                    sendNetworkMessage('pong', { timestamp: message.data.timestamp, received: Date.now() });
                    break;
                case 'pong':
                    gameState.latency = Date.now() - message.data.timestamp;
                    break;
            }
        }

        function handlePlayerJoin(message) {
            const { playerId, name, isHost } = message.data;
            
            if (playerId === gameState.playerId) return;
            
            if (!gameState.players[playerId]) {
                gameState.players[playerId] = {
                    id: playerId,
                    name: name,
                    position: { x: isHost ? -20 : 20, y: 1, z: 0 },
                    health: 100,
                    contraband: 0,
                    reputation: 0,
                    inventory: [],
                    status: 'Connected',
                    lastUpdate: Date.now()
                };
                
                document.getElementById('playerName2').textContent = `(${name})`;
                document.getElementById('status2').textContent = 'Connected';
                
                if (gameState.isHost && !gameState.gameStarted) {
                    showMessage(`${name} connected! Ready to start.`, "success");
                }
            }
        }

        // ============================================================================
        // GAME START - ENHANCED
        // ============================================================================
        function startGame() {
            if (!gameState.isHost || !gameState.connectionEstablished) {
                showMessage("Wait for partner to connect first", "warning");
                return;
            }
            
            AudioSystem.play('escapeStart');
            showLoadingScreen(true);
            document.getElementById('loadingText').textContent = 'Initializing prison escape sequence...';
            
            // Initialize Three.js and game
            setTimeout(() => {
                try {
                    initThreeJS();
                    generatePrison(gameState.prisonSeed);
                    createPlayer(gameState.playerId, true);
                    
                    // Send game start to other player
                    sendNetworkMessage('gameStart', {
                        prisonSeed: gameState.prisonSeed,
                        playerPositions: {
                            [gameState.playerId]: { x: -20, y: 1, z: 0 },
                            [Object.keys(gameState.players)[1]]: { x: 20, y: 1, z: 0 }
                        },
                        timestamp: Date.now()
                    });
                    
                    // Start game locally
                    setTimeout(() => {
                        startGameLocal();
                    }, 1500);
                    
                } catch (error) {
                    console.error('Error starting game:', error);
                    showMessage("Error starting game: " + error.message, "error");
                    showLoadingScreen(false);
                }
            }, 1000);
        }

        function startGameFromNetwork(data) {
            console.log('Starting game from network signal...');
            AudioSystem.play('escapeStart');
            showLoadingScreen(true);
            document.getElementById('loadingText').textContent = 'Joining escape mission...';
            
            gameState.prisonSeed = data.prisonSeed;
            gameState.rng = new EnhancedRandom(gameState.prisonSeed);
            
            setTimeout(() => {
                try {
                    initThreeJS();
                    generatePrison(gameState.prisonSeed);
                    
                    const myPosition = data.playerPositions[gameState.playerId] || { x: 20, y: 1, z: 0 };
                    createPlayer(gameState.playerId, true);
                    
                    if (playerMesh && myPosition) {
                        playerMesh.position.set(myPosition.x, myPosition.y, myPosition.z);
                    }
                    
                    setTimeout(() => {
                        startGameLocal();
                    }, 1500);
                    
                } catch (error) {
                    console.error('Error joining game:', error);
                    showMessage("Error joining game: " + error.message, "error");
                    showLoadingScreen(false);
                    hideWaitingScreen();
                }
            }, 1000);
        }

        function startGameLocal() {
            console.log('üöÄ Starting escape mission...');
            gameState.gameStarted = true;
            gameState.gameTime = 0;
            
            // Hide overlays, show game
            showLoadingScreen(false);
            hideWaitingScreen();
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            document.getElementById('timerDisplay').style.display = 'block';
            
            // Show objective
            document.getElementById('objective').style.display = 'block';
            document.getElementById('objectiveText').textContent = "ESCAPE MAXIMUM SECURITY PRISON ALPHA";
            document.getElementById('objectiveSubtext').textContent = "Coordinate with your partner. Collect items. Avoid detection. Escape.";
            
            // Start game loop
            animate();
            setupEventListeners();
            updateGameTimer();
            
            console.log('‚úÖ Escape mission started!');
            showMessage("Escape mission initiated! Good luck, inmates!", "success");
        }

        function showLoadingScreen(show) {
            document.getElementById('loadingScreen').style.display = show ? 'flex' : 'none';
        }

        // ============================================================================
        // ENHANCED THREE.JS INITIALIZATION
        // ============================================================================
        function initThreeJS() {
            console.log('Initializing enhanced Three.js engine...');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a1a, 30, 150);
            
            // Enhanced camera with smoother movement
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 40);
            
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            
            // Enhanced lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(50, 100, 50);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 4096;
            mainLight.shadow.mapSize.height = 4096;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 500;
            mainLight.shadow.camera.left = -100;
            mainLight.shadow.camera.right = 100;
            mainLight.shadow.camera.top = 100;
            mainLight.shadow.camera.bottom = -100;
            scene.add(mainLight);
            
            // Moonlight for night effect
            const moonLight = new THREE.DirectionalLight(0x4488ff, 0.3);
            moonLight.position.set(-50, 100, -50);
            scene.add(moonLight);
            
            // Enhanced ground
            const groundGeometry = new THREE.PlaneGeometry(300, 300);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a3322,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add grid for better spatial awareness
            const gridHelper = new THREE.GridHelper(300, 30, 0x00ff00, 0x003300);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
            
            console.log('‚úÖ Three.js initialized successfully');
        }

        // ============================================================================
        // ENHANCED PRISON GENERATION
        // ============================================================================
        function generatePrison(seed = Date.now()) {
            console.log('Generating maximum security prison...');
            
            const rng = new EnhancedRandom(seed);
            
            // Clear existing objects
            [wallMeshes, itemMeshes, botMeshes, cellMeshes].forEach(arr => {
                arr.forEach(mesh => {
                    if (mesh && mesh.parent) scene.remove(mesh);
                });
                arr.length = 0;
            });
            
            gameState.items = [];
            gameState.bots = [];
            
            // Outer walls with enhanced detail
            const wallHeight = 12;
            const wallThickness = 3;
            const halfSize = CONFIG.PRISON_SIZE / 2;
            
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.3,
                bumpScale: 0.05
            });
            
            // Create prison walls with watchtowers
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                const x = Math.cos(angle) * halfSize;
                const z = Math.sin(angle) * halfSize;
                
                const wallGeometry = new THREE.BoxGeometry(
                    i % 2 === 0 ? CONFIG.PRISON_SIZE : wallThickness,
                    wallHeight,
                    i % 2 === 0 ? wallThickness : CONFIG.PRISON_SIZE
                );
                
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(x, wallHeight/2, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                wallMeshes.push(wall);
                
                // Add watchtowers at corners
                if (i % 2 === 0) {
                    const towerGeometry = new THREE.CylinderGeometry(3, 3, wallHeight + 8, 8);
                    const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    tower.position.set(x + (x > 0 ? -40 : 40), (wallHeight + 8)/2, z + (z > 0 ? -40 : 40));
                    tower.castShadow = true;
                    scene.add(tower);
                    wallMeshes.push(tower);
                }
            }
            
            // Cell blocks with individual cells
            const cellMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.7,
                emissive: 0x111111
            });
            
            for (let i = 0; i < CONFIG.CELL_COUNT; i++) {
                const row = Math.floor(i / 5);
                const col = i % 5;
                const x = (col - 2) * 18;
                const z = (row - 2) * 18;
                
                // Cell block structure
                const cellGeometry = new THREE.BoxGeometry(10, 6, 8);
                const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                cell.position.set(x, 3, z);
                cell.castShadow = true;
                cell.receiveShadow = true;
                scene.add(cell);
                cellMeshes.push(cell);
                
                // Cell door
                const doorGeometry = new THREE.BoxGeometry(2, 4, 0.5);
                const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(x + 4, 2, z);
                door.castShadow = true;
                scene.add(door);
                cellMeshes.push(door);
            }
            
            // Admin buildings
            const adminGeometry = new THREE.BoxGeometry(30, 10, 20);
            const adminMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const adminBuilding = new THREE.Mesh(adminGeometry, adminMaterial);
            adminBuilding.position.set(0, 5, -halfSize + 25);
            adminBuilding.castShadow = true;
            scene.add(adminBuilding);
            wallMeshes.push(adminBuilding);
            
            // Generate items with enhanced placement
            const placedItems = new Set();
            CONFIG.ITEM_TYPES.forEach((itemType) => {
                let attempts = 0;
                let placed = false;
                
                while (!placed && attempts < 20) {
                    const x = rng.range(-60, 60);
                    const z = rng.range(-60, 60);
                    const key = `${Math.round(x/10)}_${Math.round(z/10)}`;
                    
                    if (!placedItems.has(key)) {
                        placedItems.add(key);
                        
                        let geometry;
                        switch(itemType.id) {
                            case 'shovel':
                                geometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
                                break;
                            case 'uniform':
                                geometry = new THREE.BoxGeometry(1.2, 1.8, 0.4);
                                break;
                            case 'idcard':
                                geometry = new THREE.BoxGeometry(0.6, 0.4, 0.05);
                                break;
                            case 'crowbar':
                                geometry = new THREE.BoxGeometry(0.2, 1.6, 0.2);
                                break;
                            default:
                                geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                        }
                        
                        const material = new THREE.MeshStandardMaterial({ 
                            color: itemType.color,
                            roughness: 0.4,
                            metalness: 0.6,
                            emissive: new THREE.Color(itemType.color).multiplyScalar(0.1)
                        });
                        
                        const item = new THREE.Mesh(geometry, material);
                        item.position.set(x, 1.5, z);
                        item.rotation.y = rng.range(0, Math.PI * 2);
                        item.castShadow = true;
                        item.userData = {
                            type: itemType.id,
                            name: itemType.name,
                            collected: false,
                            rarity: itemType.rarity
                        };
                        
                        scene.add(item);
                        itemMeshes.push(item);
                        
                        gameState.items.push({
                            type: itemType.id,
                            position: { x, y: 1.5, z },
                            collected: false,
                            rarity: itemType.rarity
                        });
                        
                        placed = true;
                    }
                    attempts++;
                }
            });
            
            // Generate enhanced guard bots
            for (let i = 0; i < CONFIG.GUARD_COUNT; i++) {
                const x = rng.range(-halfSize + 20, halfSize - 20);
                const z = rng.range(-halfSize + 20, halfSize - 20);
                
                const guardGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2.5, 8);
                const guardMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0000ff,
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: 0x000044
                });
                
                const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                guard.position.set(x, 1.25, z);
                guard.castShadow = true;
                scene.add(guard);
                botMeshes.push(guard);
                
                // Create patrol path
                const patrolPath = [];
                const points = rng.int(3, 6);
                for (let j = 0; j < points; j++) {
                    patrolPath.push({
                        x: x + rng.range(-30, 30),
                        z: z + rng.range(-30, 30)
                    });
                }
                
                gameState.bots.push({
                    type: 'guard',
                    position: { x, y: 1.25, z },
                    patrolPath,
                    patrolIndex: 0,
                    alertLevel: 0,
                    personality: rng.weightedChoice([
                        { value: 'strict', weight: 0.4 },
                        { value: 'lazy', weight: 0.3 },
                        { value: 'observant', weight: 0.2 },
                        { value: 'corrupt', weight: 0.1 }
                    ]),
                    speed: 0.04 + rng.random() * 0.03,
                    detectionRange: 15 + rng.random() * 10,
                    visionAngle: Math.PI / 4
                });
            }
            
            // Generate inmate bots
            for (let i = 0; i < CONFIG.INMATE_BOT_COUNT; i++) {
                const x = rng.range(-halfSize + 30, halfSize - 30);
                const z = rng.range(-halfSize + 30, halfSize - 30);
                
                const inmateGeometry = new THREE.BoxGeometry(1.2, 2.2, 1.2);
                const inmateMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xaa4400,
                    roughness: 0.8,
                    metalness: 0.1
                });
                
                const inmate = new THREE.Mesh(inmateGeometry, inmateMaterial);
                inmate.position.set(x, 1.1, z);
                inmate.castShadow = true;
                scene.add(inmate);
                botMeshes.push(inmate);
                
                gameState.bots.push({
                    type: 'inmate',
                    position: { x, y: 1.1, z },
                    personality: rng.weightedChoice([
                        { value: 'lazy', weight: 0.4 },
                        { value: 'violent', weight: 0.3 },
                        { value: 'helpful', weight: 0.2 },
                        { value: 'snitch', weight: 0.1 }
                    ]),
                    speed: 0.02 + rng.random() * 0.02,
                    activity: 'wandering',
                    lastActivityChange: 0,
                    mood: rng.weightedChoice([
                        { value: 'neutral', weight: 0.6 },
                        { value: 'angry', weight: 0.2 },
                        { value: 'happy', weight: 0.1 },
                        { value: 'depressed', weight: 0.1 }
                    ])
                });
            }
            
            console.log('‚úÖ Prison generation complete');
        }

        // ============================================================================
        // ENHANCED PLAYER MANAGEMENT
        // ============================================================================
        function createPlayer(playerId, isLocal) {
            const geometry = new THREE.CapsuleGeometry(0.5, 1.5, 8, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: isLocal ? 0xff0066 : 0x00ccff,
                roughness: 0.5,
                metalness: 0.5,
                emissive: isLocal ? 0x660022 : 0x003366,
                emissiveIntensity: 0.2
            });
            
            const player = new THREE.Mesh(geometry, material);
            player.castShadow = true;
            player.receiveShadow = true;
            
            if (isLocal) {
                playerMesh = player;
                playerMesh.position.set(-20, 1.5, 0);
                gameState.localPlayer = playerMesh;
            } else {
                otherPlayerMesh = player;
                otherPlayerMesh.position.set(20, 1.5, 0);
            }
            
            scene.add(player);
            
            if (!gameState.players[playerId]) {
                gameState.players[playerId] = {
                    id: playerId,
                    name: isLocal ? 'You' : 'Partner',
                    position: player.position,
                    health: 100,
                    contraband: 0,
                    reputation: 0,
                    inventory: [],
                    status: 'Exploring',
                    isLocal: isLocal,
                    mesh: player,
                    lastActivity: Date.now()
                };
            } else {
                gameState.players[playerId].mesh = player;
                gameState.players[playerId].isLocal = isLocal;
            }
            
            return player;
        }

        function updatePlayer(playerId, data) {
            if (!gameState.players[playerId]) return;
            
            const player = gameState.players[playerId];
            
            // Smooth position interpolation
            if (player.mesh && !player.isLocal && data.x !== undefined) {
                const targetX = data.x;
                const targetZ = data.z;
                const currentX = player.mesh.position.x;
                const currentZ = player.mesh.position.z;
                
                player.mesh.position.x = currentX + (targetX - currentX) * 0.3;
                player.mesh.position.z = currentZ + (targetZ - currentZ) * 0.3;
                
                if (data.ry !== undefined) {
                    player.mesh.rotation.y = data.ry;
                }
            }
            
            // Update player stats
            if (data.health !== undefined) player.health = data.health;
            if (data.contraband !== undefined) player.contraband = data.contraband;
            if (data.reputation !== undefined) player.reputation = data.reputation;
            if (data.inventory !== undefined) player.inventory = data.inventory;
            if (data.status !== undefined) player.status = data.status;
            
            if (playerId !== gameState.playerId) {
                updatePlayerUI(2, player);
            }
        }

        // ============================================================================
        // ENHANCED GAME LOOP
        // ============================================================================
        function animate() {
            if (!gameState.gameStarted || gameState.isPaused) {
                requestAnimationFrame(animate);
                return;
            }
            
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            gameState.lastUpdate += deltaTime;
            gameState.gameTime += deltaTime;
            
            if (gameState.lastUpdate >= 1/60) {
                gameState.lastUpdate = 0;
                
                updateLocalPlayer();
                updateBots(deltaTime);
                checkCollisions();
                updateCamera();
                updateTimeOfDay(deltaTime);
                updatePrisonLights();
            }
            
            renderer.render(scene, camera);
        }

        function updateLocalPlayer() {
            if (!playerMesh || !gameState.players[gameState.playerId]) return;
            
            const player = gameState.players[gameState.playerId];
            const speed = (isRunning ? moveSpeed * 1.8 : moveSpeed) * (player.health / 100);
            
            // Movement with input
            if (keys['w'] || keys['arrowup']) playerMesh.position.z -= speed;
            if (keys['s'] || keys['arrowdown']) playerMesh.position.z += speed;
            if (keys['a'] || keys['arrowleft']) {
                playerMesh.position.x -= speed;
                playerMesh.rotation.y = Math.PI / 2;
            }
            if (keys['d'] || keys['arrowright']) {
                playerMesh.position.x += speed;
                playerMesh.rotation.y = -Math.PI / 2;
            }
            
            // Jumping
            if (keys[' '] && playerMesh.position.y <= 1.6) {
                playerMesh.position.y += 0.25;
                AudioSystem.play('collect');
            }
            
            // Gravity
            if (playerMesh.position.y > 1.5) {
                playerMesh.position.y -= 0.08;
            }
            
            // Boundary limits
            const halfSize = CONFIG.PRISON_SIZE / 2 - 5;
            playerMesh.position.x = Math.max(-halfSize, Math.min(halfSize, playerMesh.position.x));
            playerMesh.position.z = Math.max(-halfSize, Math.min(halfSize, playerMesh.position.z));
            
            player.position = playerMesh.position.clone();
            
            // Update player status based on activity
            if (keys['shift']) {
                player.status = 'Running';
                if (player.health > 0) player.health = Math.max(1, player.health - 0.01);
            } else if (keys['w'] || keys['a'] || keys['s'] || keys['d']) {
                player.status = 'Walking';
            } else {
                player.status = 'Idle';
            }
            
            // Send updates to partner
            if (gameState.connectionEstablished) {
                sendNetworkMessage('playerUpdate', {
                    x: playerMesh.position.x,
                    y: playerMesh.position.y,
                    z: playerMesh.position.z,
                    ry: playerMesh.rotation.y,
                    health: Math.floor(player.health),
                    contraband: player.contraband,
                    reputation: player.reputation,
                    inventory: player.inventory,
                    status: player.status
                });
            }
            
            updatePlayerUI(1, player);
        }

        function updateBots(deltaTime) {
            gameState.bots.forEach((bot, index) => {
                if (!botMeshes[index]) return;
                
                const mesh = botMeshes[index];
                
                if (bot.type === 'guard') {
                    updateGuardBot(bot, index, deltaTime);
                } else if (bot.type === 'inmate') {
                    updateInmateBot(bot, index, deltaTime);
                }
                
                // Update mesh position
                if (mesh && bot.position) {
                    mesh.position.set(bot.position.x, bot.position.y || 1.25, bot.position.z);
                    
                    // Alert visual feedback
                    if (bot.alertLevel > 30) {
                        mesh.material.emissive.setHex(0xff0000);
                        mesh.material.emissiveIntensity = 0.3 + (bot.alertLevel / 100);
                    } else {
                        mesh.material.emissive.setHex(bot.type === 'guard' ? 0x000044 : 0x221100);
                        mesh.material.emissiveIntensity = 0.1;
                    }
                }
            });
        }

        function updateGuardBot(bot, index, deltaTime) {
            if (bot.patrolPath && bot.patrolPath.length > 0) {
                const target = bot.patrolPath[bot.patrolIndex];
                const dx = target.x - bot.position.x;
                const dz = target.z - bot.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < 2) {
                    bot.patrolIndex = (bot.patrolIndex + 1) % bot.patrolPath.length;
                } else {
                    bot.position.x += (dx / distance) * bot.speed;
                    bot.position.z += (dz / distance) * bot.speed;
                    
                    // Rotate toward movement direction
                    if (botMeshes[index]) {
                        botMeshes[index].rotation.y = Math.atan2(-dx, -dz);
                    }
                }
            }
            
            // Alert decay
            if (bot.alertLevel > 0) {
                bot.alertLevel -= deltaTime * 3;
                if (bot.alertLevel < 0) bot.alertLevel = 0;
            }
            
            // Player detection
            checkGuardDetection(bot, index);
            
            // Update network if alert level changed significantly
            if (bot.alertLevel > 0 && Math.random() < 0.1) {
                sendNetworkMessage('botUpdate', { index, alertLevel: Math.floor(bot.alertLevel) });
            }
        }

        function updateInmateBot(bot, index, deltaTime) {
            const now = Date.now();
            
            // Change activity occasionally
            if (now - bot.lastActivityChange > 10000) {
                bot.lastActivityChange = now;
                bot.activity = gameState.rng.choice(['wandering', 'resting', 'socializing']);
            }
            
            // Activity-based behavior
            switch(bot.activity) {
                case 'wandering':
                    if (Math.random() < 0.02) {
                        bot.position.x += (Math.random() - 0.5) * 3;
                        bot.position.z += (Math.random() - 0.5) * 3;
                        
                        const halfSize = CONFIG.PRISON_SIZE / 2 - 15;
                        bot.position.x = Math.max(-halfSize, Math.min(halfSize, bot.position.x));
                        bot.position.z = Math.max(-halfSize, Math.min(halfSize, bot.position.z));
                    }
                    break;
                    
                case 'resting':
                    // Stay in place, maybe sit down animation
                    break;
            }
        }

        function checkGuardDetection(bot, index) {
            if (!playerMesh || bot.alertLevel > 80) return;
            
            const dx = playerMesh.position.x - bot.position.x;
            const dz = playerMesh.position.z - bot.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance < bot.detectionRange) {
                // Check line of sight
                const hasLineOfSight = checkLineOfSight(bot.position, playerMesh.position);
                
                if (hasLineOfSight) {
                    const detectionChance = (1 - distance/bot.detectionRange) * 0.05;
                    if (Math.random() < detectionChance) {
                        bot.alertLevel += 25;
                        showMessage("üö® Guard spotted you!", 'warning');
                        AudioSystem.play('guardAlert');
                        
                        // Alert nearby guards
                        if (bot.alertLevel > 40) {
                            gameState.bots.forEach((otherBot, otherIndex) => {
                                if (otherBot.type === 'guard' && otherIndex !== index && 
                                    Math.abs(otherBot.position.x - bot.position.x) < 30 &&
                                    Math.abs(otherBot.position.z - bot.position.z) < 30) {
                                    otherBot.alertLevel += 15;
                                }
                            });
                        }
                        
                        sendNetworkMessage('botUpdate', { index, alertLevel: bot.alertLevel });
                    }
                }
            }
            
            // Chase player if alert level is high
            if (bot.alertLevel > 30 && distance < 25) {
                bot.position.x += (dx / distance) * bot.speed * (1 + bot.alertLevel / 100);
                bot.position.z += (dz / distance) * bot.speed * (1 + bot.alertLevel / 100);
                
                if (distance < 3) {
                    playerCaught("Guard apprehended you!");
                }
            }
        }

        function checkLineOfSight(from, to) {
            // Simple line of sight check (could be enhanced with raycasting)
            const dx = to.x - from.x;
            const dz = to.z - from.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            // Check for walls in between (simplified)
            const steps = Math.ceil(distance);
            for (let i = 1; i < steps; i++) {
                const checkX = from.x + (dx / steps) * i;
                const checkZ = from.z + (dz / steps) * i;
                
                // Check if point is near any wall
                for (const wall of wallMeshes) {
                    const wallPos = wall.position;
                    const wallSize = wall.geometry.parameters;
                    if (Math.abs(checkX - wallPos.x) < wallSize.width/2 &&
                        Math.abs(checkZ - wallPos.z) < (wallSize.depth || wallSize.height)/2) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        function playerCaught(reason) {
            const player = gameState.players[gameState.playerId];
            player.health -= 30;
            
            if (player.health <= 0) {
                sendToSolitary(reason);
            } else {
                showMessage(`üí• ${reason} Health: ${player.health}%`, 'error');
                AudioSystem.play('hit');
            }
        }

        function checkCollisions() {
            if (!playerMesh) return;
            
            const player = gameState.players[gameState.playerId];
            
            // Item collection
            itemMeshes.forEach((item, index) => {
                if (item && !item.userData.collected) {
                    const distance = playerMesh.position.distanceTo(item.position);
                    if (distance < 2) {
                        collectItem(item.userData.type, index);
                    }
                }
            });
            
            // Wall collisions
            const halfSize = CONFIG.PRISON_SIZE / 2 - 2;
            if (Math.abs(playerMesh.position.x) > halfSize || 
                Math.abs(playerMesh.position.z) > halfSize) {
                playerMesh.position.x = Math.max(-halfSize, Math.min(halfSize, playerMesh.position.x));
                playerMesh.position.z = Math.max(-halfSize, Math.min(halfSize, playerMesh.position.z));
            }
        }

        function updateCamera() {
            if (!playerMesh) return;
            
            const cameraDistance = 20;
            const cameraHeight = 10;
            const targetX = playerMesh.position.x;
            const targetZ = playerMesh.position.z;
            
            // Smooth camera follow
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.z += (targetZ + cameraDistance - camera.position.z) * 0.1;
            camera.position.y = playerMesh.position.y + cameraHeight;
            
            camera.lookAt(
                playerMesh.position.x,
                playerMesh.position.y + 3,
                playerMesh.position.z
            );
        }

        function updateTimeOfDay(deltaTime) {
            gameState.timeOfDay += deltaTime / CONFIG.DAY_CYCLE;
            if (gameState.timeOfDay >= 1) gameState.timeOfDay = 0;
            
            gameState.isNight = gameState.timeOfDay < 0.25 || gameState.timeOfDay > 0.75;
            
            // Update lighting based on time
            const intensity = gameState.isNight ? 0.3 : 0.8;
            scene.children.forEach(child => {
                if (child.isDirectionalLight && child !== scene.children.find(c => c.isAmbientLight)) {
                    child.intensity = intensity;
                }
            });
        }

        function updatePrisonLights() {
            // This would control prison lights turning on/off
            // For now, just a placeholder
        }

        // ============================================================================
        // ENHANCED GAME MECHANICS
        // ============================================================================
        function collectItem(type, index) {
            const player = gameState.players[gameState.playerId];
            
            if (!player.inventory.includes(type)) {
                player.inventory.push(type);
                player.contraband++;
                
                // Find item details
                const itemType = CONFIG.ITEM_TYPES.find(i => i.id === type);
                
                if (itemMeshes[index]) {
                    // Animate collection
                    itemMeshes[index].scale.set(0.1, 0.1, 0.1);
                    itemMeshes[index].visible = false;
                    itemMeshes[index].userData.collected = true;
                }
                if (gameState.items[index]) {
                    gameState.items[index].collected = true;
                }
                
                sendNetworkMessage('itemCollected', { index, type });
                updateInventoryUI();
                updateEscapeOptions();
                
                // Show collection message with rarity color
                let rarityColor = '#ffffff';
                switch(itemType.rarity) {
                    case 'common': rarityColor = '#ffffff'; break;
                    case 'uncommon': rarityColor = '#00ff00'; break;
                    case 'rare': rarityColor = '#0077ff'; break;
                    case 'epic': rarityColor = '#aa00ff'; break;
                    case 'legendary': rarityColor = '#ffaa00'; break;
                }
                
                showMessage(`‚úÖ Collected: ${itemType.name} (${itemType.rarity.toUpperCase()})!`, 'success');
                AudioSystem.play('collect');
                
                // Special effects for rare items
                if (itemType.rarity === 'epic' || itemType.rarity === 'legendary') {
                    showMessage(`‚ú® ${itemType.name} acquired! This will help your escape!`, 'success');
                }
            }
        }

        function collectItemRemote(data) {
            const { index, type } = data;
            if (itemMeshes[index]) {
                itemMeshes[index].visible = false;
                itemMeshes[index].userData.collected = true;
            }
            
            const itemType = CONFIG.ITEM_TYPES.find(i => i.id === type);
            if (itemType) {
                showMessage(`üì¶ Partner collected: ${itemType.name}`, 'info');
            }
        }

        function updateInventoryUI() {
            const player = gameState.players[gameState.playerId];
            const inventoryDiv = document.getElementById('inventoryItems');
            const countSpan = document.getElementById('inventoryCount');
            
            inventoryDiv.innerHTML = '';
            countSpan.textContent = `(${player.inventory.length}/8)`;
            
            player.inventory.forEach((itemId, index) => {
                const itemType = CONFIG.ITEM_TYPES.find(i => i.id === itemId);
                if (!itemType) return;
                
                const div = document.createElement('div');
                div.className = 'inventory-item';
                div.innerHTML = `
                    <div class="inventory-icon" style="background: ${itemType.color}">
                        ${itemType.icon}
                        <div style="font-size: 10px; margin-top: 2px;">${itemType.rarity.charAt(0).toUpperCase()}</div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">${itemType.name}</div>
                        <div style="font-size: 12px; color: #aaa;">${itemType.rarity.toUpperCase()}</div>
                    </div>
                `;
                inventoryDiv.appendChild(div);
            });
            
            const progress = calculateEscapeProgress();
            document.getElementById('escapeProgress').style.width = `${progress}%`;
        }

        function calculateEscapeProgress() {
            const player = gameState.players[gameState.playerId];
            let progress = 0;
            
            // Items contribute to progress
            player.inventory.forEach(itemId => {
                const item = CONFIG.ITEM_TYPES.find(i => i.id === itemId);
                if (item) {
                    switch(item.rarity) {
                        case 'common': progress += 5; break;
                        case 'uncommon': progress += 10; break;
                        case 'rare': progress += 15; break;
                        case 'epic': progress += 20; break;
                        case 'legendary': progress += 30; break;
                    }
                }
            });
            
            // Reputation contributes
            progress += Math.min(player.reputation, 100);
            
            // Penalty for high alert
            const highAlertBots = gameState.bots.filter(b => b.alertLevel > 50).length;
            progress -= highAlertBots * 10;
            
            return Math.max(0, Math.min(100, progress));
        }

        function updateEscapeOptions() {
            const player = gameState.players[gameState.playerId];
            
            Object.keys(CONFIG.ESCAPE_REQUIREMENTS).forEach(method => {
                const option = document.getElementById('escape' + method.charAt(0).toUpperCase() + method.slice(1));
                if (!option) return;
                
                const requirements = CONFIG.ESCAPE_REQUIREMENTS[method];
                let canEscape = true;
                let missingRequirements = [];
                
                requirements.forEach(req => {
                    if (req.includes('reputation')) {
                        const needed = parseInt(req.split('_')[1]);
                        if (player.reputation < needed) {
                            canEscape = false;
                            missingRequirements.push(`Reputation ${needed}+`);
                        }
                    } else if (req === 'clean_record') {
                        if (player.contraband > 0) {
                            canEscape = false;
                            missingRequirements.push('Clean Record');
                        }
                    } else {
                        if (!player.inventory.includes(req)) {
                            canEscape = false;
                            const item = CONFIG.ITEM_TYPES.find(i => i.id === req);
                            missingRequirements.push(item ? item.name : req);
                        }
                    }
                });
                
                if (canEscape) {
                    option.classList.add('ready');
                    option.classList.remove('disabled');
                    option.title = 'Ready to escape!';
                } else {
                    option.classList.remove('ready');
                    option.classList.add('disabled');
                    option.title = `Missing: ${missingRequirements.join(', ')}`;
                }
            });
        }

        // ============================================================================
        // ENHANCED ESCAPE MECHANICS
        // ============================================================================
        function toggleEscapeMenu() {
            AudioSystem.play('button');
            const menu = document.getElementById('escapeMenu');
            menu.style.display = menu.style.display === 'grid' ? 'none' : 'grid';
            
            if (menu.style.display === 'grid') {
                updateEscapeOptions();
            }
        }

        function startEscape(method) {
            const option = document.getElementById('escape' + method.charAt(0).toUpperCase() + method.slice(1));
            if (option.classList.contains('disabled')) {
                showMessage("You don't meet the requirements for this escape method!", 'warning');
                return;
            }
            
            AudioSystem.play('escapeStart');
            toggleEscapeMenu();
            showMessage(`üöÄ Starting ${method} escape sequence... Coordinate with partner!`, 'info');
            
            gameState.escapeInProgress = true;
            
            sendNetworkMessage('escapeAttempt', {
                method: method,
                playerId: gameState.playerId,
                timestamp: Date.now(),
                requirements: CONFIG.ESCAPE_REQUIREMENTS[method]
            });
            
            // Show escape sequence
            setTimeout(() => {
                const success = attemptEscape(method);
                
                if (success) {
                    escapeSuccess(method);
                } else {
                    escapeFailure(method);
                }
            }, 4000);
        }

        function attemptEscape(method) {
            const player = gameState.players[gameState.playerId];
            let successChance = 0.5;
            
            // Base chances
            switch(method) {
                case 'tunnel': 
                    successChance = 0.65;
                    if (player.inventory.includes('map')) successChance += 0.15;
                    break;
                case 'disguise': 
                    successChance = 0.75;
                    if (player.reputation > 30) successChance += 0.10;
                    break;
                case 'riot': 
                    successChance = 0.55 + (player.reputation / 200);
                    break;
                case 'parole': 
                    successChance = 0.8 - (player.contraband * 0.05);
                    break;
            }
            
            // Partner coordination bonus
            if (Object.keys(gameState.players).length > 1) {
                successChance += 0.15;
            }
            
            // Night time bonus
            if (gameState.isNight) {
                successChance += 0.10;
            }
            
            // Health penalty
            if (player.health < 50) {
                successChance -= 0.20;
            }
            
            return Math.random() < Math.min(0.95, Math.max(0.05, successChance));
        }

        function escapeSuccess(method) {
            AudioSystem.play('success');
            
            const successMessages = {
                tunnel: [
                    "You emerged into freedom! The tunnel was a success!",
                    "Dirty but free! The tunnel led you to safety!",
                    "After hours of digging, you taste fresh air again!"
                ],
                disguise: [
                    "The guards saluted as you walked out! Perfect disguise!",
                    "Security never suspected a thing! Welcome to freedom!",
                    "You blended right in! The uniform was a perfect fit!"
                ],
                riot: [
                    "Chaos was the perfect cover! You slipped away unnoticed!",
                    "While guards handled the riot, you made your escape!",
                    "The riot provided the distraction you needed!"
                ],
                parole: [
                    "Paperwork processed! You're officially a free citizen!",
                    "Legal loopholes worked in your favor! Freedom achieved!",
                    "The warden signed your release! Congratulations!"
                ]
            };
            
            const messages = successMessages[method] || ["Escape successful! You're free!"];
            const message = messages[Math.floor(Math.random() * messages.length)];
            
            const timeEscaped = formatTime(gameState.gameTime);
            alert(`üéâ ESCAPE SUCCESSFUL! üéâ\n\nMethod: ${method.toUpperCase()}\nTime: ${timeEscaped}\n\n${message}\n\nRefresh to play again.`);
            
            sendNetworkMessage('gameOver', { 
                success: true, 
                method: method,
                time: gameState.gameTime,
                message: message
            });
        }

        function escapeFailure(method) {
            AudioSystem.play('failure');
            
            const failureMessages = {
                tunnel: "The tunnel collapsed! Guards found you buried in dirt.",
                disguise: "The ID card scanner flagged you as an impostor!",
                riot: "Nobody showed up to your riot! You stood alone.",
                parole: "The warden laughed and tore up your paperwork."
            };
            
            const reason = failureMessages[method] || "Escape attempt failed!";
            sendToSolitary(`${reason} ${method} escape failed.`);
            sendNetworkMessage('gameOver', { success: false, method: method, reason: reason });
        }

        function handleEscapeAttempt(data) {
            const { method, playerId } = data;
            showMessage(`üö® Partner attempting ${method} escape...`, 'info');
            
            // If both players attempt same method, increase success chance
            if (gameState.escapeInProgress && gameState.escapeMethod === method) {
                showMessage("‚úÖ Both partners coordinating escape! Success chance increased!", "success");
            }
        }

        // ============================================================================
        // ENHANCED FAILURE SYSTEM
        // ============================================================================
        function sendToSolitary(reason) {
            gameState.gameStarted = false;
            AudioSystem.stopMusic();
            
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('solitaryScreen').style.display = 'flex';
            
            document.getElementById('failReason').textContent = reason;
            
            // Random funny message
            const funnyMessages = [
                "The guards are enjoying donuts while you contemplate your life choices...",
                "At least the rats are good company! They don't judge... much.",
                "Solitary: where dreams go to nap and escape plans go to die.",
                "You had time to think about your life choices... still a bad idea!",
                "The warden sends his regards... and a bill for damages.",
                "Even the cockroaches are judging your escape attempt.",
                "Welcome to your new 'quiet time' vacation package!",
                "The only thing escaping now is your sanity!",
                "At least you have a nice view... of four concrete walls.",
                "They say prison builds character. You must be a novel by now!"
            ];
            
            const funnyMessage = funnyMessages[Math.floor(Math.random() * funnyMessages.length)];
            document.getElementById('funnyMessage').textContent = funnyMessage;
            
            // Random escape hint
            const hint = CONFIG.ESCAPE_HINTS[Math.floor(Math.random() * CONFIG.ESCAPE_HINTS.length)];
            document.getElementById('escapeHint').textContent = `üí° ${hint}`;
            
            animateSolitaryScene();
            
            if (gameState.connectionEstablished) {
                sendNetworkMessage('gameOver', { 
                    success: false, 
                    reason: reason,
                    message: funnyMessage
                });
            }
        }

        function animateSolitaryScene() {
            const animationDiv = document.getElementById('solitaryAnimation');
            animationDiv.innerHTML = '';
            
            // Create solitary cell
            const cell = document.createElement('div');
            cell.style.cssText = `
                width: 100%;
                height: 100%;
                position: relative;
                background: linear-gradient(135deg, #111 0%, #222 100%);
                overflow: hidden;
            `;
            animationDiv.appendChild(cell);
            
            // Add cell bars
            for (let i = 0; i < 10; i++) {
                const bar = document.createElement('div');
                bar.style.cssText = `
                    position: absolute;
                    width: 10px;
                    height: 200px;
                    background: linear-gradient(to bottom, #666 0%, #333 100%);
                    top: 50px;
                    left: ${20 + i * 30}px;
                    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
                `;
                cell.appendChild(bar);
            }
            
            // Add inmate (player)
            const inmate = document.createElement('div');
            inmate.style.cssText = `
                position: absolute;
                width: 30px;
                height: 50px;
                background: linear-gradient(to bottom, #ff0066 0%, #990033 100%);
                border-radius: 15px 15px 5px 5px;
                bottom: 20px;
                left: 150px;
                animation: inmate-bounce 2s infinite;
                box-shadow: 0 0 20px rgba(255, 0, 102, 0.5);
            `;
            cell.appendChild(inmate);
            
            // Add guard patrol
            const guard = document.createElement('div');
            guard.style.cssText = `
                position: absolute;
                width: 40px;
                height: 60px;
                background: linear-gradient(to bottom, #0000ff 0%, #000088 100%);
                border-radius: 20px 20px 5px 5px;
                bottom: 20px;
                left: -50px;
                animation: guard-patrol 4s linear infinite;
                box-shadow: 0 0 20px rgba(0, 0, 255, 0.5);
            `;
            cell.appendChild(guard);
            
            // Add styles for animations
            const style = document.createElement('style');
            style.textContent = `
                @keyframes inmate-bounce {
                    0%, 100% { transform: translateY(0); }
                    50% { transform: translateY(-10px); }
                }
                @keyframes guard-patrol {
                    0% { left: -50px; }
                    100% { left: 350px; }
                }
            `;
            animationDiv.appendChild(style);
        }

        function handleGameOver(data) {
            if (data.success) {
                showMessage(`üéâ Partner escaped via ${data.method}! Time: ${formatTime(data.time)}`, 'success');
                AudioSystem.play('success');
            } else {
                showMessage(`üíÄ Partner got caught: ${data.reason || 'Escape failed'}`, 'warning');
                AudioSystem.play('failure');
            }
        }

        // ============================================================================
        // ENHANCED UI FUNCTIONS
        // ============================================================================
        function updatePlayerUI(playerNum, player) {
            const num = playerNum === 1 ? '1' : '2';
            const elements = {
                health: document.getElementById(`health${num}`),
                healthBar: document.getElementById(`healthBar${num}`),
                contraband: document.getElementById(`contraband${num}`),
                reputation: document.getElementById(`rep${num}`),
                position: document.getElementById(`pos${num}`),
                status: document.getElementById(`status${num}`)
            };
            
            if (elements.health) elements.health.textContent = Math.floor(player.health);
            if (elements.healthBar) elements.healthBar.style.width = `${Math.max(0, player.health)}%`;
            if (elements.contraband) elements.contraband.textContent = player.contraband;
            if (elements.reputation) elements.reputation.textContent = Math.floor(player.reputation);
            if (elements.status) elements.status.textContent = player.status;
            
            // Update position display
            if (elements.position && player.position) {
                let area = 'Unknown';
                const x = player.position.x;
                const z = player.position.z;
                
                if (x < -50) area = 'West Wing';
                else if (x > 50) area = 'East Wing';
                else if (z < -50) area = 'South Block';
                else if (z > 50) area = 'North Block';
                else area = 'Central Yard';
                
                elements.position.textContent = area;
            }
        }

        function showMessage(text, type = 'info') {
            const messageDiv = document.getElementById('messageDisplay');
            if (!messageDiv) return;
            
            messageDiv.textContent = text;
            messageDiv.style.display = 'block';
            
            // Set color based on type
            const colors = {
                info: '#00ccff',
                success: '#00ff88',
                warning: '#ffcc00',
                error: '#ff0066'
            };
            
            messageDiv.style.borderColor = colors[type] || colors.info;
            messageDiv.style.color = colors[type] || colors.info;
            messageDiv.style.boxShadow = `0 0 30px ${colors[type] || colors.info}`;
            
            // Auto-hide after delay
            clearTimeout(messageDiv.hideTimeout);
            messageDiv.hideTimeout = setTimeout(() => {
                messageDiv.style.display = 'none';
            }, type === 'error' ? 5000 : 3000);
        }

        function hideObjective() {
            AudioSystem.play('button');
            const objective = document.getElementById('objective');
            if (objective) {
                objective.style.display = 'none';
            }
        }

        function togglePause() {
            AudioSystem.play('button');
            gameState.isPaused = !gameState.isPaused;
            document.getElementById('pauseMenu').style.display = gameState.isPaused ? 'block' : 'none';
            
            if (gameState.isPaused) {
                showMessage("Game Paused", "info");
            }
        }

        function returnToLobby() {
            AudioSystem.play('button');
            
            // Clean up network
            if (gameState.peer) {
                gameState.peer.close();
            }
            if (gameState.connectionCheckInterval) {
                clearInterval(gameState.connectionCheckInterval);
            }
            if (gameState.pingInterval) {
                clearInterval(gameState.pingInterval);
            }
            
            // Clean up Three.js
            if (scene) {
                while(scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
            }
            if (renderer) {
                renderer.dispose();
            }
            
            // Reset game state
            gameState.gameStarted = false;
            gameState.escapeInProgress = false;
            gameState.connectionEstablished = false;
            gameState.players = {};
            
            // Show lobby
            document.getElementById('solitaryScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'flex';
            
            resetLobbyButtons();
            updateConnectionStatus('disconnected', 'Ready to escape');
            AudioSystem.startMusic();
        }

        function resetLobbyButtons() {
            document.getElementById('hostBtn').disabled = false;
            document.getElementById('joinBtn').disabled = false;
            document.getElementById('tutorialBtn').disabled = false;
            document.getElementById('joinSection').style.display = 'none';
            document.getElementById('roomInfo').style.display = 'none';
            document.getElementById('tutorialSection').style.display = 'none';
        }

        function retryGame() {
            AudioSystem.play('button');
            
            // Clean up current game
            if (scene) {
                while(scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
            }
            
            gameState.gameStarted = false;
            gameState.escapeInProgress = false;
            gameState.gameTime = 0;
            
            // Generate new prison with new seed
            gameState.prisonSeed = Date.now() + Math.floor(Math.random() * 10000);
            gameState.rng = new EnhancedRandom(gameState.prisonSeed);
            
            // Reset player
            const player = gameState.players[gameState.playerId];
            if (player) {
                player.health = 100;
                player.contraband = 0;
                player.reputation = 0;
                player.inventory = [];
                player.status = 'Retrying...';
            }
            
            // Reset Three.js objects
            playerMesh = null;
            otherPlayerMesh = null;
            botMeshes = [];
            itemMeshes = [];
            wallMeshes = [];
            cellMeshes = [];
            
            // Switch screens
            document.getElementById('solitaryScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            
            // Start new game
            setTimeout(() => {
                try {
                    initThreeJS();
                    generatePrison(gameState.prisonSeed);
                    createPlayer(gameState.playerId, true);
                    
                    gameState.gameStarted = true;
                    animate();
                    
                    showMessage("üîÑ New escape attempt initiated! Good luck!", 'success');
                    AudioSystem.startMusic();
                    
                } catch (e) {
                    console.error('Error in retry:', e);
                    showMessage("Error restarting game", 'error');
                    returnToLobby();
                }
            }, 500);
        }

        // ============================================================================
        // INPUT HANDLING - ENHANCED
        // ============================================================================
        function setupEventListeners() {
            // Keyboard input
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                
                if (key === 'shift') isRunning = true;
                
                // Handle special keys
                switch(key) {
                    case 'e':
                        if (!gameState.escapeInProgress) attemptInteraction();
                        break;
                    case 'f':
                        if (!gameState.escapeInProgress) attemptFight();
                        break;
                    case 'tab':
                        toggleInventory();
                        e.preventDefault();
                        break;
                    case 'c':
                        toggleChat();
                        e.preventDefault();
                        break;
                    case 'm':
                        if (!gameState.escapeInProgress) toggleEscapeMenu();
                        e.preventDefault();
                        break;
                    case 'enter':
                        if (document.getElementById('chat').style.display === 'block') {
                            sendChatMessage();
                            e.preventDefault();
                        }
                        break;
                    case 'escape':
                        if (document.getElementById('chat').style.display === 'block') {
                            toggleChat();
                        } else if (document.getElementById('escapeMenu').style.display === 'grid') {
                            toggleEscapeMenu();
                        } else if (document.getElementById('inventory').style.display === 'block') {
                            toggleInventory();
                        } else if (gameState.gameStarted) {
                            togglePause();
                        }
                        e.preventDefault();
                        break;
                }
            });
            
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = false;
                
                if (key === 'shift') isRunning = false;
            });
            
            // Mouse input
            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
            
            // Prevent context menu
            window.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function mobileKeyDown(key) {
            keys[key] = true;
            if (key === 'e') attemptInteraction();
            if (key === 'f') attemptFight();
            if (key === ' ') {
                playerMesh.position.y += 0.25;
                AudioSystem.play('collect');
            }
        }

        function mobileKeyUp(key) {
            keys[key] = false;
        }

        // ============================================================================
        // ENHANCED INTERACTION FUNCTIONS
        // ============================================================================
        function attemptInteraction() {
            const player = gameState.players[gameState.playerId];
            
            // Item interaction
            itemMeshes.forEach((item, index) => {
                if (item && !item.userData.collected && playerMesh) {
                    const distance = playerMesh.position.distanceTo(item.position);
                    if (distance < 3) {
                        collectItem(item.userData.type, index);
                    }
                }
            });
            
            // Bot interaction
            gameState.bots.forEach((bot, index) => {
                if (playerMesh && bot.position) {
                    const dx = playerMesh.position.x - bot.position.x;
                    const dz = playerMesh.position.z - bot.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 4) {
                        if (bot.type === 'guard') {
                            interactWithGuard(bot, player);
                        } else if (bot.type === 'inmate') {
                            interactWithInmate(bot, player);
                        }
                    }
                }
            });
        }

        function interactWithGuard(bot, player) {
            if (player.inventory.includes('donut')) {
                player.reputation += 15;
                player.inventory = player.inventory.filter(i => i !== 'donut');
                bot.alertLevel = Math.max(0, bot.alertLevel - 40);
                updateInventoryUI();
                showMessage('üç© Guard bribed with donut! Reputation +15, Alert -40', 'success');
                AudioSystem.play('collect');
            } else if (player.inventory.includes('cigarettes')) {
                player.reputation += 10;
                player.inventory = player.inventory.filter(i => i !== 'cigarettes');
                updateInventoryUI();
                showMessage('üö¨ Guard appreciated the cigarettes! Reputation +10', 'success');
                AudioSystem.play('collect');
            } else {
                showMessage('üöì Guard: "Move along, inmate!"', 'warning');
            }
        }

        function interactWithInmate(bot, player) {
            const messages = {
                lazy: "Zzz... come back later...",
                violent: "What you lookin' at?! Got a problem?!",
                helpful: "Need something? I might know where to find useful items...",
                snitch: "I don't talk to troublemakers. Guards! Guards!"
            };
            
            showMessage(`üë§ Inmate: "${messages[bot.personality]}"`, 'info');
            
            if (bot.personality === 'helpful') {
                if (player.contraband > 0) {
                    const tips = CONFIG.ESCAPE_HINTS;
                    const tip = tips[Math.floor(Math.random() * tips.length)];
                    showMessage(`üí° Inmate tip: ${tip}`, 'success');
                    player.reputation += 10;
                    updatePlayerUI(1, player);
                } else {
                    showMessage('üí° Inmate: "Get some contraband first, then we talk."', 'info');
                }
            } else if (bot.personality === 'snitch' && Math.random() < 0.3) {
                // Snitch alerts guards
                gameState.bots.forEach(b => {
                    if (b.type === 'guard') {
                        b.alertLevel += 20;
                    }
                });
                showMessage('üö® Inmate alerted the guards!', 'error');
            }
        }

        function attemptFight() {
            const player = gameState.players[gameState.playerId];
            
            gameState.bots.forEach((bot, index) => {
                if (bot.type === 'guard' && playerMesh) {
                    const dx = playerMesh.position.x - bot.position.x;
                    const dz = playerMesh.position.z - bot.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 3) {
                        const successChance = player.inventory.includes('crowbar') ? 0.7 : 0.4;
                        const success = Math.random() < successChance;
                        
                        if (success) {
                            showMessage('ü•ä Guard knocked out! (Temporarily)', 'success');
                            bot.alertLevel = 100;
                            player.reputation += 10;
                            AudioSystem.play('hit');
                        } else {
                            showMessage('üí• Fight failed! Guard fought back! Health -25', 'error');
                            player.health -= 25;
                            AudioSystem.play('hit');
                            if (player.health <= 0) {
                                sendToSolitary('Lost a fight with a guard');
                            }
                        }
                        
                        sendNetworkMessage('botUpdate', { index, alertLevel: bot.alertLevel });
                        updatePlayerUI(1, player);
                    }
                }
            });
        }

        // ============================================================================
        // ENHANCED CHAT SYSTEM
        // ============================================================================
        function toggleChat() {
            AudioSystem.play('chat');
            const chat = document.getElementById('chat');
            if (chat.style.display === 'block') {
                chat.style.display = 'none';
            } else {
                chat.style.display = 'flex';
                document.getElementById('chatInput').focus();
            }
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (message && gameState.connectionEstablished) {
                displayChatMessage('You', message, true, 'normal');
                sendNetworkMessage('chat', { text: message, type: 'normal' });
                input.value = '';
                AudioSystem.play('chat');
            }
        }

        function displayChatMessage(sender, message, isLocal, type = 'normal') {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isLocal ? 'you' : 'partner'}`;
            
            let displayMessage = message;
            if (type === 'system') {
                displayMessage = `‚ö° ${message}`;
            } else if (type === 'alert') {
                displayMessage = `üö® ${message}`;
            }
            
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${displayMessage}`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Auto-close chat after system messages
            if (type === 'system' || type === 'alert') {
                setTimeout(() => {
                    if (chatMessages.children.length > 10) {
                        chatMessages.removeChild(chatMessages.firstChild);
                    }
                }, 5000);
            }
        }

        function toggleInventory() {
            AudioSystem.play('button');
            const inventory = document.getElementById('inventory');
            if (inventory.style.display === 'block') {
                inventory.style.display = 'none';
            } else {
                inventory.style.display = 'block';
                updateInventoryUI();
            }
        }

        // ============================================================================
        // UTILITY FUNCTIONS - ENHANCED
        // ============================================================================
        function generateSecureId() {
            return Array.from(crypto.getRandomValues(new Uint8Array(16)))
                .map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function updateGameTimer() {
            setInterval(() => {
                if (gameState.gameStarted && !gameState.isPaused) {
                    gameState.gameTime += 1;
                    document.getElementById('gameTimer').textContent = formatTime(gameState.gameTime);
                }
            }, 1000);
        }

        function toggleAudio() {
            const enabled = AudioSystem.toggle();
            showMessage(enabled ? "Sound enabled üîä" : "Sound disabled üîá", "info");
        }

        // ============================================================================
        // ERROR HANDLING & CLEANUP
        // ============================================================================
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            showMessage(`System Error: ${event.message}`, 'error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            showMessage('Network error occurred. Please refresh.', 'error');
        });

        window.addEventListener('beforeunload', () => {
            // Clean up everything
            if (gameState.peer) {
                gameState.peer.close();
            }
            if (gameState.connectionCheckInterval) {
                clearInterval(gameState.connectionCheckInterval);
            }
            if (gameState.pingInterval) {
                clearInterval(gameState.pingInterval);
            }
            if (renderer) {
                renderer.dispose();
            }
            
            // Clear localStorage
            localStorage.removeItem('cbz_hostOffer');
            localStorage.removeItem('cbz_iceCandidates');
            localStorage.removeItem('cbz_roomInfo');
            localStorage.removeItem('cbz_playerAnswer');
            localStorage.removeItem('cbz_playerIceCandidates');
            
            AudioSystem.stopMusic();
        });

        console.log('‚úÖ Cell Block Zero - Enhanced Edition Ready!');
        console.log('üîß Features:');
        console.log('   ‚Ä¢ Enhanced P2P networking with STUN/TURN servers');
        console.log('   ‚Ä¢ 4-digit room codes with copy functionality');
        console.log('   ‚Ä¢ Improved connection reliability');
        console.log('   ‚Ä¢ Enhanced visuals with Three.js');
        console.log('   ‚Ä¢ Audio system with sound effects');
        console.log('   ‚Ä¢ Mobile controls support');
        console.log('   ‚Ä¢ Particle background effects');
        console.log('   ‚Ä¢ Game timer and progress tracking');
        console.log('   ‚Ä¢ Multiple escape methods with requirements');
        console.log('   ‚Ä¢ Guard AI with patrol patterns and detection');
        console.log('   ‚Ä¢ Inventory system with item rarities');
        console.log('   ‚Ä¢ Chat system for coordination');
        console.log('   ‚Ä¢ Solitary confinement with animations');
        console.log('   ‚Ä¢ Pause menu and audio controls');
    </script>
</body>
</html>
