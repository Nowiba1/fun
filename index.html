<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Riders: Delivery Chaos - NEXT LEVEL</title>
    <!-- Babylon.js Core -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <!-- Havok Physics -->
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_es.js"></script>
    <!-- Post-processing effects -->
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            overflow: hidden;
            background: #0a0a14;
            color: #fff;
        }
        
        #renderCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            outline: none;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .hud-container {
            position: absolute;
            top: 25px;
            left: 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .hud-panel {
            background: linear-gradient(135deg, rgba(20, 20, 30, 0.85), rgba(40, 40, 60, 0.85));
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ff6b00;
            box-shadow: 0 8px 32px rgba(255, 107, 0, 0.2);
            backdrop-filter: blur(10px);
            min-width: 280px;
            transition: all 0.3s ease;
        }
        
        .hud-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(255, 107, 0, 0.3);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 12px 0;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-label {
            color: #a0a0c0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            color: #ff6b00;
            font-size: 22px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(255, 107, 0, 0.5);
        }
        
        .stat-unit {
            color: #ffb866;
            font-size: 12px;
            margin-left: 4px;
        }
        
        #productsPanel {
            border-color: #00ff88;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.2);
        }
        
        #productsPanel:hover {
            box-shadow: 0 12px 40px rgba(0, 255, 136, 0.3);
        }
        
        .products-display {
            text-align: center;
            padding: 20px;
        }
        
        .products-count {
            font-size: 56px;
            font-weight: 900;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
            margin: 10px 0;
        }
        
        .products-label {
            color: #a0ffd0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .speedometer {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 180px;
            height: 180px;
        }
        
        .speed-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(20, 20, 30, 0.9), rgba(10, 10, 20, 0.95));
            border: 4px solid #ff6b00;
            box-shadow: 0 0 40px rgba(255, 107, 0, 0.4);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .speed-value {
            font-size: 42px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }
        
        .speed-label {
            color: #ffb866;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 5px;
        }
        
        .bot-indicator {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 50, 50, 0.9), rgba(180, 0, 0, 0.9));
            padding: 15px 30px;
            border-radius: 25px;
            border: 2px solid #ff3333;
            box-shadow: 0 0 30px rgba(255, 50, 50, 0.6);
            display: flex;
            align-items: center;
            gap: 15px;
            backdrop-filter: blur(10px);
        }
        
        .bot-icon {
            font-size: 24px;
            animation: pulse 2s infinite;
        }
        
        .bot-count {
            font-size: 28px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .controls-panel {
            position: absolute;
            bottom: 40px;
            left: 40px;
            background: rgba(20, 20, 30, 0.8);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #444466;
            max-width: 320px;
            backdrop-filter: blur(10px);
        }
        
        .controls-title {
            color: #ff6b00;
            font-size: 18px;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-key {
            background: linear-gradient(135deg, #333355, #222244);
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid #555588;
            color: #fff;
            font-weight: 600;
            min-width: 100px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(10, 10, 20, 0.95), rgba(5, 5, 15, 0.98));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: all;
        }
        
        .screen-title {
            font-size: 64px;
            font-weight: 900;
            color: #ff6b00;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 0 0 30px rgba(255, 107, 0, 0.8);
            background: linear-gradient(45deg, #ff6b00, #ffa500);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .screen-subtitle {
            font-size: 24px;
            color: #a0a0c0;
            margin-bottom: 50px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
        }
        
        .button-container {
            display: flex;
            gap: 25px;
            margin-top: 30px;
        }
        
        .game-button {
            background: linear-gradient(135deg, #ff6b00, #ff8533);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(255, 107, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .game-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(255, 107, 0, 0.6);
        }
        
        .game-button:active {
            transform: translateY(-2px);
        }
        
        .secondary-button {
            background: linear-gradient(135deg, #333355, #444477);
            box-shadow: 0 8px 25px rgba(51, 51, 85, 0.4);
        }
        
        .secondary-button:hover {
            box-shadow: 0 15px 35px rgba(51, 51, 85, 0.6);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin: 40px 0;
            background: rgba(30, 30, 45, 0.7);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #444466;
        }
        
        .stat-card {
            text-align: center;
            padding: 20px;
            background: rgba(40, 40, 60, 0.8);
            border-radius: 10px;
            border: 1px solid #555588;
        }
        
        .stat-card-value {
            font-size: 36px;
            font-weight: 900;
            color: #ff6b00;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 107, 0, 0.5);
        }
        
        .hidden {
            display: none !important;
        }
        
        #loadingScreen {
            z-index: 300;
        }
        
        .loading-bar-container {
            width: 400px;
            height: 12px;
            background: rgba(40, 40, 60, 0.8);
            border-radius: 6px;
            overflow: hidden;
            margin: 40px 0;
            border: 1px solid #555588;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b00, #ffa500);
            width: 0%;
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.7);
        }
        
        .loading-text {
            color: #a0a0c0;
            font-size: 16px;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .road-line {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, transparent, #ffff00, transparent);
            animation: roadFlow 1s linear infinite;
        }
        
        @keyframes roadFlow {
            0% { background-position: -200px 0; }
            100% { background-position: 200px 0; }
        }
        
        #boostBar {
            position: absolute;
            top: 25px;
            right: 25px;
            width: 200px;
            height: 15px;
            background: rgba(40, 40, 60, 0.8);
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #ff6b00;
        }
        
        #boostFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ff88, #00ffcc);
            border-radius: 6px;
            transition: width 0.2s ease;
        }
        
        .boost-label {
            position: absolute;
            top: -25px;
            right: 0;
            color: #00ff88;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .collision-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: #ff3333;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 40px rgba(255, 50, 50, 0.8);
        }
        
        .lane-indicator {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        .lane-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .lane-dot.active {
            background: #ff6b00;
            border-color: #ffa500;
            box-shadow: 0 0 15px rgba(255, 107, 0, 0.8);
            transform: scale(1.3);
        }
    </style>
</head>
<body>
    <!-- Babylon.js Canvas -->
    <canvas id="renderCanvas"></canvas>
    
    <!-- Game UI -->
    <div id="ui">
        <!-- Left HUD Panel -->
        <div class="hud-container">
            <div class="hud-panel" id="statsPanel">
                <div class="stat-row">
                    <span class="stat-label">Score</span>
                    <span class="stat-value" id="scoreValue">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Distance</span>
                    <span class="stat-value" id="distanceValue">0<span class="stat-unit">m</span></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Time</span>
                    <span class="stat-value" id="timeValue">00:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Active Bots</span>
                    <span class="stat-value" id="botCountValue">0</span>
                </div>
            </div>
            
            <div class="hud-panel" id="productsPanel">
                <div class="products-display">
                    <div class="products-count" id="productsValue">10</div>
                    <div class="products-label">Products Remaining</div>
                </div>
            </div>
        </div>
        
        <!-- Speedometer -->
        <div class="speedometer">
            <div class="speed-circle">
                <div class="speed-value" id="speedValue">0</div>
                <div class="speed-label">km/h</div>
            </div>
        </div>
        
        <!-- Bot Indicator -->
        <div class="bot-indicator" id="botIndicator">
            <span class="bot-icon">ü§ñ</span>
            <span class="bot-count" id="botCount">0</span>
            <span>Bots Chasing</span>
        </div>
        
        <!-- Boost Bar -->
        <div id="boostBar">
            <div class="boost-label">Boost</div>
            <div id="boostFill"></div>
        </div>
        
        <!-- Lane Indicator -->
        <div class="lane-indicator">
            <div class="lane-dot" id="laneLeft"></div>
            <div class="lane-dot" id="laneCenter"></div>
            <div class="lane-dot" id="laneRight"></div>
        </div>
        
        <!-- Controls Panel -->
        <div class="controls-panel">
            <div class="controls-title">Controls</div>
            <div class="control-item">
                <span>Accelerate</span>
                <span class="control-key">W / ‚Üë</span>
            </div>
            <div class="control-item">
                <span>Brake/Reverse</span>
                <span class="control-key">S / ‚Üì</span>
            </div>
            <div class="control-item">
                <span>Move Left</span>
                <span class="control-key">A / ‚Üê</span>
            </div>
            <div class="control-item">
                <span>Move Right</span>
                <span class="control-key">D / ‚Üí</span>
            </div>
            <div class="control-item">
                <span>Boost</span>
                <span class="control-key">SPACE</span>
            </div>
            <div class="control-item">
                <span>Pause</span>
                <span class="control-key">ESC / P</span>
            </div>
        </div>
        
        <!-- Collision Warning -->
        <div class="collision-warning" id="collisionWarning">‚ö†</div>
    </div>
    
    <!-- Loading Screen -->
    <div id="loadingScreen" class="screen-overlay">
        <h1 class="screen-title">CART RIDERS</h1>
        <h2 class="screen-subtitle">Delivery Chaos - Next Level Edition</h2>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing Advanced Engine...</div>
    </div>
    
    <!-- Pause Screen -->
    <div id="pauseScreen" class="screen-overlay hidden">
        <h1 class="screen-title">GAME PAUSED</h1>
        <h2 class="screen-subtitle">Delivery chaos is temporarily suspended. Ready to continue?</h2>
        <div class="button-container">
            <button id="resumeButton" class="game-button">Resume Delivery</button>
            <button id="restartButton" class="game-button secondary-button">Restart Run</button>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen-overlay hidden">
        <h1 class="screen-title">DELIVERY FAILED!</h1>
        <h2 class="screen-subtitle">All products destroyed. The bots have won this round.</h2>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-card-value" id="finalScore">0</div>
                <div class="stat-label">Final Score</div>
            </div>
            <div class="stat-card">
                <div class="stat-card-value" id="finalDistance">0m</div>
                <div class="stat-label">Distance Traveled</div>
            </div>
            <div class="stat-card">
                <div class="stat-card-value" id="finalTime">00:00</div>
                <div class="stat-label">Survival Time</div>
            </div>
            <div class="stat-card">
                <div class="stat-card-value" id="finalBots">0</div>
                <div class="stat-label">Bots Defeated</div>
            </div>
        </div>
        
        <div class="button-container">
            <button id="playAgainButton" class="game-button">Make Another Delivery</button>
        </div>
    </div>

    <script>
        // Game Constants
        const GAME_CONFIG = {
            ROAD: {
                WIDTH: 15,
                LANE_WIDTH: 5,
                SEGMENT_LENGTH: 40,
                VISIBLE_SEGMENTS: 60,
                CURVE_INTENSITY: 0.4,
                HILL_INTENSITY: 8,
                BANK_INTENSITY: 0.3
            },
            PLAYER: {
                START_LANE: 1, // 0: left, 1: center, 2: right
                START_PRODUCTS: 10,
                BASE_SPEED: 40,
                MAX_SPEED: 120,
                ACCELERATION: 1.2,
                DECELERATION: 0.8,
                BOOST_MULTIPLIER: 1.8,
                BOOST_CAPACITY: 100,
                BOOST_DRAIN_RATE: 25,
                BOOST_RECHARGE_RATE: 15,
                LANE_CHANGE_SPEED: 0.2
            },
            AI: {
                SPAWN_SCORE_INTERVAL: 750,
                MIN_SPEED: 25,
                MAX_SPEED: 80,
                AGGRESSION_LEVELS: [0.3, 0.6, 0.9],
                MISTAKE_PROBABILITY: 0.02,
                REACTION_TIME: 0.5
            },
            WORLD: {
                BUILDING_SPACING: 30,
                MAX_BUILDINGS: 50,
                FOG_DENSITY: 0.1,
                VIEW_DISTANCE: 800
            },
            PHYSICS: {
                GRAVITY: -9.81,
                COLLISION_FORCE: 2.5,
                BOUNCE_FACTOR: 0.3
            }
        };

        // Game State
        let gameState = 'LOADING';
        let gameTime = 0;
        let score = 0;
        let distance = 0;
        let activeBots = 0;
        let nextBotScore = GAME_CONFIG.AI.SPAWN_SCORE_INTERVAL;
        
        // Babylon.js Variables
        let engine, scene, camera, canvas;
        let player, roadManager, buildingManager, botManager, uiManager;
        let havokInstance, physicsPlugin;
        
        // Input State
        const input = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            boost: false,
            lane: GAME_CONFIG.PLAYER.START_LANE,
            targetLane: GAME_CONFIG.PLAYER.START_LANE
        };

        // DOM Elements
        const dom = {
            loadingScreen: document.getElementById('loadingScreen'),
            loadingBar: document.getElementById('loadingBar'),
            loadingText: document.getElementById('loadingText'),
            pauseScreen: document.getElementById('pauseScreen'),
            gameOverScreen: document.getElementById('gameOverScreen'),
            scoreValue: document.getElementById('scoreValue'),
            distanceValue: document.getElementById('distanceValue'),
            timeValue: document.getElementById('timeValue'),
            botCountValue: document.getElementById('botCountValue'),
            productsValue: document.getElementById('productsValue'),
            speedValue: document.getElementById('speedValue'),
            botIndicator: document.getElementById('botIndicator'),
            botCount: document.getElementById('botCount'),
            boostFill: document.getElementById('boostFill'),
            collisionWarning: document.getElementById('collisionWarning'),
            laneLeft: document.getElementById('laneLeft'),
            laneCenter: document.getElementById('laneCenter'),
            laneRight: document.getElementById('laneRight'),
            resumeButton: document.getElementById('resumeButton'),
            restartButton: document.getElementById('restartButton'),
            playAgainButton: document.getElementById('playAgainButton'),
            finalScore: document.getElementById('finalScore'),
            finalDistance: document.getElementById('finalDistance'),
            finalTime: document.getElementById('finalTime'),
            finalBots: document.getElementById('finalBots')
        };

        // Initialize the Game
        async function initGame() {
            updateLoadingProgress(10, 'Initializing Babylon.js Engine...');
            
            // Get canvas and create engine
            canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true
            });
            
            updateLoadingProgress(20, 'Creating Scene...');
            
            // Create scene
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1.0);
            
            // Enable physics
            updateLoadingProgress(30, 'Initializing Physics Engine...');
            await initPhysics();
            
            updateLoadingProgress(40, 'Setting Up Lighting...');
            setupLighting();
            
            updateLoadingProgress(50, 'Creating Environment...');
            setupEnvironment();
            
            updateLoadingProgress(60, 'Creating Road System...');
            roadManager = new RoadManager();
            
            updateLoadingProgress(70, 'Creating Building System...');
            buildingManager = new BuildingManager();
            
            updateLoadingProgress(80, 'Creating Player...');
            player = new Player();
            
            updateLoadingProgress(90, 'Initializing AI System...');
            botManager = new BotManager();
            
            updateLoadingProgress(95, 'Setting Up Camera...');
            setupCamera();
            
            updateLoadingProgress(100, 'Finalizing Setup...');
            
            // Setup post-processing
            setupPostProcessing();
            
            // Setup event listeners
            setupEventListeners();
            
            // Start game loop
            engine.runRenderLoop(() => {
                if (gameState === 'PLAYING') {
                    const deltaTime = engine.getDeltaTime() / 1000;
                    updateGame(deltaTime);
                }
                scene.render();
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
            
            // Hide loading screen and start game
            setTimeout(() => {
                dom.loadingScreen.classList.add('hidden');
                startGame();
            }, 1000);
        }

        // Initialize Physics
        async function initPhysics() {
            try {
                // Initialize Havok physics
                havokInstance = await HavokPhysics();
                physicsPlugin = new BABYLON.HavokPlugin(true, havokInstance);
                scene.enablePhysics(new BABYLON.Vector3(0, GAME_CONFIG.PHYSICS.GRAVITY, 0), physicsPlugin);
            } catch (error) {
                console.warn('Havok physics failed, falling back to default physics');
                scene.enablePhysics(new BABYLON.Vector3(0, GAME_CONFIG.PHYSICS.GRAVITY, 0));
            }
        }

        // Setup Lighting
        function setupLighting() {
            // Hemispheric light (sky light)
            const hemiLight = new BABYLON.HemisphericLight(
                'hemiLight',
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemiLight.intensity = 0.6;
            hemiLight.groundColor = new BABYLON.Color3(0.1, 0.1, 0.2);
            hemiLight.specular = new BABYLON.Color3(0, 0, 0);
            
            // Directional light (sun)
            const dirLight = new BABYLON.DirectionalLight(
                'dirLight',
                new BABYLON.Vector3(-1, -2, -1),
                scene
            );
            dirLight.position = new BABYLON.Vector3(20, 40, 20);
            dirLight.intensity = 0.8;
            dirLight.shadowEnabled = true;
            
            // Shadow generator
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, dirLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurScale = 2;
            shadowGenerator.setDarkness(0.4);
            
            // Fog
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = GAME_CONFIG.WORLD.FOG_DENSITY;
            scene.fogColor = new BABYLON.Color3(0.05, 0.05, 0.1);
        }

        // Setup Environment
        function setupEnvironment() {
            // Skybox
            const skybox = BABYLON.MeshBuilder.CreateBox('skybox', { size: 1000 }, scene);
            const skyboxMaterial = new BABYLON.StandardMaterial('skyboxMaterial', scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(
                'https://assets.babylonjs.com/textures/skybox',
                scene
            );
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;
            
            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround(
                'ground',
                { width: 1000, height: 1000 },
                scene
            );
            const groundMaterial = new BABYLON.StandardMaterial('groundMaterial', scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture(
                'https://assets.babylonjs.com/textures/grass.png',
                scene
            );
            groundMaterial.diffuseTexture.uScale = 100;
            groundMaterial.diffuseTexture.vScale = 100;
            groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            ground.material = groundMaterial;
            ground.receiveShadows = true;
            
            // Enable physics for ground
            ground.physicsImpostor = new BABYLON.PhysicsImpostor(
                ground,
                BABYLON.PhysicsImpostor.BoxImpostor,
                { mass: 0, restitution: 0.1 },
                scene
            );
        }

        // Road Manager Class
        class RoadManager {
            constructor() {
                this.segments = [];
                this.currentIndex = 0;
                this.noiseOffset = Math.random() * 1000;
                this.generateInitialRoad();
            }
            
            generateInitialRoad() {
                for (let i = 0; i < GAME_CONFIG.ROAD.VISIBLE_SEGMENTS; i++) {
                    this.createSegment(i);
                }
            }
            
            createSegment(index) {
                const z = index * GAME_CONFIG.ROAD.SEGMENT_LENGTH;
                
                // Use noise for natural curves and hills
                const noiseX = this.simplexNoise(this.noiseOffset + z * 0.01, 0);
                const noiseY = this.simplexNoise(this.noiseOffset + 1000 + z * 0.005, 0);
                const noiseZ = this.simplexNoise(this.noiseOffset + 2000 + z * 0.02, 0);
                
                const curve = noiseX * GAME_CONFIG.ROAD.CURVE_INTENSITY;
                const elevation = noiseY * GAME_CONFIG.ROAD.HILL_INTENSITY;
                const bank = noiseZ * GAME_CONFIG.ROAD.BANK_INTENSITY;
                
                // Create road segment
                const segment = BABYLON.MeshBuilder.CreateBox(
                    `road_${index}`,
                    {
                        width: GAME_CONFIG.ROAD.WIDTH,
                        height: 0.2,
                        depth: GAME_CONFIG.ROAD.SEGMENT_LENGTH
                    },
                    scene
                );
                
                segment.position = new BABYLON.Vector3(curve * 50, elevation, z);
                segment.rotation.x = bank;
                segment.rotation.y = curve;
                
                // Road material
                const roadMaterial = new BABYLON.StandardMaterial(`roadMat_${index}`, scene);
                roadMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                roadMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                
                // Add lane markings using decals
                this.addLaneMarkings(segment, elevation);
                
                segment.material = roadMaterial;
                segment.receiveShadows = true;
                
                // Add physics
                segment.physicsImpostor = new BABYLON.PhysicsImpostor(
                    segment,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 0.2 },
                    scene
                );
                
                // Store segment data
                this.segments[index] = {
                    mesh: segment,
                    index,
                    z,
                    curve,
                    elevation,
                    bank
                };
                
                // Occasionally add obstacles
                if (Math.random() < 0.1 && index > 10) {
                    this.addRoadObstacle(segment, elevation);
                }
            }
            
            addLaneMarkings(segment, elevation) {
                const laneWidth = GAME_CONFIG.ROAD.LANE_WIDTH;
                const roadWidth = GAME_CONFIG.ROAD.WIDTH;
                
                // Left lane marking
                const leftMarking = BABYLON.MeshBuilder.CreateBox(
                    'leftMarking',
                    { width: 0.1, height: 0.02, depth: GAME_CONFIG.ROAD.SEGMENT_LENGTH },
                    scene
                );
                leftMarking.parent = segment;
                leftMarking.position = new BABYLON.Vector3(-laneWidth, 0.11, 0);
                leftMarking.material = this.createLaneMaterial(0xFFFF00);
                
                // Right lane marking
                const rightMarking = BABYLON.MeshBuilder.CreateBox(
                    'rightMarking',
                    { width: 0.1, height: 0.02, depth: GAME_CONFIG.ROAD.SEGMENT_LENGTH },
                    scene
                );
                rightMarking.parent = segment;
                rightMarking.position = new BABYLON.Vector3(laneWidth, 0.11, 0);
                rightMarking.material = this.createLaneMaterial(0xFFFF00);
                
                // Center dashed markings
                const dashCount = Math.floor(GAME_CONFIG.ROAD.SEGMENT_LENGTH / 5);
                for (let i = 0; i < dashCount; i++) {
                    const dash = BABYLON.MeshBuilder.CreateBox(
                        `dash_${i}`,
                        { width: 0.05, height: 0.02, depth: 2 },
                        scene
                    );
                    dash.parent = segment;
                    dash.position = new BABYLON.Vector3(
                        0,
                        0.11,
                        -GAME_CONFIG.ROAD.SEGMENT_LENGTH/2 + i * 5 + 2.5
                    );
                    dash.material = this.createLaneMaterial(0xFFFFFF);
                }
            }
            
            createLaneMaterial(color) {
                const material = new BABYLON.StandardMaterial('laneMaterial', scene);
                material.emissiveColor = BABYLON.Color3.FromInts(
                    (color >> 16) & 0xFF,
                    (color >> 8) & 0xFF,
                    color & 0xFF
                );
                material.diffuseColor = material.emissiveColor;
                material.specularColor = new BABYLON.Color3(0, 0, 0);
                return material;
            }
            
            addRoadObstacle(segment, elevation) {
                const obstacleTypes = ['cone', 'barrel', 'bump'];
                const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                
                let obstacle;
                switch (type) {
                    case 'cone':
                        obstacle = BABYLON.MeshBuilder.CreateCylinder(
                            'cone',
                            { diameterTop: 0, diameterBottom: 1, height: 1.5 },
                            scene
                        );
                        break;
                    case 'barrel':
                        obstacle = BABYLON.MeshBuilder.CreateCylinder(
                            'barrel',
                            { diameterTop: 0.8, diameterBottom: 0.8, height: 1.2 },
                            scene
                        );
                        break;
                    case 'bump':
                        obstacle = BABYLON.MeshBuilder.CreateBox(
                            'bump',
                            { width: GAME_CONFIG.ROAD.WIDTH - 4, height: 0.3, depth: 1 },
                            scene
                        );
                        break;
                }
                
                if (obstacle) {
                    obstacle.parent = segment;
                    obstacle.position.y = 0.5;
                    obstacle.position.z = (Math.random() - 0.5) * GAME_CONFIG.ROAD.SEGMENT_LENGTH * 0.8;
                    
                    const obstacleMaterial = new BABYLON.StandardMaterial('obstacleMat', scene);
                    obstacleMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
                    obstacleMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.1, 0);
                    obstacle.material = obstacleMaterial;
                    
                    // Add physics
                    obstacle.physicsImpostor = new BABYLON.PhysicsImpostor(
                        obstacle,
                        BABYLON.PhysicsImpostor[type === 'bump' ? 'BoxImpostor' : 'CylinderImpostor'],
                        { mass: type === 'bump' ? 0 : 10, restitution: 0.5 },
                        scene
                    );
                }
            }
            
            update(playerZ) {
                const currentIndex = Math.floor(playerZ / GAME_CONFIG.ROAD.SEGMENT_LENGTH);
                
                if (currentIndex > this.currentIndex) {
                    this.currentIndex = currentIndex;
                    
                    // Remove old segments
                    const removeIndex = currentIndex - 20;
                    if (this.segments[removeIndex]) {
                        this.segments[removeIndex].mesh.dispose();
                        delete this.segments[removeIndex];
                    }
                    
                    // Add new segments
                    const addIndex = currentIndex + GAME_CONFIG.ROAD.VISIBLE_SEGMENTS - 10;
                    this.createSegment(addIndex);
                }
            }
            
            simplexNoise(x, y) {
                // Simple 2D noise function
                const s = (x, y) => {
                    const X = Math.floor(x) * 107, Y = Math.floor(y) * 113;
                    return ((Math.sin(X * 12.9898 + Y * 78.233) * 43758.5453) % 1) * 2 - 1;
                };
                
                const ix = Math.floor(x), fx = x - ix;
                const iy = Math.floor(y), fy = y - iy;
                
                const a = s(ix, iy), b = s(ix + 1, iy);
                const c = s(ix, iy + 1), d = s(ix + 1, iy + 1);
                
                const ux = fx * fx * (3 - 2 * fx);
                const uy = fy * fy * (3 - 2 * fy);
                
                return a + (b - a) * ux + (c - a) * uy + (a - b - c + d) * ux * uy;
            }
            
            getCurrentRoadData(z) {
                const index = Math.floor(z / GAME_CONFIG.ROAD.SEGMENT_LENGTH);
                return this.segments[index] || { curve: 0, elevation: 0, bank: 0 };
            }
        }

        // Building Manager Class
        class BuildingManager {
            constructor() {
                this.buildings = [];
                this.buildingTemplates = [];
                this.generateBuildingTemplates();
                this.generateInitialBuildings();
            }
            
            generateBuildingTemplates() {
                // Create different building types
                for (let i = 0; i < 5; i++) {
                    const width = 8 + Math.random() * 12;
                    const depth = 8 + Math.random() * 12;
                    const height = 15 + Math.random() * 30;
                    
                    const building = BABYLON.MeshBuilder.CreateBox(
                        `buildingTemplate_${i}`,
                        { width, height, depth },
                        scene
                    );
                    
                    // Apply procedural texture
                    this.applyBuildingTexture(building);
                    
                    building.isVisible = false; // Hide templates
                    this.buildingTemplates.push({
                        mesh: building,
                        width,
                        depth,
                        height
                    });
                }
            }
            
            applyBuildingTexture(mesh) {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Building color
                const hue = Math.floor(Math.random() * 40);
                const saturation = 30 + Math.random() * 40;
                const lightness = 30 + Math.random() * 40;
                const buildingColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                
                // Draw building facade
                ctx.fillStyle = buildingColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw windows
                const floorCount = 6 + Math.floor(Math.random() * 8);
                const windowCols = 4 + Math.floor(Math.random() * 6);
                const windowWidth = canvas.width / (windowCols * 2.5);
                const windowHeight = canvas.height / (floorCount * 3);
                const spacingX = canvas.width / windowCols;
                const spacingY = canvas.height / floorCount;
                
                // Window colors
                const windowColors = ['#aaddff', '#ffcc66', '#ccffcc'];
                const windowColor = windowColors[Math.floor(Math.random() * windowColors.length)];
                
                ctx.fillStyle = windowColor;
                for (let floor = 0; floor < floorCount; floor++) {
                    for (let col = 0; col < windowCols; col++) {
                        if (Math.random() > 0.15) { // 85% chance of a window
                            const x = col * spacingX + spacingX/2 - windowWidth/2;
                            const y = floor * spacingY + spacingY/2 - windowHeight/2;
                            
                            // Draw window
                            ctx.fillRect(x, y, windowWidth, windowHeight);
                            
                            // Window frame
                            ctx.strokeStyle = '#333333';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(x, y, windowWidth, windowHeight);
                            
                            // Window cross
                            ctx.beginPath();
                            ctx.moveTo(x + windowWidth/2, y);
                            ctx.lineTo(x + windowWidth/2, y + windowHeight);
                            ctx.moveTo(x, y + windowHeight/2);
                            ctx.lineTo(x + windowWidth, y + windowHeight/2);
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw doors
                const doorCount = 1 + Math.floor(Math.random() * 3);
                const doorWidth = canvas.width / (doorCount * 2.5);
                const doorHeight = canvas.height / 4;
                
                ctx.fillStyle = '#553311';
                for (let i = 0; i < doorCount; i++) {
                    const x = (i + 1) * canvas.width / (doorCount + 1) - doorWidth/2;
                    const y = canvas.height - doorHeight;
                    
                    ctx.fillRect(x, y, doorWidth, doorHeight);
                    
                    // Door details
                    ctx.strokeStyle = '#221100';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, doorWidth, doorHeight);
                    
                    // Door handle
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(x + doorWidth * 0.8, y + doorHeight/2, doorWidth/8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#553311';
                }
                
                // Create texture
                const texture = new BABYLON.Texture(null, scene);
                texture.name = `buildingTexture_${Date.now()}`;
                texture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
                texture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
                
                // Convert canvas to texture
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                texture.updateURL(canvas.toDataURL());
                
                // Apply material
                const material = new BABYLON.StandardMaterial(`buildingMat_${Date.now()}`, scene);
                material.diffuseTexture = texture;
                material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                material.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.05);
                
                mesh.material = material;
            }
            
            generateInitialBuildings() {
                for (let i = 0; i < GAME_CONFIG.WORLD.MAX_BUILDINGS; i++) {
                    this.createBuilding(i);
                }
            }
            
            createBuilding(index) {
                if (this.buildingTemplates.length === 0) return;
                
                const template = this.buildingTemplates[
                    Math.floor(Math.random() * this.buildingTemplates.length)
                ];
                
                // Clone building
                const building = template.mesh.clone(`building_${index}`);
                building.isVisible = true;
                
                // Position building
                const side = Math.random() > 0.5 ? 1 : -1;
                const roadOffset = GAME_CONFIG.ROAD.WIDTH / 2 + template.width / 2 + 5;
                const z = index * GAME_CONFIG.WORLD.BUILDING_SPACING;
                const x = side * (roadOffset + Math.random() * 15);
                
                building.position = new BABYLON.Vector3(
                    x,
                    template.height / 2,
                    z
                );
                
                // Random rotation and scale
                building.rotation.y = Math.random() * Math.PI;
                const scale = 0.8 + Math.random() * 0.4;
                building.scaling = new BABYLON.Vector3(scale, scale, scale);
                
                // Enable physics for collisions
                building.physicsImpostor = new BABYLON.PhysicsImpostor(
                    building,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 0.1 },
                    scene
                );
                
                // Store building
                this.buildings[index] = {
                    mesh: building,
                    index,
                    x,
                    z
                };
                
                // Create shadow catcher
                this.createShadowCatcher(building, template);
            }
            
            createShadowCatcher(building, template) {
                const shadowCatcher = BABYLON.MeshBuilder.CreateGround(
                    `shadow_${building.name}`,
                    { width: template.width * 1.2, height: template.depth * 1.2 },
                    scene
                );
                
                shadowCatcher.position = new BABYLON.Vector3(
                    building.position.x,
                    0.01,
                    building.position.z
                );
                
                const shadowMaterial = new BABYLON.ShadowOnlyMaterial('shadowMat', scene);
                shadowCatcher.material = shadowMaterial;
                shadowCatcher.receiveShadows = true;
            }
            
            update(playerZ) {
                // Remove buildings behind player
                for (let i = this.buildings.length - 1; i >= 0; i--) {
                    const building = this.buildings[i];
                    if (building && building.z < playerZ - 300) {
                        building.mesh.dispose();
                        delete this.buildings[i];
                    }
                }
                
                // Add new buildings ahead
                const farthestZ = this.buildings.reduce((max, b) => 
                    b && b.z > max ? b.z : max, playerZ
                );
                
                if (farthestZ < playerZ + 500) {
                    const newIndex = Math.floor(farthestZ / GAME_CONFIG.WORLD.BUILDING_SPACING) + 1;
                    this.createBuilding(newIndex);
                }
            }
        }

        // Player Class
        class Player {
            constructor() {
                this.products = GAME_CONFIG.PLAYER.START_PRODUCTS;
                this.boost = GAME_CONFIG.PLAYER.BOOST_CAPACITY;
                this.speed = 0;
                this.lane = GAME_CONFIG.PLAYER.START_LANE;
                this.targetLane = GAME_CONFIG.PLAYER.START_LANE;
                this.position = new BABYLON.Vector3(0, 1, 0);
                this.rotation = new BABYLON.Vector3(0, Math.PI, 0);
                this.lastCollisionTime = 0;
                this.cameraShake = 0;
                
                this.createCart();
                this.updateLaneIndicator();
            }
            
            createCart() {
                // Create cart body
                this.cart = BABYLON.MeshBuilder.CreateBox(
                    'cart',
                    { width: 2, height: 1, depth: 3 },
                    scene
                );
                
                // Cart material
                const cartMaterial = new BABYLON.StandardMaterial('cartMat', scene);
                cartMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
                cartMaterial.specularColor = new BABYLON.Color3(0.5, 0.1, 0.1);
                this.cart.material = cartMaterial;
                
                // Add wheels
                this.addWheels();
                
                // Add character
                this.createCharacter();
                
                // Enable physics
                this.cart.physicsImpostor = new BABYLON.PhysicsImpostor(
                    this.cart,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 100, restitution: 0.3 },
                    scene
                );
                
                // Set initial position
                this.cart.position = this.position;
                this.cart.rotation = this.rotation;
            }
            
            addWheels() {
                const wheelPositions = [
                    new BABYLON.Vector3(-0.8, -0.5, 1),
                    new BABYLON.Vector3(0.8, -0.5, 1),
                    new BABYLON.Vector3(-0.8, -0.5, -1),
                    new BABYLON.Vector3(0.8, -0.5, -1)
                ];
                
                wheelPositions.forEach((pos, i) => {
                    const wheel = BABYLON.MeshBuilder.CreateCylinder(
                        `wheel_${i}`,
                        { diameter: 0.6, height: 0.2 },
                        scene
                    );
                    wheel.parent = this.cart;
                    wheel.position = pos;
                    wheel.rotation.z = Math.PI / 2;
                    
                    const wheelMaterial = new BABYLON.StandardMaterial('wheelMat', scene);
                    wheelMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                    wheel.material = wheelMaterial;
                });
            }
            
            createCharacter() {
                // Character body
                this.character = BABYLON.MeshBuilder.CreateBox(
                    'character',
                    { width: 0.8, height: 1.5, depth: 0.4 },
                    scene
                );
                this.character.parent = this.cart;
                this.character.position = new BABYLON.Vector3(0, 0.8, 0);
                this.character.rotation.y = Math.PI / 4; // 45-degree angle
                
                const charMaterial = new BABYLON.StandardMaterial('charMat', scene);
                charMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.8);
                this.character.material = charMaterial;
            }
            
            update(deltaTime) {
                // Apply input
                this.processInput(deltaTime);
                
                // Update position based on speed
                const forwardVector = this.cart.getDirection(BABYLON.Vector3.Forward());
                this.cart.moveWithCollisions(forwardVector.scale(-this.speed * deltaTime));
                
                // Update lane position
                this.updateLanePosition(deltaTime);
                
                // Update boost
                this.updateBoost(deltaTime);
                
                // Update UI
                this.updateUI();
                
                // Apply camera shake
                if (this.cameraShake > 0) {
                    this.cameraShake -= deltaTime * 5;
                    if (this.cameraShake < 0) this.cameraShake = 0;
                }
            }
            
            processInput(deltaTime) {
                // Acceleration
                if (input.forward) {
                    this.speed += GAME_CONFIG.PLAYER.ACCELERATION * deltaTime * 60;
                } else {
                    this.speed *= 0.99; // Natural deceleration
                }
                
                // Braking
                if (input.backward) {
                    this.speed -= GAME_CONFIG.PLAYER.DECELERATION * deltaTime * 60;
                    if (this.speed < 0) this.speed = 0;
                }
                
                // Lane changes
                if (input.left && this.targetLane > 0) {
                    this.targetLane--;
                    input.left = false;
                }
                if (input.right && this.targetLane < 2) {
                    this.targetLane++;
                    input.right = false;
                }
                
                // Boost
                if (input.boost && this.boost > 0) {
                    this.speed *= GAME_CONFIG.PLAYER.BOOST_MULTIPLIER;
                    this.boost -= GAME_CONFIG.PLAYER.BOOST_DRAIN_RATE * deltaTime;
                    if (this.boost < 0) this.boost = 0;
                } else if (this.boost < GAME_CONFIG.PLAYER.BOOST_CAPACITY) {
                    this.boost += GAME_CONFIG.PLAYER.BOOST_RECHARGE_RATE * deltaTime;
                    if (this.boost > GAME_CONFIG.PLAYER.BOOST_CAPACITY) {
                        this.boost = GAME_CONFIG.PLAYER.BOOST_CAPACITY;
                    }
                }
                
                // Clamp speed
                const maxSpeed = input.boost ? 
                    GAME_CONFIG.PLAYER.MAX_SPEED * GAME_CONFIG.PLAYER.BOOST_MULTIPLIER : 
                    GAME_CONFIG.PLAYER.MAX_SPEED;
                this.speed = Math.min(Math.max(this.speed, 0), maxSpeed);
            }
            
            updateLanePosition(deltaTime) {
                const targetX = (this.targetLane - 1) * GAME_CONFIG.ROAD.LANE_WIDTH;
                const currentX = this.cart.position.x;
                const diffX = targetX - currentX;
                
                // Smooth lane change
                this.cart.position.x += diffX * GAME_CONFIG.PLAYER.LANE_CHANGE_SPEED * deltaTime * 60;
                
                // Clamp to road boundaries
                const halfRoad = GAME_CONFIG.ROAD.WIDTH / 2 - 1;
                this.cart.position.x = Math.max(-halfRoad, Math.min(halfRoad, this.cart.position.x));
                
                // Update current lane
                this.lane = Math.floor(
                    (this.cart.position.x + GAME_CONFIG.ROAD.WIDTH / 2) / GAME_CONFIG.ROAD.LANE_WIDTH
                );
                this.lane = Math.max(0, Math.min(2, this.lane));
                
                // Update lane indicator
                this.updateLaneIndicator();
            }
            
            updateLaneIndicator() {
                dom.laneLeft.classList.toggle('active', this.lane === 0);
                dom.laneCenter.classList.toggle('active', this.lane === 1);
                dom.laneRight.classList.toggle('active', this.lane === 2);
            }
            
            updateBoost(deltaTime) {
                const boostPercent = (this.boost / GAME_CONFIG.PLAYER.BOOST_CAPACITY) * 100;
                dom.boostFill.style.width = `${boostPercent}%`;
                
                // Visual feedback for low boost
                if (this.boost < 30) {
                    dom.boostFill.style.background = 'linear-gradient(90deg, #ff3333, #ff6666)';
                } else if (this.boost < 50) {
                    dom.boostFill.style.background = 'linear-gradient(90deg, #ffaa00, #ffcc00)';
                } else {
                    dom.boostFill.style.background = 'linear-gradient(90deg, #00ff88, #00ffcc)';
                }
            }
            
            updateUI() {
                dom.speedValue.textContent = Math.floor(this.speed);
                dom.productsValue.textContent = this.products;
                
                // Update boost bar
                const boostPercent = (this.boost / GAME_CONFIG.PLAYER.BOOST_CAPACITY) * 100;
                dom.boostFill.style.width = `${boostPercent}%`;
            }
            
            handleCollision() {
                const currentTime = gameTime;
                if (currentTime - this.lastCollisionTime > 1) { // 1 second cooldown
                    this.lastCollisionTime = currentTime;
                    this.products--;
                    this.cameraShake = 2;
                    
                    // Visual feedback
                    this.showCollisionWarning();
                    
                    // Apply physics impulse
                    const impulse = new BABYLON.Vector3(
                        (Math.random() - 0.5) * GAME_CONFIG.PHYSICS.COLLISION_FORCE,
                        0.5,
                        (Math.random() - 0.5) * GAME_CONFIG.PHYSICS.COLLISION_FORCE
                    );
                    
                    this.cart.physicsImpostor.applyImpulse(
                        impulse,
                        this.cart.getAbsolutePosition()
                    );
                    
                    // Reduce speed
                    this.speed *= 0.7;
                    
                    // Update UI
                    dom.productsValue.textContent = this.products;
                    
                    // Flash products panel
                    const productsPanel = document.getElementById('productsPanel');
                    productsPanel.style.borderColor = '#ff3333';
                    productsPanel.style.boxShadow = '0 0 40px rgba(255, 50, 50, 0.8)';
                    
                    setTimeout(() => {
                        productsPanel.style.borderColor = '#00ff88';
                        productsPanel.style.boxShadow = '0 8px 32px rgba(0, 255, 136, 0.2)';
                    }, 500);
                }
            }
            
            showCollisionWarning() {
                dom.collisionWarning.style.opacity = '1';
                dom.collisionWarning.style.transform = 'translate(-50%, -50%) scale(1.5)';
                
                setTimeout(() => {
                    dom.collisionWarning.style.opacity = '0';
                    dom.collisionWarning.style.transform = 'translate(-50%, -50%) scale(1)';
                }, 300);
            }
            
            getPosition() {
                return this.cart.position;
            }
            
            getSpeed() {
                return this.speed;
            }
        }

        // Bot Manager Class
        class BotManager {
            constructor() {
                this.bots = [];
                this.activeBots = 0;
                this.botTemplate = null;
                this.createBotTemplate();
                this.spawnInitialBots();
            }
            
            createBotTemplate() {
                // Create bot cart template
                this.botTemplate = BABYLON.MeshBuilder.CreateBox(
                    'botTemplate',
                    { width: 2, height: 1, depth: 3 },
                    scene
                );
                
                // Bot material (red)
                const botMaterial = new BABYLON.StandardMaterial('botMat', scene);
                botMaterial.diffuseColor = new BABYLON.Color3(1, 0.2, 0.2);
                botMaterial.emissiveColor = new BABYLON.Color3(0.3, 0, 0);
                this.botTemplate.material = botMaterial;
                
                // Add wheels
                this.addBotWheels();
                
                // Hide template
                this.botTemplate.isVisible = false;
                
                // Add physics
                this.botTemplate.physicsImpostor = new BABYLON.PhysicsImpostor(
                    this.botTemplate,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 120, restitution: 0.4 },
                    scene
                );
            }
            
            addBotWheels() {
                const wheelPositions = [
                    new BABYLON.Vector3(-0.8, -0.5, 1),
                    new BABYLON.Vector3(0.8, -0.5, 1),
                    new BABYLON.Vector3(-0.8, -0.5, -1),
                    new BABYLON.Vector3(0.8, -0.5, -1)
                ];
                
                wheelPositions.forEach((pos, i) => {
                    const wheel = BABYLON.MeshBuilder.CreateCylinder(
                        `botWheel_${i}`,
                        { diameter: 0.6, height: 0.2 },
                        scene
                    );
                    wheel.parent = this.botTemplate;
                    wheel.position = pos;
                    wheel.rotation.z = Math.PI / 2;
                    
                    const wheelMaterial = new BABYLON.StandardMaterial('botWheelMat', scene);
                    wheelMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                    wheel.material = wheelMaterial;
                });
            }
            
            spawnInitialBots() {
                // Start with 1 bot
                this.spawnBot();
            }
            
            spawnBot() {
                if (!this.botTemplate) return;
                
                // Clone bot from template
                const bot = this.botTemplate.clone(`bot_${this.bots.length}`);
                bot.isVisible = true;
                
                // Randomize bot properties
                const botData = {
                    mesh: bot,
                    lane: Math.floor(Math.random() * 3),
                    targetLane: Math.floor(Math.random() * 3),
                    speed: GAME_CONFIG.AI.MIN_SPEED + Math.random() * 
                        (GAME_CONFIG.AI.MAX_SPEED - GAME_CONFIG.AI.MIN_SPEED),
                    aggression: GAME_CONFIG.AI.AGGRESSION_LEVELS[
                        Math.floor(Math.random() * GAME_CONFIG.AI.AGGRESSION_LEVELS.length)
                    ],
                    mistakeTimer: 0,
                    reactionTimer: 0,
                    position: new BABYLON.Vector3(0, 1, -50 - Math.random() * 50)
                };
                
                // Set initial position
                bot.position = botData.position;
                bot.rotation = new BABYLON.Vector3(0, Math.PI, 0);
                
                // Add to scene
                this.bots.push(botData);
                this.activeBots++;
                
                // Update UI
                dom.botCountValue.textContent = this.activeBots;
                dom.botCount.textContent = this.activeBots;
                
                // Show bot indicator
                dom.botIndicator.style.opacity = '1';
            }
            
            update(deltaTime, playerPosition, playerLane, playerSpeed) {
                for (let i = this.bots.length - 1; i >= 0; i--) {
                    const bot = this.bots[i];
                    if (!bot) continue;
                    
                    // Update timers
                    bot.mistakeTimer -= deltaTime;
                    bot.reactionTimer -= deltaTime;
                    
                    // AI Logic
                    this.updateBotAI(bot, deltaTime, playerPosition, playerLane, playerSpeed);
                    
                    // Move bot forward
                    const forwardVector = bot.mesh.getDirection(BABYLON.Vector3.Forward());
                    bot.mesh.moveWithCollisions(forwardVector.scale(-bot.speed * deltaTime));
                    
                    // Update lane position
                    this.updateBotLane(bot, deltaTime);
                    
                    // Remove bots that are too far behind
                    if (bot.mesh.position.z < playerPosition.z - 150) {
                        bot.mesh.dispose();
                        this.bots.splice(i, 1);
                        this.activeBots--;
                    }
                }
                
                // Update UI
                dom.botCountValue.textContent = this.activeBots;
                dom.botCount.textContent = this.activeBots;
                dom.botIndicator.style.opacity = this.activeBots > 0 ? '1' : '0.5';
            }
            
            updateBotAI(bot, deltaTime, playerPosition, playerLane, playerSpeed) {
                // Calculate distance to player
                const distanceToPlayer = BABYLON.Vector3.Distance(
                    bot.mesh.position,
                    playerPosition
                );
                
                // Make occasional mistakes
                if (bot.mistakeTimer <= 0 && Math.random() < GAME_CONFIG.AI.MISTAKE_PROBABILITY) {
                    bot.mistakeTimer = 1 + Math.random() * 3;
                    bot.targetLane = Math.floor(Math.random() * 3);
                }
                
                // Normal AI behavior
                if (bot.mistakeTimer <= 0 && bot.reactionTimer <= 0) {
                    // Chase player
                    const laneDiff = playerLane - bot.lane;
                    
                    if (Math.abs(laneDiff) > 0.5 && Math.random() < bot.aggression * 0.03) {
                        bot.targetLane += Math.sign(laneDiff);
                        bot.targetLane = Math.max(0, Math.min(2, bot.targetLane));
                        bot.reactionTimer = GAME_CONFIG.AI.REACTION_TIME;
                    }
                    
                    // Adjust speed based on distance to player
                    if (distanceToPlayer > 30) {
                        bot.speed = Math.min(bot.speed + deltaTime * 10, GAME_CONFIG.AI.MAX_SPEED);
                    } else if (distanceToPlayer < 15) {
                        bot.speed = Math.max(bot.speed - deltaTime * 15, GAME_CONFIG.AI.MIN_SPEED);
                    }
                    
                    // Try to match player speed when close
                    if (distanceToPlayer < 25) {
                        bot.speed += (playerSpeed - bot.speed) * deltaTime * 0.5;
                    }
                }
            }
            
            updateBotLane(bot, deltaTime) {
                const targetX = (bot.targetLane - 1) * GAME_CONFIG.ROAD.LANE_WIDTH;
                const currentX = bot.mesh.position.x;
                const diffX = targetX - currentX;
                
                // Smooth lane change
                bot.mesh.position.x += diffX * 0.1 * deltaTime * 60;
                
                // Clamp to road boundaries
                const halfRoad = GAME_CONFIG.ROAD.WIDTH / 2 - 1;
                bot.mesh.position.x = Math.max(-halfRoad, Math.min(halfRoad, bot.mesh.position.x));
                
                // Update current lane
                bot.lane = Math.floor(
                    (bot.mesh.position.x + GAME_CONFIG.ROAD.WIDTH / 2) / GAME_CONFIG.ROAD.LANE_WIDTH
                );
                bot.lane = Math.max(0, Math.min(2, bot.lane));
            }
            
            checkCollisions(playerPosition) {
                for (const bot of this.bots) {
                    if (!bot) continue;
                    
                    const distance = BABYLON.Vector3.Distance(
                        bot.mesh.position,
                        playerPosition
                    );
                    
                    if (distance < 2.5) {
                        return bot;
                    }
                }
                return null;
            }
        }

        // Setup Camera
        function setupCamera() {
            // Create third-person camera
            camera = new BABYLON.FollowCamera(
                'followCamera',
                new BABYLON.Vector3(0, 5, -15),
                scene
            );
            
            // Set camera target (player's cart)
            camera.lockedTarget = player.cart;
            
            // Camera settings
            camera.heightOffset = 3;
            camera.radius = 12;
            camera.rotationOffset = 0;
            camera.cameraAcceleration = 0.05;
            camera.maxCameraSpeed = 10;
            
            // Attach camera to canvas
            camera.attachControl(canvas, true);
            
            // Enable camera collisions
            camera.checkCollisions = true;
            camera.collisionRadius = new BABYLON.Vector3(0.5, 0.5, 0.5);
        }

        // Setup Post-Processing
        function setupPostProcessing() {
            // Create post-processing pipeline
            const pipeline = new BABYLON.PostProcessRenderPipeline(
                engine,
                'defaultPipeline'
            );
            
            // Add bloom effect for glowing elements
            const bloom = new BABYLON.BloomEffect(
                'bloom',
                scene,
                1.0,  // Bloom scale
                40,   // Bloom threshold
                0.8   // Bloom weight
            );
            pipeline.addEffect(bloom);
            
            // Add vignette effect
            const vignette = new BABYLON.VignetteEffect(
                'vignette',
                scene,
                0.5,  // Vignette weight
                0.5   // Vignette blur
            );
            pipeline.addEffect(vignette);
            
            // Apply pipeline to scene
            scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(
                'defaultPipeline',
                camera
            );
            
            // Enable image processing
            scene.imageProcessingConfiguration.contrast = 1.2;
            scene.imageProcessingConfiguration.exposure = 1.1;
            scene.imageProcessingConfiguration.toneMappingEnabled = true;
        }

        // Update Loading Progress
        function updateLoadingProgress(percent, text) {
            dom.loadingBar.style.width = `${percent}%`;
            dom.loadingText.textContent = text;
        }

        // Setup Event Listeners
        function setupEventListeners() {
            // Keyboard input
            window.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        input.forward = true;
                        break;
                    case 's':
                    case 'arrowdown':
                        input.backward = true;
                        break;
                    case 'a':
                    case 'arrowleft':
                        input.left = true;
                        break;
                    case 'd':
                    case 'arrowright':
                        input.right = true;
                        break;
                    case ' ':
                    case 'space':
                        input.boost = true;
                        break;
                    case 'escape':
                    case 'p':
                        togglePause();
                        break;
                }
            });
            
            window.addEventListener('keyup', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        input.forward = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        input.backward = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        input.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        input.right = false;
                        break;
                    case ' ':
                    case 'space':
                        input.boost = false;
                        break;
                }
            });
            
            // Gamepad support
            let gamepad = null;
            
            function updateGamepad() {
                if (!navigator.getGamepads) return;
                
                const gamepads = navigator.getGamepads();
                if (gamepads[0]) {
                    gamepad = gamepads[0];
                    
                    // Left stick for acceleration/braking
                    if (Math.abs(gamepad.axes[1]) > 0.1) {
                        if (gamepad.axes[1] < -0.5) {
                            input.forward = true;
                            input.backward = false;
                        } else if (gamepad.axes[1] > 0.5) {
                            input.backward = true;
                            input.forward = false;
                        }
                    } else {
                        input.forward = false;
                        input.backward = false;
                    }
                    
                    // Left stick for lane changes
                    if (Math.abs(gamepad.axes[0]) > 0.5) {
                        if (gamepad.axes[0] < -0.5 && !input.left) {
                            input.left = true;
                        } else if (gamepad.axes[0] > 0.5 && !input.right) {
                            input.right = true;
                        }
                    }
                    
                    // Button A (0) for boost
                    if (gamepad.buttons[0] && gamepad.buttons[0].pressed) {
                        input.boost = true;
                    } else {
                        input.boost = false;
                    }
                    
                    // Start button (9) for pause
                    if (gamepad.buttons[9] && gamepad.buttons[9].pressed) {
                        togglePause();
                    }
                }
            }
            
            // Gamepad polling
            setInterval(updateGamepad, 50);
            
            // UI buttons
            dom.resumeButton.addEventListener('click', togglePause);
            dom.restartButton.addEventListener('click', restartGame);
            dom.playAgainButton.addEventListener('click', restartGame);
            
            // Prevent context menu on right click
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // Start Game
        function startGame() {
            gameState = 'PLAYING';
            gameTime = 0;
            score = 0;
            distance = 0;
            activeBots = 1;
            nextBotScore = GAME_CONFIG.AI.SPAWN_SCORE_INTERVAL;
            
            // Reset UI
            dom.scoreValue.textContent = '0';
            dom.distanceValue.textContent = '0m';
            dom.timeValue.textContent = '00:00';
            dom.botCountValue.textContent = '1';
            dom.productsValue.textContent = GAME_CONFIG.PLAYER.START_PRODUCTS;
            dom.speedValue.textContent = '0';
        }

        // Update Game
        function updateGame(deltaTime) {
            // Update game time
            gameTime += deltaTime;
            
            // Update player
            player.update(deltaTime);
            
            // Update road based on player position
            const playerPos = player.getPosition();
            roadManager.update(playerPos.z);
            
            // Update buildings
            buildingManager.update(playerPos.z);
            
            // Update bots
            botManager.update(deltaTime, playerPos, player.lane, player.getSpeed());
            
            // Update score and distance
            updateScore(deltaTime);
            
            // Check collisions
            checkCollisions();
            
            // Update camera with shake
            updateCameraWithShake(deltaTime);
            
            // Spawn new bots based on score
            if (score >= nextBotScore) {
                botManager.spawnBot();
                nextBotScore += GAME_CONFIG.AI.SPAWN_SCORE_INTERVAL;
                activeBots++;
            }
            
            // Update UI
            updateUI(deltaTime);
            
            // Check game over
            if (player.products <= 0) {
                gameOver();
            }
        }

        // Update Score
        function updateScore(deltaTime) {
            // Distance score
            distance += player.getSpeed() * deltaTime * 0.1;
            
            // Base score from distance and speed
            const distanceScore = Math.floor(distance * 0.2);
            const speedScore = Math.floor(player.getSpeed() * deltaTime * 5);
            
            // Bonus for surviving with bots
            const botBonus = activeBots * 10 * deltaTime;
            
            score = distanceScore + speedScore + Math.floor(botBonus);
        }

        // Check Collisions
        function checkCollisions() {
            const playerPos = player.getPosition();
            
            // Check collision with bots
            const collidingBot = botManager.checkCollisions(playerPos);
            if (collidingBot) {
                player.handleCollision();
                
                // Apply physics to bot
                const impulse = new BABYLON.Vector3(
                    (Math.random() - 0.5) * GAME_CONFIG.PHYSICS.COLLISION_FORCE,
                    0.3,
                    (Math.random() - 0.5) * GAME_CONFIG.PHYSICS.COLLISION_FORCE
                );
                
                collidingBot.mesh.physicsImpostor.applyImpulse(
                    impulse,
                    collidingBot.mesh.getAbsolutePosition()
                );
                
                // Reduce bot speed
                collidingBot.speed *= 0.8;
            }
            
            // Check road boundary collisions
            const halfRoad = GAME_CONFIG.ROAD.WIDTH / 2 - 0.5;
            if (Math.abs(playerPos.x) > halfRoad) {
                player.handleCollision();
                
                // Push player back into road
                const pushDirection = playerPos.x > 0 ? -1 : 1;
                const impulse = new BABYLON.Vector3(
                    pushDirection * GAME_CONFIG.PHYSICS.COLLISION_FORCE * 0.5,
                    0.2,
                    0
                );
                
                player.cart.physicsImpostor.applyImpulse(
                    impulse,
                    player.cart.getAbsolutePosition()
                );
            }
        }

        // Update Camera with Shake
        function updateCameraWithShake(deltaTime) {
            if (player.cameraShake > 0) {
                const shakeX = (Math.random() - 0.5) * player.cameraShake * 0.1;
                const shakeY = (Math.random() - 0.5) * player.cameraShake * 0.1;
                
                camera.position.x += shakeX;
                camera.position.y += shakeY;
                
                // Smoothly return to normal
                camera.position.x -= shakeX * deltaTime * 10;
                camera.position.y -= shakeY * deltaTime * 10;
            }
        }

        // Update UI
        function updateUI(deltaTime) {
            // Update score
            dom.scoreValue.textContent = score.toLocaleString();
            
            // Update distance
            dom.distanceValue.textContent = `${Math.floor(distance)}m`;
            
            // Update time
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            dom.timeValue.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update bot count
            dom.botCountValue.textContent = activeBots;
            dom.botCount.textContent = activeBots;
            
            // Update speed
            dom.speedValue.textContent = Math.floor(player.getSpeed());
            
            // Update products
            dom.productsValue.textContent = player.products;
        }

        // Toggle Pause
        function togglePause() {
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED';
                dom.pauseScreen.classList.remove('hidden');
            } else if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                dom.pauseScreen.classList.add('hidden');
            }
        }

        // Game Over
        function gameOver() {
            gameState = 'GAME_OVER';
            
            // Update final stats
            dom.finalScore.textContent = score.toLocaleString();
            dom.finalDistance.textContent = `${Math.floor(distance)}m`;
            
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            dom.finalTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            dom.finalBots.textContent = activeBots;
            
            // Show game over screen
            dom.gameOverScreen.classList.remove('hidden');
        }

        // Restart Game
        function restartGame() {
            // Reset game state
            gameState = 'PLAYING';
            gameTime = 0;
            score = 0;
            distance = 0;
            activeBots = 1;
            nextBotScore = GAME_CONFIG.AI.SPAWN_SCORE_INTERVAL;
            
            // Reset player
            player.products = GAME_CONFIG.PLAYER.START_PRODUCTS;
            player.boost = GAME_CONFIG.PLAYER.BOOST_CAPACITY;
            player.speed = 0;
            player.lane = GAME_CONFIG.PLAYER.START_LANE;
            player.targetLane = GAME_CONFIG.PLAYER.START_LANE;
            player.position = new BABYLON.Vector3(0, 1, 0);
            player.rotation = new BABYLON.Vector3(0, Math.PI, 0);
            player.lastCollisionTime = 0;
            player.cameraShake = 0;
            
            // Reset player cart position
            player.cart.position = player.position;
            player.cart.rotation = player.rotation;
            player.cart.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
            player.cart.physicsImpostor.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));
            
            // Clear bots
            for (const bot of botManager.bots) {
                if (bot && bot.mesh) {
                    bot.mesh.dispose();
                }
            }
            botManager.bots = [];
            botManager.activeBots = 0;
            
            // Spawn initial bot
            botManager.spawnBot();
            
            // Reset road and buildings
            roadManager = new RoadManager();
            buildingManager = new BuildingManager();
            
            // Update UI
            dom.scoreValue.textContent = '0';
            dom.distanceValue.textContent = '0m';
            dom.timeValue.textContent = '00:00';
            dom.botCountValue.textContent = '1';
            dom.productsValue.textContent = GAME_CONFIG.PLAYER.START_PRODUCTS;
            dom.speedValue.textContent = '0';
            
            // Hide screens
            dom.pauseScreen.classList.add('hidden');
            dom.gameOverScreen.classList.add('hidden');
        }

        // Initialize the game when page loads
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
