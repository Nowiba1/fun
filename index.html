<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLAP! Ultimate - 3D P2P Brawler</title>
    <style>
        :root { --accent: #ff0055; --bg: #0a0a12; }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Impact, sans-serif; background: var(--bg); color: white; }
        canvas { display: block; filter: contrast(1.1) saturate(1.2); }
        
        /* UI DESIGN */
        #ui-layer { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 100; background: rgba(10, 10, 18, 0.85); backdrop-filter: blur(8px); transition: opacity 0.5s; }
        .panel { background: #1a1a2e; border: 4px solid var(--accent); padding: 40px; border-radius: 30px; text-align: center; width: 450px; box-shadow: 0 0 50px rgba(255, 0, 85, 0.3); }
        .hidden { display: none !important; opacity: 0; pointer-events: none; }
        
        h1 { font-size: 4rem; margin: 0; color: #fff; text-shadow: 0 0 20px var(--accent); font-style: italic; }
        .subtitle { color: var(--accent); font-weight: bold; letter-spacing: 2px; margin-bottom: 30px; }
        
        button { background: var(--accent); color: white; border: none; padding: 18px 30px; font-size: 1.2rem; font-weight: 900; cursor: pointer; border-radius: 15px; margin: 10px; width: 100%; transition: 0.2s; text-transform: uppercase; }
        button:hover { transform: scale(1.05); filter: brightness(1.2); }
        
        textarea { width: 100%; height: 100px; margin-top: 15px; border-radius: 10px; background: #000; color: #00ffcc; border: 1px solid #333; font-family: monospace; padding: 10px; box-sizing: border-box; font-size: 11px; }
        
        /* HUD */
        #hud { position: absolute; top: 0; width: 100%; display: flex; justify-content: space-between; padding: 20px 50px; box-sizing: border-box; pointer-events: none; display: none; }
        .score-box { background: rgba(0,0,0,0.6); padding: 10px 30px; border-radius: 15px; border-bottom: 4px solid var(--accent); font-size: 2rem; font-weight: bold; }
        #center-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 5rem; font-weight: 900; color: white; text-shadow: 0 0 30px var(--accent); pointer-events: none; opacity: 0; transition: 0.3s; }
    </style>
</head>
<body>

<div id="hud">
    <div class="score-box" id="p1-score">P1: 0</div>
    <div class="score-box" id="p2-score">P2: 0</div>
</div>
<div id="center-msg">SLAP!</div>

<div id="ui-layer">
    <div id="menu-main" class="panel">
        <h1>SLAP!</h1>
        <div class="subtitle">ULTIMATE P2P EDITION</div>
        <button onclick="showPanel('menu-create')">Create Arena</button>
        <button onclick="showPanel('menu-join')">Join Friend</button>
    </div>

    <div id="menu-create" class="panel hidden">
        <h2>Host Arena</h2>
        <p>Send this invitation string:</p>
        <textarea id="host-offer" readonly onclick="this.select()"></textarea>
        <p>Paste response string:</p>
        <textarea id="host-answer-input" placeholder="Paste joiner's response..."></textarea>
        <button onclick="finalizeHost()">Start Combat</button>
    </div>

    <div id="menu-join" class="panel hidden">
        <h2>Joining Arena</h2>
        <textarea id="client-offer-input" placeholder="Paste host's code..."></textarea>
        <button onclick="startJoiner()">Generate Response</button>
        <div id="client-response-area" class="hidden">
            <textarea id="client-answer-output" readonly onclick="this.select()"></textarea>
            <p>Send that back to host!</p>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/** * --- GAME CONSTANTS ---
 */
const GAME_CONFIG = {
    arenaSize: 12,
    playerSpeed: 0.18,
    knockback: 1.5,
    gravity: 0.02,
    drag: 0.93,
    slapCooldown: 500,
    winScore: 3
};

let scene, camera, renderer, player, opponent, arena, floorGrid;
let isHost = false, gameActive = false, score = { p1: 0, p2: 0 };
let peerConn, dataChannel, keys = {};
let time = 0, cameraShake = 0, slowMo = 1.0;

/** * --- NETWORKING (WebRTC) ---
 */
const rtcConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

function showPanel(id) {
    document.querySelectorAll('.panel').forEach(p => p.classList.add('hidden'));
    document.getElementById(id).classList.remove('hidden');
    if(id === 'menu-create') setupHost();
}

async function setupHost() {
    isHost = true;
    peerConn = new RTCPeerConnection(rtcConfig);
    dataChannel = peerConn.createDataChannel("slapChannel");
    setupDataHandlers();
    const offer = await peerConn.createOffer();
    await peerConn.setLocalDescription(offer);
    peerConn.onicecandidate = e => { if(!e.candidate) document.getElementById('host-offer').value = btoa(JSON.stringify(peerConn.localDescription)); };
}

async function finalizeHost() {
    const answer = new RTCSessionDescription(JSON.parse(atob(document.getElementById('host-answer-input').value)));
    await peerConn.setRemoteDescription(answer);
}

async function startJoiner() {
    const offer = new RTCSessionDescription(JSON.parse(atob(document.getElementById('client-offer-input').value)));
    peerConn = new RTCPeerConnection(rtcConfig);
    peerConn.ondatachannel = e => { dataChannel = e.channel; setupDataHandlers(); };
    await peerConn.setRemoteDescription(offer);
    const answer = await peerConn.createAnswer();
    await peerConn.setLocalDescription(answer);
    peerConn.onicecandidate = e => { if(!e.candidate) {
        document.getElementById('client-answer-output').value = btoa(JSON.stringify(peerConn.localDescription));
        document.getElementById('client-response-area').classList.remove('hidden');
    }};
}

function setupDataHandlers() {
    dataChannel.onopen = () => initWorld();
    dataChannel.onmessage = e => {
        const d = JSON.parse(e.data);
        if(d.type === 'sync') {
            opponent.position.lerp(new THREE.Vector3(d.p.x, d.p.y, d.p.z), 0.5);
            opponent.rotation.y = d.r;
            opponent.body.rotation.x = d.brx;
        } else if(d.type === 'slap') {
            handleHit(d.dir, d.pwr);
        } else if(d.type === 'reset') {
            resetRound(d.scores);
        }
    };
}

/** * --- WORLD DESIGN & CHARACTER ---
 */
function initWorld() {
    document.getElementById('ui-layer').classList.add('hidden');
    document.getElementById('hud').style.display = 'flex';
    
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a12);
    scene.fog = new THREE.Fog(0x0a0a12, 20, 50);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Dynamic Arena
    const arenaGeo = new THREE.CylinderGeometry(GAME_CONFIG.arenaSize, GAME_CONFIG.arenaSize + 2, 2, 6);
    const arenaMat = new THREE.MeshPhongMaterial({ color: 0x222244, flatShading: true });
    arena = new THREE.Mesh(arenaGeo, arenaMat);
    arena.position.y = -1.1;
    scene.add(arena);

    floorGrid = new THREE.GridHelper(40, 40, 0xff0055, 0x222222);
    floorGrid.position.y = -0.05;
    scene.add(floorGrid);

    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);
    const sun = new THREE.PointLight(0xffffff, 1, 100);
    sun.position.set(10, 20, 10);
    scene.add(sun);

    player = createChar(isHost ? 0x00ffcc : 0xff0055);
    opponent = createChar(isHost ? 0xff0055 : 0x00ffcc);
    
    scene.add(player);
    scene.add(opponent);
    resetPositions();

    gameActive = true;
    animate();
}

function createChar(color) {
    const group = new THREE.Group();
    const mat = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
    
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.8, 0.8), mat);
    body.position.y = 0.9;
    group.add(body);
    group.body = body;

    const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), new THREE.MeshPhongMaterial({color: 0xffffff}));
    head.position.y = 1.4;
    body.add(head);

    const handGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
    group.hand = new THREE.Mesh(handGeo, mat);
    group.hand.position.set(0.9, 0, 0.6);
    body.add(group.hand);

    group.velocity = new THREE.Vector3();
    group.lastSlap = 0;
    return group;
}

/** * --- GAMEPLAY LOGIC ---
 */
function handleInput() {
    let mx = 0, mz = 0;
    const pad = navigator.getGamepads()[0];

    if(keys['KeyW'] || keys['ArrowUp'] || (pad && pad.axes[1] < -0.1)) mz -= 1;
    if(keys['KeyS'] || keys['ArrowDown'] || (pad && pad.axes[1] > 0.1)) mz += 1;
    if(keys['KeyA'] || keys['ArrowLeft'] || (pad && pad.axes[0] < -0.1)) mx -= 1;
    if(keys['KeyD'] || keys['ArrowRight'] || (pad && pad.axes[0] > 0.1)) mx += 1;

    if(mx !== 0 || mz !== 0) {
        const angle = Math.atan2(mx, mz);
        player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, angle, 0.2);
        player.position.x += Math.sin(angle) * GAME_CONFIG.playerSpeed * slowMo;
        player.position.z += Math.cos(angle) * GAME_CONFIG.playerSpeed * slowMo;
        // Wobble
        player.body.rotation.z = Math.sin(time * 15) * 0.15;
        player.body.rotation.x = 0.1;
    } else {
        player.body.rotation.z *= 0.9;
        player.body.rotation.x *= 0.9;
    }

    if(keys['Space'] || (pad && pad.buttons[0].pressed)) triggerSlap();
}

function triggerSlap() {
    if(Date.now() - player.lastSlap < GAME_CONFIG.slapCooldown) return;
    player.lastSlap = Date.now();

    // Hand Animation
    player.hand.position.z = 2.0;
    setTimeout(() => player.hand.position.z = 0.6, 150);

    const dist = player.position.distanceTo(opponent.position);
    if(dist < 2.8) {
        const dir = new THREE.Vector3().subVectors(opponent.position, player.position).normalize();
        dataChannel.send(JSON.stringify({ type: 'slap', dir: {x: dir.x, z: dir.z}, pwr: GAME_CONFIG.knockback }));
        
        // Effects
        cameraShake = 0.5;
        slowMo = 0.2;
        setTimeout(() => slowMo = 1.0, 200);
    }
}

function handleHit(dir, pwr) {
    opponent.hand.position.z = 2.0;
    setTimeout(() => opponent.hand.position.z = 0.6, 150);
    
    player.velocity.x += dir.x * pwr;
    player.velocity.z += dir.z * pwr;
    cameraShake = 0.8;
}

function animate() {
    if(!gameActive) return;
    requestAnimationFrame(animate);
    time += 0.01;

    handleInput();

    // Physics
    player.position.add(player.velocity);
    player.velocity.multiplyScalar(GAME_CONFIG.drag);

    const d = Math.sqrt(player.position.x**2 + player.position.z**2);
    if(d > GAME_CONFIG.arenaSize || player.position.y < 0) {
        player.position.y -= GAME_CONFIG.gravity;
    }

    // Camera
    camera.position.lerp(new THREE.Vector3(player.position.x, 8, player.position.z + 12), 0.1);
    if(cameraShake > 0) {
        camera.position.x += (Math.random()-0.5) * cameraShake;
        camera.position.y += (Math.random()-0.5) * cameraShake;
        cameraShake *= 0.9;
    }
    camera.lookAt(player.position);

    // Networking
    if(dataChannel.readyState === "open") {
        dataChannel.send(JSON.stringify({
            type: 'sync',
            p: {x: player.position.x, y: player.position.y, z: player.position.z},
            r: player.rotation.y, brx: player.body.rotation.x
        }));
    }

    // Win/Loss Detection
    if(player.position.y < -15 && isHost) {
        score.p2++; 
        broadcastReset();
    } else if (opponent.position.y < -15 && isHost) {
        score.p1++;
        broadcastReset();
    }

    renderer.render(scene, camera);
}

function broadcastReset() {
    const msg = { type: 'reset', scores: score };
    dataChannel.send(JSON.stringify(msg));
    resetRound(score);
}

function resetRound(newScores) {
    score = newScores;
    document.getElementById('p1-score').innerText = `P1: ${score.p1}`;
    document.getElementById('p2-score').innerText = `P2: ${score.p2}`;
    
    const msg = document.getElementById('center-msg');
    msg.innerText = "ROUND OVER!";
    msg.style.opacity = 1;
    
    gameActive = false;
    setTimeout(() => {
        if(score.p1 >= GAME_CONFIG.winScore || score.p2 >= GAME_CONFIG.winScore) {
            msg.innerText = score.p1 >= GAME_CONFIG.winScore ? "P1 WINS MATCH!" : "P2 WINS MATCH!";
            setTimeout(() => location.reload(), 3000);
        } else {
            msg.style.opacity = 0;
            resetPositions();
            gameActive = true;
            animate();
        }
    }, 2000);
}

function resetPositions() {
    player.position.set(isHost ? -5 : 5, 0, 0);
    opponent.position.set(isHost ? 5 : -5, 0, 0);
    player.velocity.set(0,0,0);
    player.rotation.set(0, isHost ? Math.PI/2 : -Math.PI/2, 0);
}

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
