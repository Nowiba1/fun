<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless 4-Lane 3D Drive</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #111;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #game-container {
            flex: 1;
            position: relative;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        #score {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #speed {
            font-size: 20px;
            margin-bottom: 5px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
            pointer-events: none;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .key {
            display: inline-block;
            background: #333;
            padding: 3px 8px;
            margin: 0 5px;
            border-radius: 4px;
            min-width: 30px;
            text-align: center;
            font-weight: bold;
            color: #fff;
        }
        
        #lane-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            display: none;
            box-shadow: 0 0 30px rgba(0, 100, 200, 0.5);
        }
        
        #game-over h2 {
            font-size: 40px;
            color: #f44;
            margin-bottom: 20px;
        }
        
        #final-score {
            font-size: 28px;
            margin-bottom: 25px;
        }
        
        #restart-btn {
            background: #4a8;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #restart-btn:hover {
            background: #5b9;
            transform: scale(1.05);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            z-index: 300;
        }
        
        #import-controls {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
        }
        
        #import-controls h3 {
            margin-bottom: 10px;
            color: #4af;
        }
        
        .file-input {
            margin: 10px 0;
            color: white;
        }
        
        #import-btn {
            background: #4af;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        #import-btn:hover {
            background: #5bf;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui">
        <div id="score">SCORE: 0</div>
        <div id="speed">SPEED: 0 km/h</div>
        <div id="lives">LIVES: 3</div>
    </div>
    
    <div id="lane-display">LANE: 2</div>
    
    <div id="import-controls">
        <h3>Import GLTF Models</h3>
        <div class="control-row">
            <label for="player-car-file">Player Car (.gltf/.glb):</label>
            <input type="file" id="player-car-file" accept=".gltf,.glb" class="file-input">
        </div>
        <div class="control-row">
            <label for="bot-car-file">Enemy Car (.gltf/.glb):</label>
            <input type="file" id="bot-car-file" accept=".gltf,.glb" class="file-input">
        </div>
        <button id="import-btn">Import Selected Models</button>
    </div>
    
    <div id="controls">
        <div class="control-row"><span class="key">W</span> / <span class="key">↑</span> : Accelerate</div>
        <div class="control-row"><span class="key">S</span> / <span class="key">↓</span> : Brake</div>
        <div class="control-row"><span class="key">A</span> / <span class="key">←</span> : Move Left</div>
        <div class="control-row"><span class="key">D</span> / <span class="key">→</span> : Move Right</div>
        <div class="control-row">Stay in your lane!</div>
    </div>
    
    <div id="game-over">
        <h2>GAME OVER</h2>
        <div id="final-score">Final Score: 0</div>
        <button id="restart-btn">RESTART GAME</button>
    </div>
    
    <div id="loading">Loading game...</div>

    <script>
        // ==================== GAME INITIALIZATION ====================
        document.getElementById('loading').style.display = 'block';
        
        // Global variables
        let scene, camera, renderer, roadCurve, roadMesh, playerCar, clock;
        let playerPosition = 0; // Position along the curve
        let playerSpeed = 0;
        
        // FIXED: 4-lane system
        const LANE_COUNT = 4;
        const ROAD_WIDTH = 12;
        const LANE_WIDTH = ROAD_WIDTH / LANE_COUNT; // 3 units per lane
        // Lane center positions: [-4.5, -1.5, 1.5, 4.5]
        let currentLane = 2; // Start in lane 2 (0-indexed, so 2 = third lane from left)
        let targetLane = 2;
        let laneChangeProgress = 0;
        
        let score = 0;
        let lives = 3;
        let gameRunning = true;
        let keys = {};
        let bots = [];
        let buildings = [];
        let curvePoints = [];
        let lastPointIndex = 0;
        let cameraShake = 0;
        
        // Custom models
        let customPlayerModel = null;
        let customBotModel = null;
        
        // Game constants
        const ROAD_LENGTH = 2000; // Length of the road segment we keep in memory
        const SEGMENT_LENGTH = 50; // Distance between curve points
        const NUM_SEGMENTS = Math.ceil(ROAD_LENGTH / SEGMENT_LENGTH);
        const INITIAL_PLAYER_SPEED = 20;
        const MAX_SPEED = 120;
        const ACCELERATION = 0.05;
        const BOT_SPEED = 18;
        
        // Road generation parameters (FIXED)
        const EASY_TURN_MAX = 2.0;    // Maximum lateral offset for easy turns
        const HARD_TURN_MAX = 5.0;    // Maximum lateral offset for hard turns
        const HILL_MAX = 3.0;         // Maximum vertical offset for hills/dips
        
        // ==================== THREE.JS SETUP ====================
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x88aadd, 100, 800);
            
            // Create camera (third-person)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 10, -20);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Create clock for timing
            clock = new THREE.Clock();
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Initialize road curve points
            initRoadCurve();
            
            // Create the road mesh
            createRoad();
            
            // Create player car (default)
            createDefaultPlayerCar();
            
            // Create initial buildings
            createBuildings();
            
            // Create initial bots
            for (let i = 0; i < 3; i++) {
                createDefaultBot(i * 50 + 100);
            }
            
            // Setup GLTF import
            setupGLTFImport();
            
            // Start game loop
            animate();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
        }
        
        // ==================== FIXED PROCEDURAL ROAD GENERATION ====================
        function initRoadCurve() {
            curvePoints = [];
            
            // Create initial straight road segment
            for (let i = 0; i < NUM_SEGMENTS; i++) {
                const z = i * SEGMENT_LENGTH;
                curvePoints.push(new THREE.Vector3(0, 0, z));
            }
            
            lastPointIndex = NUM_SEGMENTS - 1;
            
            // Create the initial curve
            updateRoadCurveGeometry();
        }
        
        function updateRoadCurve() {
            // We'll generate the road ahead based on where the player is
            const playerSegment = Math.floor(playerPosition / SEGMENT_LENGTH);
            const segmentsToGenerate = 15; // Number of segments to generate ahead
            
            // Ensure we have enough curve points ahead of the player
            while (lastPointIndex < playerSegment + segmentsToGenerate) {
                lastPointIndex++;
                
                // Get the last few points for continuity
                const prevIndex = Math.max(0, curvePoints.length - 3);
                const prevPoints = curvePoints.slice(prevIndex);
                
                // Procedural generation parameters
                const t = lastPointIndex * 0.08; // Adjusted frequency
                
                // ==================== HORIZONTAL CURVES (TURNS) ====================
                let curveX = 0;
                
                // Generate different types of turns
                const turnType = Math.floor(t) % 30;
                
                if (turnType >= 0 && turnType < 10) {
                    // EASY TURN: Gentle curves ±2 units max
                    curveX = Math.sin(t * 0.2) * EASY_TURN_MAX;
                } else if (turnType >= 10 && turnType < 15) {
                    // HARD TURN: Sharp curves ±5 units max
                    curveX = Math.sin(t * 0.5) * HARD_TURN_MAX;
                } else {
                    // Straight section with slight variation
                    curveX = Math.sin(t * 0.1) * 1.0;
                }
                
                // ==================== VERTICAL CURVES (HILLS/DIPS/BUMPS) ====================
                let curveY = 0;
                
                const featureType = Math.floor(t * 0.5) % 40;
                
                if (featureType >= 0 && featureType < 8) {
                    // UPHILL: Smooth uphill section
                    const localT = (t * 2) % 1;
                    curveY = localT * HILL_MAX;
                } else if (featureType >= 8 && featureType < 16) {
                    // DOWNHILL: Smooth downhill section
                    const localT = (t * 2) % 1;
                    curveY = (1 - localT) * HILL_MAX;
                } else if (featureType >= 16 && featureType < 20) {
                    // DIP: Short downward curve
                    const localT = (t * 3) % 1;
                    curveY = -Math.sin(localT * Math.PI) * 2.5;
                } else if (featureType >= 20 && featureType < 24) {
                    // SPEED BUMP: Clearly visible bump (1-2 units high, 2-3 segments long)
                    const localT = (t * 0.8) % 1;
                    // Sine curve for smooth rise and fall
                    if (localT < 0.5) {
                        // Rising phase
                        curveY = Math.sin(localT * Math.PI) * 1.5;
                    } else {
                        // Falling phase
                        curveY = Math.sin((1 - localT) * Math.PI) * 1.5;
                    }
                }
                
                // Apply moving average smoothing to prevent abrupt changes
                if (curvePoints.length >= 3) {
                    const prevX = curvePoints[curvePoints.length - 1].x;
                    const prevPrevX = curvePoints[curvePoints.length - 2].x;
                    curveX = (prevPrevX + prevX + curveX) / 3;
                    
                    const prevY = curvePoints[curvePoints.length - 1].y;
                    const prevPrevY = curvePoints[curvePoints.length - 2].y;
                    curveY = (prevPrevY + prevY + curveY) / 3;
                }
                
                // Add small random variation for organic feel
                const randomX = (Math.random() - 0.5) * 0.5;
                const randomY = (Math.random() - 0.5) * 0.3;
                
                // Calculate new point position
                const z = lastPointIndex * SEGMENT_LENGTH;
                const x = curveX + randomX;
                const y = curveY + randomY;
                
                curvePoints.push(new THREE.Vector3(x, y, z));
            }
            
            // Remove points far behind the player to save memory
            const pointsToKeep = 100;
            if (curvePoints.length > pointsToKeep) {
                const removeCount = curvePoints.length - pointsToKeep;
                curvePoints.splice(0, removeCount);
                lastPointIndex -= removeCount;
            }
            
            // Update the road curve geometry
            updateRoadCurveGeometry();
        }
        
        function updateRoadCurveGeometry() {
            // Create the CatmullRom curve from the points
            if (curvePoints.length >= 4) { // CatmullRom needs at least 4 points
                roadCurve = new THREE.CatmullRomCurve3(curvePoints);
                roadCurve.curveType = 'centripetal';
                roadCurve.tension = 0.3; // Lower tension for smoother curves
            }
        }
        
        function createRoad() {
            if (!roadCurve || curvePoints.length < 4) {
                console.log("Road curve not ready yet, waiting...");
                return;
            }
            
            if (roadMesh) {
                scene.remove(roadMesh);
                if (roadMesh.geometry) roadMesh.geometry.dispose();
                if (roadMesh.material) roadMesh.material.dispose();
            }
            
            // Create road geometry by extruding along the curve
            const roadShape = new THREE.Shape();
            const halfWidth = ROAD_WIDTH / 2;
            roadShape.moveTo(-halfWidth, 0);
            roadShape.lineTo(-halfWidth, -0.1);
            roadShape.lineTo(halfWidth, -0.1);
            roadShape.lineTo(halfWidth, 0);
            roadShape.lineTo(-halfWidth, 0);
            
            // Extrude the shape along the curve
            const extrudeSettings = {
                steps: 250, // Higher for smoother curves
                depth: 0.1,
                bevelEnabled: false,
                extrudePath: roadCurve
            };
            
            try {
                const geometry = new THREE.ExtrudeGeometry(roadShape, extrudeSettings);
                
                // Center the geometry
                geometry.center();
                
                // Create road material
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0x333333,
                    side: THREE.DoubleSide
                });
                
                // Create the road mesh
                roadMesh = new THREE.Mesh(geometry, material);
                roadMesh.receiveShadow = true;
                roadMesh.castShadow = false;
                scene.add(roadMesh);
                
                // Add lane markings for 4 lanes
                addLaneMarkings();
            } catch (e) {
                console.error("Error creating road:", e);
                // Retry on next frame
                setTimeout(createRoad, 100);
            }
        }
        
        function addLaneMarkings() {
            if (!roadCurve) return;
            
            // Remove old lane markings
            scene.children.filter(child => child.userData && child.userData.isLaneMarking).forEach(marking => {
                scene.remove(marking);
                if (marking.geometry) marking.geometry.dispose();
                if (marking.material) marking.material.dispose();
            });
            
            // Create dashed lane markings for 4 lanes (3 dividers)
            const laneMarkingMaterial = new THREE.LineDashedMaterial({
                color: 0xffff00,
                dashSize: 3,
                gapSize: 5,
                linewidth: 2
            });
            
            // Lane divider positions: between lanes at -3, 0, 3 (for 12-unit wide road with 4 lanes)
            const dividerOffsets = [-3, 0, 3];
            
            dividerOffsets.forEach(offset => {
                const points = [];
                
                // Generate points along the curve
                for (let i = 0; i <= 100; i++) {
                    const t = i / 100;
                    try {
                        const curvePoint = roadCurve.getPoint(t);
                        const tangent = roadCurve.getTangent(t).normalize();
                        
                        // Calculate perpendicular vector
                        const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                        
                        // Calculate marking position
                        const markingPos = curvePoint.clone().add(perpendicular.multiplyScalar(offset));
                        
                        // Adjust height slightly above road
                        markingPos.y += 0.1;
                        
                        points.push(markingPos);
                    } catch (e) {
                        console.warn("Error getting curve point at t=" + t, e);
                    }
                }
                
                if (points.length > 0) {
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, laneMarkingMaterial);
                    line.computeLineDistances();
                    line.userData = { isLaneMarking: true };
                    scene.add(line);
                }
            });
        }
        
        // ==================== CAR CREATION (DEFAULT AND GLTF) ====================
        function createDefaultPlayerCar() {
            // Create a simple default car if no custom model is loaded
            const carBody = new THREE.BoxGeometry(2.8, 1.2, 5);
            const carMaterial = new THREE.MeshLambertMaterial({ color: 0x2266ff });
            const car = new THREE.Mesh(carBody, carMaterial);
            car.castShadow = true;
            
            // Car top
            const carTop = new THREE.BoxGeometry(2.4, 1, 3);
            const carTopMesh = new THREE.Mesh(carTop, carMaterial);
            carTopMesh.position.y = 0.9;
            carTopMesh.position.z = -0.5;
            carTopMesh.castShadow = true;
            car.add(carTopMesh);
            
            playerCar = new THREE.Group();
            playerCar.add(car);
            playerCar.userData.speed = INITIAL_PLAYER_SPEED;
            playerCar.userData.lane = currentLane;
            
            scene.add(playerCar);
        }
        
        function createDefaultBot(offsetZ) {
            const botBody = new THREE.BoxGeometry(2.8, 1.2, 5);
            const botMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 });
            const bot = new THREE.Mesh(botBody, botMaterial);
            bot.castShadow = true;
            
            // Bot top
            const botTop = new THREE.BoxGeometry(2.4, 1, 3);
            const botTopMesh = new THREE.Mesh(botTop, botMaterial);
            botTopMesh.position.y = 0.9;
            botTopMesh.position.z = -0.5;
            botTopMesh.castShadow = true;
            bot.add(botTopMesh);
            
            const botGroup = new THREE.Group();
            botGroup.add(bot);
            
            // Bot properties - now with lane system
            const laneCenters = [-4.5, -1.5, 1.5, 4.5];
            const randomLane = Math.floor(Math.random() * LANE_COUNT);
            
            botGroup.userData = {
                speed: BOT_SPEED + Math.random() * 5,
                offset: offsetZ,
                lane: randomLane, // 0-3 for 4 lanes
                targetLane: randomLane,
                laneChangeProgress: 0,
                lastLaneChange: 0,
                aggro: Math.random() * 0.5 + 0.5,
                isDefault: true
            };
            
            scene.add(botGroup);
            bots.push(botGroup);
        }
        
        // ==================== GLTF IMPORT SYSTEM ====================
        function setupGLTFImport() {
            const importBtn = document.getElementById('import-btn');
            const playerFileInput = document.getElementById('player-car-file');
            const botFileInput = document.getElementById('bot-car-file');
            const loader = new THREE.GLTFLoader();
            
            importBtn.addEventListener('click', () => {
                // Load player car if file selected
                if (playerFileInput.files.length > 0) {
                    const file = playerFileInput.files[0];
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        const arrayBuffer = e.target.result;
                        
                        loader.parse(
                            arrayBuffer,
                            '',
                            function(gltf) {
                                // Remove existing player car
                                if (playerCar) {
                                    scene.remove(playerCar);
                                    // Clean up old geometry
                                    playerCar.traverse(child => {
                                        if (child.geometry) child.geometry.dispose();
                                        if (child.material) child.material.dispose();
                                    });
                                }
                                
                                // Scale and position the imported model
                                gltf.scene.scale.set(0.5, 0.5, 0.5);
                                gltf.scene.traverse(child => {
                                    if (child.isMesh) {
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                    }
                                });
                                
                                customPlayerModel = gltf.scene;
                                playerCar = new THREE.Group();
                                playerCar.add(gltf.scene);
                                playerCar.userData = {
                                    speed: INITIAL_PLAYER_SPEED,
                                    lane: currentLane,
                                    isCustomModel: true
                                };
                                
                                scene.add(playerCar);
                                console.log("Player car GLTF model loaded successfully");
                            },
                            function(error) {
                                console.error("Error loading player car GLTF:", error);
                                alert("Failed to load player car model. Please check the file format.");
                            }
                        );
                    };
                    
                    reader.readAsArrayBuffer(file);
                }
                
                // Load bot car if file selected
                if (botFileInput.files.length > 0) {
                    const file = botFileInput.files[0];
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        const arrayBuffer = e.target.result;
                        
                        loader.parse(
                            arrayBuffer,
                            '',
                            function(gltf) {
                                customBotModel = gltf.scene;
                                console.log("Bot car GLTF model loaded successfully");
                                
                                // Replace existing bots with new model on next spawn
                                bots.forEach(bot => {
                                    bot.userData.useCustomModel = true;
                                });
                            },
                            function(error) {
                                console.error("Error loading bot car GLTF:", error);
                                alert("Failed to load bot car model. Please check the file format.");
                            }
                        );
                    };
                    
                    reader.readAsArrayBuffer(file);
                }
                
                if (playerFileInput.files.length === 0 && botFileInput.files.length === 0) {
                    alert("Please select at least one GLTF/GLB file to import.");
                }
            });
        }
        
        function createBotWithModel(offsetZ, lane) {
            if (customBotModel) {
                // Clone the custom bot model
                const botModel = customBotModel.clone();
                botModel.scale.set(0.5, 0.5, 0.5);
                botModel.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                const botGroup = new THREE.Group();
                botGroup.add(botModel);
                
                // Bot properties
                const laneCenters = [-4.5, -1.5, 1.5, 4.5];
                
                botGroup.userData = {
                    speed: BOT_SPEED + Math.random() * 5,
                    offset: offsetZ,
                    lane: lane,
                    targetLane: lane,
                    laneChangeProgress: 0,
                    lastLaneChange: 0,
                    aggro: Math.random() * 0.5 + 0.5,
                    isCustomModel: true
                };
                
                scene.add(botGroup);
                bots.push(botGroup);
            } else {
                // Use default bot
                createDefaultBot(offsetZ);
            }
        }
        
        // ==================== FIXED PLAYER CAR WITH LANE SNAPPING ====================
        function updatePlayerCar(deltaTime) {
            if (!gameRunning || !playerCar) return;
            
            // Update player position along the curve
            playerPosition += playerSpeed * deltaTime;
            
            // Update the road curve as player moves forward
            updateRoadCurve();
            
            // Update road mesh periodically
            if (Math.floor(playerPosition) % 300 < 5) {
                createRoad();
                updateLaneDisplay();
            }
            
            // Get player position on curve
            const curveT = (playerPosition % ROAD_LENGTH) / ROAD_LENGTH;
            
            if (!roadCurve) {
                console.warn("Road curve not ready");
                return;
            }
            
            let curvePoint, tangent;
            try {
                curvePoint = roadCurve.getPoint(curveT);
                tangent = roadCurve.getTangent(curveT).normalize();
            } catch (e) {
                console.warn("Error getting road curve point:", e);
                return;
            }
            
            // Calculate perpendicular vector for lane positioning
            const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
            
            // ==================== LANE SNAPPING SYSTEM ====================
            // Calculate lane center positions: [-4.5, -1.5, 1.5, 4.5]
            const laneCenters = [
                -4.5,  // Lane 0 (leftmost)
                -1.5,  // Lane 1
                1.5,   // Lane 2 (start lane)
                4.5    // Lane 3 (rightmost)
            ];
            
            // Handle lane change input
            if ((keys['a'] || keys['A'] || keys['ArrowLeft']) && targetLane > 0) {
                targetLane--;
                keys['a'] = keys['A'] = keys['ArrowLeft'] = false; // Prevent rapid lane changes
            }
            if ((keys['d'] || keys['D'] || keys['ArrowRight']) && targetLane < LANE_COUNT - 1) {
                targetLane++;
                keys['d'] = keys['D'] = keys['ArrowRight'] = false;
            }
            
            // Smooth lane change animation
            if (currentLane !== targetLane) {
                laneChangeProgress += deltaTime * 2;
                if (laneChangeProgress >= 1) {
                    laneChangeProgress = 0;
                    currentLane = targetLane;
                }
            }
            
            // Calculate current lane offset (lerp between lanes during change)
            const currentLaneOffset = laneCenters[currentLane];
            const targetLaneOffset = laneCenters[targetLane];
            const laneOffset = currentLaneOffset + (targetLaneOffset - currentLaneOffset) * laneChangeProgress;
            
            // Clamp lane offset to road width
            const clampedLaneOffset = Math.max(-ROAD_WIDTH/2 + 1.5, Math.min(ROAD_WIDTH/2 - 1.5, laneOffset));
            
            // Calculate car position with lane offset
            const carPosition = curvePoint.clone().add(perpendicular.multiplyScalar(clampedLaneOffset));
            
            // Set car position
            playerCar.position.copy(carPosition);
            
            // Adjust car height based on road curvature
            playerCar.position.y += 1.2; // Height above road
            
            // Rotate car to follow road direction (use tangent vector)
            playerCar.lookAt(playerCar.position.clone().add(tangent));
            
            // Tilt car slightly during turns
            const turnIntensity = perpendicular.dot(new THREE.Vector3(1, 0, 0));
            playerCar.rotation.z = -turnIntensity * 0.08;
            
            // Apply slight tilt on hills
            let roadAhead;
            try {
                roadAhead = roadCurve.getPoint((curveT + 0.02) % 1);
                const verticalChange = roadAhead.y - curvePoint.y;
                playerCar.rotation.x = -verticalChange * 0.05;
            } catch (e) {
                // Silently handle curve point errors
            }
            
            // Update player speed
            if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                playerSpeed = Math.min(playerSpeed + ACCELERATION, MAX_SPEED);
            } else if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                playerSpeed = Math.max(playerSpeed - ACCELERATION * 2, 0);
            } else {
                // Natural deceleration
                playerSpeed = Math.max(playerSpeed - ACCELERATION * 0.1, INITIAL_PLAYER_SPEED);
            }
            
            // Update UI
            document.getElementById('speed').textContent = `SPEED: ${Math.round(playerSpeed)} km/h`;
            document.getElementById('score').textContent = `SCORE: ${Math.round(score)}`;
            document.getElementById('lives').textContent = `LIVES: ${lives}`;
            
            // Update score based on distance
            score += playerSpeed * deltaTime * 0.1;
        }
        
        function updateLaneDisplay() {
            document.getElementById('lane-display').textContent = `LANE: ${currentLane + 1}`;
        }
        
        // ==================== FIXED AI BOTS WITH LANE SYSTEM ====================
        function updateBots(deltaTime) {
            const laneCenters = [-4.5, -1.5, 1.5, 4.5];
            
            for (let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];
                
                // Update bot position along curve
                bot.userData.offset += bot.userData.speed * deltaTime;
                
                // Ensure bot is ahead of player
                if (bot.userData.offset < playerPosition - 100) {
                    bot.userData.offset = playerPosition + 50 + Math.random() * 100;
                    bot.userData.lane = Math.floor(Math.random() * LANE_COUNT);
                    bot.userData.targetLane = bot.userData.lane;
                }
                
                // Get bot position on curve
                const curveT = (bot.userData.offset % ROAD_LENGTH) / ROAD_LENGTH;
                
                if (!roadCurve) continue;
                
                let curvePoint, tangent;
                try {
                    curvePoint = roadCurve.getPoint(curveT);
                    tangent = roadCurve.getTangent(curveT).normalize();
                } catch (e) {
                    continue;
                }
                
                // Calculate perpendicular vector for lane positioning
                const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // Bot lane changing logic
                bot.userData.lastLaneChange += deltaTime;
                
                // Occasionally change lanes
                if (bot.userData.lastLaneChange > 4 && Math.random() < 0.01) {
                    // Try to match player's lane if aggressive and nearby
                    if (Math.random() < bot.userData.aggro) {
                        const distanceToPlayer = bot.userData.offset - playerPosition;
                        if (distanceToPlayer > 0 && distanceToPlayer < 80) {
                            bot.userData.targetLane = targetLane;
                        } else {
                            // Random lane change
                            const newLane = Math.floor(Math.random() * LANE_COUNT);
                            if (newLane !== bot.userData.lane) {
                                bot.userData.targetLane = newLane;
                            }
                        }
                    } else {
                        // Random lane change
                        const newLane = Math.floor(Math.random() * LANE_COUNT);
                        if (newLane !== bot.userData.lane) {
                            bot.userData.targetLane = newLane;
                        }
                    }
                    bot.userData.lastLaneChange = 0;
                }
                
                // Smooth lane change for bot
                if (bot.userData.lane !== bot.userData.targetLane) {
                    bot.userData.laneChangeProgress += deltaTime;
                    if (bot.userData.laneChangeProgress >= 1) {
                        bot.userData.laneChangeProgress = 0;
                        bot.userData.lane = bot.userData.targetLane;
                    }
                }
                
                // Calculate bot lane position
                const currentLaneOffset = laneCenters[bot.userData.lane];
                const targetLaneOffset = laneCenters[bot.userData.targetLane];
                const laneOffset = currentLaneOffset + (targetLaneOffset - currentLaneOffset) * bot.userData.laneChangeProgress;
                
                // Clamp lane offset
                const clampedLaneOffset = Math.max(-ROAD_WIDTH/2 + 1.5, Math.min(ROAD_WIDTH/2 - 1.5, laneOffset));
                
                // Calculate bot position
                const botPosition = curvePoint.clone().add(perpendicular.multiplyScalar(clampedLaneOffset));
                
                // Set bot position
                bot.position.copy(botPosition);
                bot.position.y += 1.2;
                
                // Rotate bot to follow road
                bot.lookAt(bot.position.clone().add(tangent));
                
                // Check for collision with player
                const distanceToPlayer = Math.abs(bot.userData.offset - playerPosition);
                const lateralDistance = Math.abs(laneOffset - (laneCenters[currentLane] + (laneCenters[targetLane] - laneCenters[currentLane]) * laneChangeProgress));
                
                if (distanceToPlayer < 4 && lateralDistance < 2.0) {
                    // Collision detected
                    handleCollision();
                    // Remove the bot after collision
                    scene.remove(bot);
                    bots.splice(i, 1);
                    
                    // Create a new bot ahead with appropriate model
                    const lane = Math.floor(Math.random() * LANE_COUNT);
                    createBotWithModel(playerPosition + 100 + Math.random() * 100, lane);
                }
                
                // Remove bots that are too far behind
                if (bot.userData.offset < playerPosition - 200) {
                    scene.remove(bot);
                    bots.splice(i, 1);
                }
            }
            
            // Add new bots as score increases
            const targetBotCount = 3 + Math.floor(score / 1000);
            if (bots.length < targetBotCount) {
                const lane = Math.floor(Math.random() * LANE_COUNT);
                createBotWithModel(playerPosition + 100 + Math.random() * 200, lane);
            }
        }
        
        // ==================== FIXED CAMERA SYSTEM ====================
        function updateCamera(deltaTime) {
            if (!playerCar || !roadCurve) return;
            
            // Get player position on curve
            const curveT = (playerPosition % ROAD_LENGTH) / ROAD_LENGTH;
            
            let curvePoint, tangent;
            try {
                curvePoint = roadCurve.getPoint(curveT);
                tangent = roadCurve.getTangent(curveT).normalize();
            } catch (e) {
                return;
            }
            
            // Calculate perpendicular vector
            const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
            
            // Calculate current lane offset
            const laneCenters = [-4.5, -1.5, 1.5, 4.5];
            const currentLaneOffset = laneCenters[currentLane];
            const targetLaneOffset = laneCenters[targetLane];
            const laneOffset = currentLaneOffset + (targetLaneOffset - currentLaneOffset) * laneChangeProgress;
            
            // Calculate car position
            const carPosition = curvePoint.clone().add(perpendicular.multiplyScalar(laneOffset));
            
            // Camera offset: behind and above the car, following tangent direction
            const cameraOffset = new THREE.Vector3(0, 6, -18);
            
            // Apply camera rotation to follow road direction
            const cameraQuaternion = new THREE.Quaternion();
            cameraQuaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), tangent);
            cameraOffset.applyQuaternion(cameraQuaternion);
            
            // Add slight horizontal offset based on lane
            cameraOffset.x += laneOffset * 0.1;
            
            // Apply camera shake from bumps and dips
            if (cameraShake > 0) {
                cameraOffset.x += (Math.random() - 0.5) * cameraShake;
                cameraOffset.y += (Math.random() - 0.5) * cameraShake * 0.5;
                cameraShake *= 0.8; // Dampen shake over time
            }
            
            // Target camera position
            const targetPosition = carPosition.clone().add(cameraOffset);
            targetPosition.y += 4; // Additional height
            
            // Smooth camera movement (lerp)
            camera.position.lerp(targetPosition, 0.1);
            
            // Make camera look ahead along the road tangent
            const lookAtPosition = carPosition.clone().add(tangent.multiplyScalar(40));
            lookAtPosition.y += 2;
            camera.lookAt(lookAtPosition);
            
            // Detect road features for camera shake
            let roadAhead;
            try {
                roadAhead = roadCurve.getPoint((curveT + 0.01) % 1);
                const verticalChange = Math.abs(roadAhead.y - curvePoint.y);
                
                if (verticalChange > 0.8) {
                    cameraShake = verticalChange * 0.3;
                }
            } catch (e) {
                // Silently handle
            }
        }
        
        // ==================== BUILDINGS ====================
        function createBuildings() {
            // Remove old buildings
            buildings.forEach(building => {
                scene.remove(building);
                if (building.geometry) building.geometry.dispose();
                if (building.material) building.material.dispose();
            });
            buildings = [];
            
            if (!roadCurve) return;
            
            // Create buildings along the road
            for (let i = 0; i < 40; i++) {
                // Get position along curve
                const t = i / 40;
                let curvePoint, tangent;
                try {
                    curvePoint = roadCurve.getPoint(t);
                    tangent = roadCurve.getTangent(t).normalize();
                } catch (e) {
                    continue;
                }
                
                // Calculate perpendicular vector
                const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // Create buildings on both sides of the road
                for (let side = -1; side <= 1; side += 2) {
                    // Random distance from road
                    const distance = 20 + Math.random() * 30;
                    
                    // Calculate building position
                    const buildingPos = curvePoint.clone().add(
                        perpendicular.multiplyScalar(side * (ROAD_WIDTH/2 + distance))
                    );
                    
                    // Random building size
                    const width = 5 + Math.random() * 10;
                    const height = 10 + Math.random() * 30;
                    const depth = 5 + Math.random() * 10;
                    
                    // Create building geometry
                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    
                    // Random building color
                    const hue = Math.random() * 0.1 + 0.5;
                    const color = new THREE.Color().setHSL(hue, 0.3, 0.3 + Math.random() * 0.2);
                    
                    const buildingMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    
                    // Position building
                    building.position.copy(buildingPos);
                    building.position.y = height / 2;
                    
                    // Add some rotation for variety
                    building.rotation.y = Math.random() * Math.PI;
                    
                    building.castShadow = true;
                    building.receiveShadow = true;
                    
                    scene.add(building);
                    buildings.push(building);
                }
            }
        }
        
        // ==================== GAME LOGIC ====================
        function handleCollision() {
            lives--;
            cameraShake = 1.5; // Camera shake on collision
            
            // Slow down after collision
            playerSpeed *= 0.6;
            
            if (lives <= 0) {
                gameOver();
            }
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('final-score').textContent = `Final Score: ${Math.round(score)}`;
            document.getElementById('game-over').style.display = 'block';
        }
        
        function restartGame() {
            // Reset game state
            playerPosition = 0;
            playerSpeed = INITIAL_PLAYER_SPEED;
            targetLane = 2;
            currentLane = 2;
            laneChangeProgress = 0;
            score = 0;
            lives = 3;
            gameRunning = true;
            cameraShake = 0;
            
            // Remove all bots
            bots.forEach(bot => {
                scene.remove(bot);
                bot.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            });
            bots = [];
            
            // Remove all buildings
            buildings.forEach(building => {
                scene.remove(building);
                if (building.geometry) building.geometry.dispose();
                if (building.material) building.material.dispose();
            });
            buildings = [];
            
            // Reinitialize road
            lastPointIndex = 0;
            initRoadCurve();
            createRoad();
            
            // Create new bots with appropriate models
            for (let i = 0; i < 3; i++) {
                const lane = Math.floor(Math.random() * LANE_COUNT);
                createBotWithModel(i * 50 + 100, lane);
            }
            
            // Create new buildings
            createBuildings();
            
            // Update lane display
            updateLaneDisplay();
            
            // Hide game over screen
            document.getElementById('game-over').style.display = 'none';
        }
        
        // ==================== INPUT HANDLING ====================
        function setupInput() {
            // Keyboard input
            document.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Restart button
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // ==================== GAME LOOP ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min(clock.getDelta(), 0.033);
            
            if (gameRunning) {
                updatePlayerCar(deltaTime);
                updateBots(deltaTime);
                updateCamera(deltaTime);
            }
            
            renderer.render(scene, camera);
        }
        
        // ==================== START GAME ====================
        window.addEventListener('load', () => {
            init();
            setupInput();
            updateLaneDisplay();
        });
    </script>
</body>
</html>
