<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cell Block Zero - Cooperative Prison Escape</title>
    
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load GLTFLoader for 3D models -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <style>
        /* Keep all the existing CSS styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            user-select: none;
        }

        body {
            background: #0a0a0a;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        /* ... (keep ALL existing CSS styles exactly as they were) ... */

        /* Add realistic cell style */
        .real-cell {
            background: linear-gradient(45deg, #333, #555);
            border: 5px solid #222;
            border-radius: 3px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }

        .real-guard {
            background: linear-gradient(to bottom, #1a2b5f, #0d1b4d);
            border-radius: 25px 25px 10px 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        .real-inmate {
            background: linear-gradient(to bottom, #8b0000, #660000);
            border-radius: 20px 20px 8px 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.4);
        }

        /* Real prison elements */
        .prison-bar {
            background: linear-gradient(to right, #666, #888, #666);
            width: 4px;
            position: absolute;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .security-camera {
            background: radial-gradient(circle, #333, #000);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            position: absolute;
            border: 2px solid #444;
        }

        .camera-light {
            background: radial-gradient(circle, #ff0000, #cc0000);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            position: absolute;
            top: 5px;
            left: 5px;
            animation: camera-pulse 2s infinite;
        }

        @keyframes camera-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Realistic UI improvements */
        .real-ui-box {
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(20,0,0,0.95));
            border: 3px solid #444;
            border-radius: 5px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8),
                        inset 0 0 20px rgba(255,0,0,0.1);
        }

        .real-button {
            background: linear-gradient(to bottom, #333, #222);
            border: 2px solid #555;
            color: #ddd;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }

        .real-button:hover {
            background: linear-gradient(to bottom, #444, #333);
            border-color: #777;
        }

        /* Add realistic textures in loading */
        .loading-bar {
            width: 300px;
            height: 20px;
            background: #222;
            border: 2px solid #444;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px auto;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #cc0000);
            transition: width 0.3s;
        }

        /* Keep all existing responsive and animation styles */
    </style>
</head>
<body>
    <!-- Keep ALL existing HTML structure exactly as it was -->
    
    <script>
        // ============================================================================
        // FIXED: MISSING FUNCTIONS
        // ============================================================================

        function updateBot(data) {
            // Update bot state from network
            const { index, alertLevel, position, patrolIndex } = data;
            
            if (gameState.bots[index]) {
                if (alertLevel !== undefined) {
                    gameState.bots[index].alertLevel = alertLevel;
                }
                if (position) {
                    gameState.bots[index].position = position;
                }
                if (patrolIndex !== undefined) {
                    gameState.bots[index].patrolIndex = patrolIndex;
                }
                
                // Update visual if bot is chasing (red color)
                if (botMeshes[index]) {
                    if (alertLevel > 30) {
                        botMeshes[index].material.color.setHex(0xff0000);
                    } else {
                        botMeshes[index].material.color.setHex(0x0000ff);
                    }
                }
            }
        }

        function updatePlayerUI(playerNum, player) {
            const num = playerNum === 1 ? '1' : '2';
            const healthElement = document.getElementById(`health${num}`);
            const healthBarElement = document.getElementById(`healthBar${num}`);
            const contrabandElement = document.getElementById(`contraband${num}`);
            const repElement = document.getElementById(`rep${num}`);
            const posElement = document.getElementById(`pos${num}`);
            
            if (healthElement) healthElement.textContent = Math.max(0, player.health);
            if (healthBarElement) {
                healthBarElement.style.width = `${Math.max(0, player.health)}%`;
                // Change color based on health
                if (player.health < 30) {
                    healthBarElement.style.background = 'linear-gradient(to right, #ff0000, #990000)';
                } else if (player.health < 70) {
                    healthBarElement.style.background = 'linear-gradient(to right, #ff9900, #cc6600)';
                } else {
                    healthBarElement.style.background = 'linear-gradient(to right, #00ff00, #009900)';
                }
            }
            if (contrabandElement) contrabandElement.textContent = player.contraband;
            if (repElement) repElement.textContent = player.reputation;
            
            if (posElement && player.position) {
                posElement.textContent = 
                    `Cell ${Math.floor((player.position.x + 50) / 10)}-${Math.floor((player.position.z + 50) / 10)}`;
            }
        }

        function toggleInventory() {
            const inventory = document.getElementById('inventory');
            if (inventory.style.display === 'block') {
                inventory.style.display = 'none';
            } else {
                inventory.style.display = 'block';
                updateInventoryUI();
            }
        }

        function attemptInteraction() {
            if (!playerMesh) return;
            
            const player = gameState.players[gameState.playerId];
            
            // Check for nearby items
            itemMeshes.forEach((item, index) => {
                if (item && !item.userData.collected) {
                    const distance = playerMesh.position.distanceTo(item.position);
                    if (distance < 2) {
                        collectItem(item.userData.type, index);
                        return;
                    }
                }
            });
            
            // Check for bots to interact with
            gameState.bots.forEach((bot, index) => {
                if (bot.position) {
                    const dx = playerMesh.position.x - bot.position.x;
                    const dz = playerMesh.position.z - bot.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 3) {
                        if (bot.type === 'guard') {
                            const player = gameState.players[gameState.playerId];
                            if (player.inventory.includes('donut')) {
                                // Bribe guard with donut
                                player.reputation += 10;
                                player.inventory = player.inventory.filter(i => i !== 'donut');
                                bot.alertLevel = Math.max(0, bot.alertLevel - 30);
                                updateInventoryUI();
                                showMessage('Guard bribed with donut! Reputation +10', 'success');
                                
                                // Send bot update to partner
                                sendNetworkMessage('botUpdate', { index, alertLevel: bot.alertLevel });
                            } else if (player.inventory.includes('cigarettes')) {
                                // Bribe guard with cigarettes
                                player.reputation += 5;
                                player.inventory = player.inventory.filter(i => i !== 'cigarettes');
                                bot.alertLevel = Math.max(0, bot.alertLevel - 15);
                                updateInventoryUI();
                                showMessage('Guard bribed with cigarettes! Reputation +5', 'success');
                                
                                sendNetworkMessage('botUpdate', { index, alertLevel: bot.alertLevel });
                            } else {
                                // Random guard interaction
                                const responses = [
                                    "Keep moving, inmate!",
                                    "No loitering!",
                                    "Back to your cell!",
                                    "What are you looking at?"
                                ];
                                showMessage(`Guard: "${responses[Math.floor(Math.random() * responses.length)]}"`, 'warning');
                            }
                        } else if (bot.type === 'inmate') {
                            tradeWithInmate(bot.personality);
                        }
                    }
                }
            });
            
            // Check for escape points
            checkEscapePoints();
        }

        function checkEscapePoints() {
            if (!playerMesh) return;
            
            const player = gameState.players[gameState.playerId];
            
            // Check if near prison walls for tunnel escape
            const halfSize = CONFIG.PRISON_SIZE / 2;
            if (Math.abs(playerMesh.position.x) > halfSize - 5 || 
                Math.abs(playerMesh.position.z) > halfSize - 5) {
                if (player.inventory.includes('shovel')) {
                    showMessage("Press M to access escape menu (near wall with shovel)", 'info');
                }
            }
            
            // Check if near main gate for disguise escape
            if (Math.abs(playerMesh.position.x) < 10 && playerMesh.position.z > halfSize - 10) {
                if (player.inventory.includes('uniform') && player.inventory.includes('idcard')) {
                    showMessage("Press M to access escape menu (at main gate with uniform)", 'info');
                }
            }
        }

        // ============================================================================
        // ENHANCED: REALISTIC PRISON GENERATION
        // ============================================================================

        function generateRealisticPrison(seed = Date.now()) {
            console.log('Generating realistic prison with seed:', seed);
            
            const rng = new SeededRandom(seed);
            
            // Clear existing objects
            clearSceneObjects();
            
            // Generate realistic prison layout
            generatePrisonWalls();
            generateCellBlocks(rng);
            generatePrisonFacilities(rng);
            generateRealisticItems(rng);
            generateRealisticBots(rng);
            generateSecurityFeatures(rng);
            
            console.log('Realistic prison generated with', gameState.items.length, 'items and', gameState.bots.length, 'bots');
        }

        function generatePrisonWalls() {
            const wallHeight = 10;
            const wallThickness = 3;
            const halfSize = CONFIG.PRISON_SIZE / 2;
            
            // Outer walls with barbed wire
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            });
            
            const walls = [
                { pos: [0, wallHeight/2, -halfSize], size: [CONFIG.PRISON_SIZE, wallHeight, wallThickness] },
                { pos: [0, wallHeight/2, halfSize], size: [CONFIG.PRISON_SIZE, wallHeight, wallThickness] },
                { pos: [halfSize, wallHeight/2, 0], size: [wallThickness, wallHeight, CONFIG.PRISON_SIZE] },
                { pos: [-halfSize, wallHeight/2, 0], size: [wallThickness, wallHeight, CONFIG.PRISON_SIZE] }
            ];
            
            walls.forEach(wall => {
                const geometry = new THREE.BoxGeometry(...wall.size);
                const mesh = new THREE.Mesh(geometry, wallMaterial);
                mesh.position.set(...wall.pos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { type: 'wall' };
                scene.add(mesh);
                wallMeshes.push(mesh);
            });
            
            // Add barbed wire on top of walls
            const barbedWireMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                roughness: 0.3,
                metalness: 0.7
            });
            
            for (let i = -halfSize + 10; i < halfSize - 10; i += 5) {
                // North and south walls
                const barbedNorth = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 2, 6),
                    barbedWireMaterial
                );
                barbedNorth.position.set(i, wallHeight + 1, -halfSize + 1);
                scene.add(barbedNorth);
                wallMeshes.push(barbedNorth);
                
                const barbedSouth = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 2, 6),
                    barbedWireMaterial
                );
                barbedSouth.position.set(i, wallHeight + 1, halfSize - 1);
                scene.add(barbedSouth);
                wallMeshes.push(barbedSouth);
                
                // East and west walls
                const barbedEast = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 2, 6),
                    barbedWireMaterial
                );
                barbedEast.position.set(halfSize - 1, wallHeight + 1, i);
                scene.add(barbedEast);
                wallMeshes.push(barbedEast);
                
                const barbedWest = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 2, 6),
                    barbedWireMaterial
                );
                barbedWest.position.set(-halfSize + 1, wallHeight + 1, i);
                scene.add(barbedWest);
                wallMeshes.push(barbedWest);
            }
            
            // Main gate
            const gateMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.4,
                metalness: 0.6
            });
            
            const gate = new THREE.Mesh(
                new THREE.BoxGeometry(20, wallHeight, 1),
                gateMaterial
            );
            gate.position.set(0, wallHeight/2, halfSize - 1);
            scene.add(gate);
            wallMeshes.push(gate);
        }

        function generateCellBlocks(rng) {
            const cellMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a,
                roughness: 0.7,
                metalness: 0.1
            });
            
            const cellBlockCount = 4;
            const cellsPerBlock = 8;
            
            for (let block = 0; block < cellBlockCount; block++) {
                const blockX = (block - 1.5) * 25;
                
                for (let cell = 0; cell < cellsPerBlock; cell++) {
                    const cellZ = (cell - 3.5) * 8;
                    
                    // Cell structure
                    const cellGeometry = new THREE.BoxGeometry(6, 4, 5);
                    const cellMesh = new THREE.Mesh(cellGeometry, cellMaterial);
                    cellMesh.position.set(blockX, 2, cellZ);
                    cellMesh.castShadow = true;
                    cellMesh.receiveShadow = true;
                    cellMesh.userData = { type: 'cell', block: block, cell: cell };
                    scene.add(cellMesh);
                    wallMeshes.push(cellMesh);
                    
                    // Cell door
                    const doorMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x444444,
                        roughness: 0.5,
                        metalness: 0.3
                    });
                    
                    const door = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 3, 0.2),
                        doorMaterial
                    );
                    door.position.set(blockX + 3, 1.5, cellZ);
                    door.rotation.y = rng.next() > 0.5 ? Math.PI/2 : -Math.PI/2;
                    scene.add(door);
                    wallMeshes.push(door);
                    
                    // Cell bed
                    const bedMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513,
                        roughness: 0.9
                    });
                    
                    const bed = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 0.5, 2),
                        bedMaterial
                    );
                    bed.position.set(blockX - 1, 0.25, cellZ);
                    scene.add(bed);
                    wallMeshes.push(bed);
                }
            }
            
            // Prison yard
            const yardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228822,
                roughness: 0.9,
                metalness: 0
            });
            
            const yard = new THREE.Mesh(
                new THREE.PlaneGeometry(60, 60),
                yardMaterial
            );
            yard.rotation.x = -Math.PI / 2;
            yard.position.set(0, 0.1, 0);
            yard.receiveShadow = true;
            scene.add(yard);
        }

        function generatePrisonFacilities(rng) {
            // Cafeteria
            const cafeteriaMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                roughness: 0.6
            });
            
            const cafeteria = new THREE.Mesh(
                new THREE.BoxGeometry(20, 5, 15),
                cafeteriaMaterial
            );
            cafeteria.position.set(-35, 2.5, -30);
            scene.add(cafeteria);
            wallMeshes.push(cafeteria);
            
            // Kitchen
            const kitchen = new THREE.Mesh(
                new THREE.BoxGeometry(10, 4, 10),
                cafeteriaMaterial
            );
            kitchen.position.set(-45, 2, -30);
            scene.add(kitchen);
            wallMeshes.push(kitchen);
            
            // Infirmary
            const infirmaryMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.7
            });
            
            const infirmary = new THREE.Mesh(
                new THREE.BoxGeometry(15, 4, 12),
                infirmaryMaterial
            );
            infirmary.position.set(35, 2, -30);
            scene.add(infirmary);
            wallMeshes.push(infirmary);
            
            // Library
            const libraryMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8
            });
            
            const library = new THREE.Mesh(
                new THREE.BoxGeometry(12, 4, 15),
                libraryMaterial
            );
            library.position.set(35, 2, 30);
            scene.add(library);
            wallMeshes.push(library);
            
            // Guard towers
            const towerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.5
            });
            
            const towerPositions = [
                [-45, 0, -45], [45, 0, -45],
                [-45, 0, 45], [45, 0, 45]
            ];
            
            towerPositions.forEach(pos => {
                const towerBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 4, 15, 8),
                    towerMaterial
                );
                towerBase.position.set(pos[0], 7.5, pos[2]);
                scene.add(towerBase);
                wallMeshes.push(towerBase);
                
                const towerTop = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 4, 6),
                    towerMaterial
                );
                towerTop.position.set(pos[0], 17, pos[2]);
                scene.add(towerTop);
                wallMeshes.push(towerTop);
            });
        }

        function generateRealisticItems(rng) {
            const realisticItems = [
                { id: 'shovel', name: 'Shovel', color: 0x8B4513, icon: 'ðŸªš', 
                  locations: ['yard', 'storage'], size: [0.3, 2, 0.1] },
                { id: 'uniform', name: 'Guard Uniform', color: 0x0000ff, icon: 'ðŸ‘•',
                  locations: ['guardroom', 'laundry'], size: [1, 1.5, 0.3] },
                { id: 'idcard', name: 'ID Card', color: 0xffff00, icon: 'ðŸªª',
                  locations: ['office', 'guardroom'], size: [0.3, 0.2, 0.05] },
                { id: 'cigarettes', name: 'Cigarettes', color: 0xf5f5f5, icon: 'ðŸš¬',
                  locations: ['yard', 'cell'], size: [0.5, 0.1, 0.2] },
                { id: 'donut', name: 'Donut', color: 0xff69b4, icon: 'ðŸ©',
                  locations: ['cafeteria', 'guardroom'], size: [0.3, 0.1, 0.3] },
                { id: 'key', name: 'Key', color: 0xffd700, icon: 'ðŸ”‘',
                  locations: ['guardroom', 'office'], size: [0.1, 0.3, 0.05] },
                { id: 'crowbar', name: 'Crowbar', color: 0x808080, icon: 'ðŸ”§',
                  locations: ['workshop', 'storage'], size: [0.2, 1.5, 0.2] },
                { id: 'rope', name: 'Rope', color: 0x8B4513, icon: 'ðŸª¢',
                  locations: ['workshop', 'storage'], size: [0.5, 0.5, 0.5] },
                { id: 'wirecutters', name: 'Wire Cutters', color: 0x444444, icon: 'âœ‚ï¸',
                  locations: ['workshop'], size: [0.3, 0.1, 0.1] },
                { id: 'flashlight', name: 'Flashlight', color: 0x333333, icon: 'ðŸ”¦',
                  locations: ['storage'], size: [0.2, 0.8, 0.2] }
            ];
            
            // Define realistic locations
            const locationPositions = {
                yard: { minX: -30, maxX: 30, minZ: -30, maxZ: 30 },
                storage: { x: -40, z: 0 },
                guardroom: { x: 0, z: 40 },
                laundry: { x: -40, z: 20 },
                office: { x: 0, z: -40 },
                workshop: { x: 40, z: 0 },
                cafeteria: { x: -35, z: -30 },
                cell: { minX: -50, maxX: 50, minZ: -20, maxZ: 20 }
            };
            
            realisticItems.forEach((itemType, index) => {
                let x, z;
                const location = rng.choice(itemType.locations);
                const loc = locationPositions[location];
                
                if (loc.minX !== undefined) {
                    // Area location
                    x = rng.range(loc.minX, loc.maxX);
                    z = rng.range(loc.minZ, loc.maxZ);
                } else {
                    // Specific location with some randomness
                    x = loc.x + rng.range(-5, 5);
                    z = loc.z + rng.range(-5, 5);
                }
                
                const geometry = new THREE.BoxGeometry(...itemType.size);
                const material = new THREE.MeshStandardMaterial({ 
                    color: itemType.color,
                    roughness: 0.5,
                    metalness: itemType.id === 'key' || itemType.id === 'crowbar' ? 0.8 : 0.3
                });
                
                const item = new THREE.Mesh(geometry, material);
                item.position.set(x, 1, z);
                item.rotation.y = rng.range(0, Math.PI * 2);
                item.castShadow = true;
                item.userData = {
                    type: itemType.id,
                    collected: false,
                    index: index,
                    location: location
                };
                
                // Add glow for important items
                if (itemType.id === 'key' || itemType.id === 'idcard') {
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: itemType.color,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glow = new THREE.Mesh(
                        new THREE.BoxGeometry(itemType.size[0] * 1.5, itemType.size[1] * 1.5, itemType.size[2] * 1.5),
                        glowMaterial
                    );
                    item.add(glow);
                }
                
                scene.add(item);
                itemMeshes.push(item);
                
                gameState.items.push({
                    type: itemType.id,
                    position: { x, y: 1, z },
                    collected: false,
                    location: location
                });
            });
        }

        function generateRealisticBots(rng) {
            // Guard bots with different ranks
            const guardTypes = [
                { rank: 'rookie', color: 0x1a2b5f, speed: 0.04, alertness: 0.7 },
                { rank: 'regular', color: 0x0d1b4d, speed: 0.03, alertness: 0.8 },
                { rank: 'sergeant', color: 0x000033, speed: 0.025, alertness: 0.9 },
                { rank: 'captain', color: 0x000022, speed: 0.02, alertness: 1.0 }
            ];
            
            for (let i = 0; i < CONFIG.GUARD_COUNT; i++) {
                const guardType = guardTypes[Math.floor(rng.next() * guardTypes.length)];
                const x = rng.range(-40, 40);
                const z = rng.range(-40, 40);
                
                // Guard body
                const bodyGeometry = new THREE.CylinderGeometry(0.7, 0.7, 2, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: guardType.color,
                    roughness: 0.3,
                    metalness: 0.2
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                // Guard head
                const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xf0c8a0,
                    roughness: 0.8
                });
                
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.5;
                
                // Guard hat (for higher ranks)
                if (guardType.rank === 'sergeant' || guardType.rank === 'captain') {
                    const hatGeometry = new THREE.CylinderGeometry(0.6, 0.8, 0.3, 8);
                    const hatMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x000000,
                        roughness: 0.5
                    });
                    const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                    hat.position.y = 0.7;
                    head.add(hat);
                }
                
                const guard = new THREE.Group();
                guard.add(body);
                guard.add(head);
                guard.position.set(x, 1, z);
                guard.castShadow = true;
                scene.add(guard);
                botMeshes.push(guard);
                
                // Generate patrol route
                const patrolPath = [];
                const patrolPoints = 4 + Math.floor(rng.next() * 3);
                for (let j = 0; j < patrolPoints; j++) {
                    patrolPath.push({
                        x: x + rng.range(-15, 15),
                        z: z + rng.range(-15, 15)
                    });
                }
                
                gameState.bots.push({
                    type: 'guard',
                    rank: guardType.rank,
                    position: { x, y: 1, z },
                    patrolPath,
                    patrolIndex: 0,
                    alertLevel: 0,
                    alertness: guardType.alertness,
                    speed: guardType.speed,
                    visionRange: 15 + (guardType.alertness * 5),
                    lastDetectionCheck: 0
                });
            }
            
            // Inmate bots with different personalities
            const inmateTypes = [
                { personality: 'lazy', color: 0x8b0000, activityChance: 0.1 },
                { personality: 'violent', color: 0x660000, activityChance: 0.3 },
                { personality: 'helpful', color: 0x00aa00, activityChance: 0.5 },
                { personality: 'loner', color: 0x550000, activityChance: 0.2 },
                { personality: 'schemer', color: 0x770000, activityChance: 0.4 }
            ];
            
            for (let i = 0; i < CONFIG.INMATE_BOT_COUNT; i++) {
                const inmateType = inmateTypes[Math.floor(rng.next() * inmateTypes.length)];
                const x = rng.range(-35, 35);
                const z = rng.range(-35, 35);
                
                const inmateGeometry = new THREE.BoxGeometry(1, 2, 1);
                const inmateMaterial = new THREE.MeshStandardMaterial({ 
                    color: inmateType.color,
                    roughness: 0.7,
                    metalness: 0
                });
                
                const inmate = new THREE.Mesh(inmateGeometry, inmateMaterial);
                inmate.position.set(x, 1, z);
                inmate.castShadow = true;
                scene.add(inmate);
                botMeshes.push(inmate);
                
                gameState.bots.push({
                    type: 'inmate',
                    personality: inmateType.personality,
                    position: { x, y: 1, z },
                    speed: 0.01 + rng.next() * 0.02,
                    activity: 'idle',
                    activityChance: inmateType.activityChance,
                    lastActivityChange: 0,
                    interactionCooldown: 0
                });
            }
        }

        function generateSecurityFeatures(rng) {
            // Security cameras
            const cameraMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.2,
                metalness: 0.8
            });
            
            const cameraPositions = [
                { x: 0, z: -45, y: 8, rotation: 0 },
                { x: 0, z: 45, y: 8, rotation: Math.PI },
                { x: -45, z: 0, y: 8, rotation: Math.PI/2 },
                { x: 45, z: 0, y: 8, rotation: -Math.PI/2 },
                { x: 25, z: 25, y: 6, rotation: -Math.PI/4 },
                { x: -25, z: -25, y: 6, rotation: Math.PI/4 }
            ];
            
            cameraPositions.forEach((pos, index) => {
                const cameraGeometry = new THREE.BoxGeometry(1, 1, 1);
                const camera = new THREE.Mesh(cameraGeometry, cameraMaterial);
                camera.position.set(pos.x, pos.y, pos.z);
                camera.rotation.y = pos.rotation;
                
                // Camera lens
                const lensGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.2, 8);
                const lensMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.3
                });
                const lens = new THREE.Mesh(lensGeometry, lensMaterial);
                lens.position.z = 0.6;
                lens.rotation.x = Math.PI/2;
                camera.add(lens);
                
                scene.add(camera);
                wallMeshes.push(camera);
                
                // Add camera sweep animation
                gameState.cameras = gameState.cameras || [];
                gameState.cameras.push({
                    mesh: camera,
                    baseRotation: pos.rotation,
                    sweepRange: Math.PI/2,
                    sweepSpeed: 0.5 + rng.next() * 0.5,
                    timeOffset: rng.next() * Math.PI * 2
                });
            });
            
            // Security lights
            const lightTowers = [
                { x: -30, z: -30 }, { x: 30, z: -30 },
                { x: -30, z: 30 }, { x: 30, z: 30 }
            ];
            
            lightTowers.forEach(pos => {
                const towerGeometry = new THREE.CylinderGeometry(0.5, 1, 8, 6);
                const towerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    roughness: 0.4
                });
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.set(pos.x, 4, pos.z);
                scene.add(tower);
                wallMeshes.push(tower);
                
                // Light fixture
                const lightGeometry = new THREE.SphereGeometry(1, 8, 8);
                const lightMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffcc,
                    emissive: 0xffff99,
                    emissiveIntensity: 0.5
                });
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.set(0, 5, 0);
                tower.add(light);
                
                // Add point light
                const pointLight = new THREE.PointLight(0xffff99, 1, 30);
                pointLight.position.set(pos.x, 9, pos.z);
                scene.add(pointLight);
            });
        }

        function clearSceneObjects() {
            // Helper function to clear all scene objects
            if (wallMeshes) {
                wallMeshes.forEach(mesh => {
                    if (mesh && mesh.parent) {
                        scene.remove(mesh);
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) {
                            if (Array.isArray(mesh.material)) {
                                mesh.material.forEach(m => m.dispose());
                            } else {
                                mesh.material.dispose();
                            }
                        }
                    }
                });
            }
            
            if (itemMeshes) {
                itemMeshes.forEach(mesh => {
                    if (mesh && mesh.parent) {
                        scene.remove(mesh);
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                    }
                });
            }
            
            if (botMeshes) {
                botMeshes.forEach(mesh => {
                    if (mesh && mesh.parent) {
                        scene.remove(mesh);
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) {
                            if (Array.isArray(mesh.material)) {
                                mesh.material.forEach(m => m.dispose());
                            } else {
                                mesh.material.dispose();
                            }
                        }
                    }
                });
            }
            
            wallMeshes = [];
            itemMeshes = [];
            botMeshes = [];
            gameState.items = [];
            gameState.bots = [];
            gameState.cameras = [];
        }

        // ============================================================================
        // ENHANCED: REALISTIC BOT AI
        // ============================================================================

        function updateRealisticBots(deltaTime) {
            const currentTime = Date.now();
            
            gameState.bots.forEach((bot, index) => {
                if (!botMeshes[index]) return;
                
                const mesh = botMeshes[index];
                
                if (bot.type === 'guard') {
                    updateGuardBot(bot, mesh, deltaTime, currentTime);
                } else if (bot.type === 'inmate') {
                    updateInmateBot(bot, mesh, deltaTime, currentTime);
                }
                
                // Update mesh position
                mesh.position.set(bot.position.x, bot.position.y, bot.position.z);
            });
            
            // Update security cameras
            if (gameState.cameras) {
                updateSecurityCameras(deltaTime);
            }
        }

        function updateGuardBot(bot, mesh, deltaTime, currentTime) {
            // Patrol logic
            if (bot.patrolPath && bot.patrolPath.length > 0) {
                const target = bot.patrolPath[bot.patrolIndex];
                const dx = target.x - bot.position.x;
                const dz = target.z - bot.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < 1) {
                    bot.patrolIndex = (bot.patrolIndex + 1) % bot.patrolPath.length;
                    // Pause at patrol point
                    bot.pauseTime = currentTime + 1000 + Math.random() * 2000;
                } else if (!bot.pauseTime || currentTime > bot.pauseTime) {
                    // Move towards target
                    const moveSpeed = bot.speed * (1 + bot.alertLevel / 100);
                    bot.position.x += (dx / distance) * moveSpeed;
                    bot.position.z += (dz / distance) * moveSpeed;
                    
                    // Face movement direction
                    if (dx !== 0 || dz !== 0) {
                        mesh.lookAt(
                            bot.position.x + dx,
                            bot.position.y,
                            bot.position.z + dz
                        );
                    }
                }
            }
            
            // Alert level decay
            if (bot.alertLevel > 0) {
                bot.alertLevel -= deltaTime * (bot.alertness * 5);
                if (bot.alertLevel < 0) bot.alertLevel = 0;
                
                // Update guard color based on alert level
                if (mesh.children[0] && mesh.children[0].material) {
                    const baseColor = bot.rank === 'rookie' ? 0x1a2b5f : 
                                    bot.rank === 'sergeant' ? 0x000033 : 
                                    bot.rank === 'captain' ? 0x000022 : 0x0d1b4d;
                    
                    const alertColor = 0xff0000;
                    const colorIntensity = Math.min(bot.alertLevel / 100, 1);
                    
                    const mixedColor = new THREE.Color().lerpColors(
                        new THREE.Color(baseColor),
                        new THREE.Color(alertColor),
                        colorIntensity
                    );
                    
                    mesh.children[0].material.color.set(mixedColor);
                }
            }
            
            // Player detection (less frequent checks)
            if (currentTime - bot.lastDetectionCheck > 500) { // Check every 500ms
                bot.lastDetectionCheck = currentTime;
                checkRealisticGuardDetection(bot, index);
            }
        }

        function updateInmateBot(bot, mesh, deltaTime, currentTime) {
            // Activity system
            if (currentTime - bot.lastActivityChange > 5000) { // Change activity every 5 seconds
                bot.lastActivityChange = currentTime;
                
                if (Math.random() < bot.activityChance) {
                    const activities = ['walking', 'talking', 'exercising', 'sitting'];
                    bot.activity = activities[Math.floor(Math.random() * activities.length)];
                    
                    if (bot.activity === 'walking') {
                        bot.walkTarget = {
                            x: bot.position.x + (Math.random() - 0.5) * 20,
                            z: bot.position.z + (Math.random() - 0.5) * 20
                        };
                    }
                } else {
                    bot.activity = 'idle';
                }
            }
            
            // Perform current activity
            switch(bot.activity) {
                case 'walking':
                    if (bot.walkTarget) {
                        const dx = bot.walkTarget.x - bot.position.x;
                        const dz = bot.walkTarget.z - bot.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance < 1) {
                            bot.activity = 'idle';
                        } else {
                            bot.position.x += (dx / distance) * bot.speed;
                            bot.position.z += (dz / distance) * bot.speed;
                            
                            // Face movement direction
                            mesh.lookAt(
                                bot.position.x + dx,
                                bot.position.y,
                                bot.position.z + dz
                            );
                        }
                    }
                    break;
                    
                case 'exercising':
                    // Simple bounce animation
                    mesh.position.y = 1 + Math.sin(currentTime * 0.01) * 0.2;
                    break;
            }
            
            // Interaction cooldown
            if (bot.interactionCooldown > 0) {
                bot.interactionCooldown -= deltaTime * 1000;
            }
        }

        function updateSecurityCameras(deltaTime) {
            gameState.cameras.forEach(camera => {
                if (!camera.mesh) return;
                
                // Sweep back and forth
                const time = Date.now() * 0.001;
                const sweep = Math.sin(time * camera.sweepSpeed + camera.timeOffset) * camera.sweepRange;
                camera.mesh.rotation.y = camera.baseRotation + sweep;
                
                // Check if camera sees player
                if (playerMesh && Math.random() < 0.01) {
                    const cameraDirection = new THREE.Vector3(0, 0, 1);
                    cameraDirection.applyEuler(camera.mesh.rotation);
                    
                    const toPlayer = new THREE.Vector3().subVectors(
                        playerMesh.position,
                        camera.mesh.position
                    ).normalize();
                    
                    const dotProduct = cameraDirection.dot(toPlayer);
                    if (dotProduct > 0.9) { // Camera is pointing at player
                        const distance = playerMesh.position.distanceTo(camera.mesh.position);
                        if (distance < 30) {
                            // Alert guards
                            gameState.bots.forEach((bot, index) => {
                                if (bot.type === 'guard') {
                                    bot.alertLevel += 30;
                                    if (bot.alertLevel > 100) bot.alertLevel = 100;
                                }
                            });
                            
                            showMessage("Security camera spotted you!", 'warning');
                        }
                    }
                }
            });
        }

        function checkRealisticGuardDetection(bot, index) {
            if (!playerMesh || bot.alertLevel > 80) return;
            
            const player = gameState.players[gameState.playerId];
            
            // Calculate distance
            const dx = playerMesh.position.x - bot.position.x;
            const dz = playerMesh.position.z - bot.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            // Check if player is within vision range
            if (distance < bot.visionRange) {
                // Check line of sight (simplified)
                let hasLineOfSight = true;
                
                // Simple obstacle check (would need raycasting for full implementation)
                wallMeshes.forEach(wall => {
                    if (wall.userData.type === 'wall' || wall.userData.type === 'cell') {
                        const wallPos = wall.position;
                        const wallDistance = Math.sqrt(
                            Math.pow(wallPos.x - bot.position.x, 2) +
                            Math.pow(wallPos.z - bot.position.z, 2)
                        );
                        
                        if (wallDistance < distance) {
                            // Simple check - if wall is between guard and player
                            const angleToWall = Math.atan2(wallPos.z - bot.position.z, wallPos.x - bot.position.x);
                            const angleToPlayer = Math.atan2(dz, dx);
                            const angleDiff = Math.abs(angleToWall - angleToPlayer);
                            
                            if (angleDiff < 0.5) {
                                hasLineOfSight = false;
                            }
                        }
                    }
                });
                
                if (hasLineOfSight) {
                    // Detection chance based on distance, alertness, and time of day
                    let detectionChance = bot.alertness * (1 - distance/bot.visionRange);
                    
                    // Night reduces detection
                    if (gameState.isNight) detectionChance *= 0.7;
                    
                    // Running increases detection
                    if (isRunning) detectionChance *= 1.3;
                    
                    // Wearing guard uniform reduces detection
                    if (player.inventory.includes('uniform')) detectionChance *= 0.5;
                    
                    if (Math.random() < detectionChance * 0.05) { // 0.05 base chance multiplier
                        bot.alertLevel += 20 * bot.alertness;
                        showMessage(`${bot.rank} guard spotted you!`, 'warning');
                        
                        // Alert nearby guards
                        if (bot.alertLevel > 40) {
                            gameState.bots.forEach((otherBot, otherIndex) => {
                                if (otherBot.type === 'guard' && otherIndex !== index) {
                                    const otherDistance = Math.sqrt(
                                        Math.pow(otherBot.position.x - bot.position.x, 2) +
                                        Math.pow(otherBot.position.z - bot.position.z, 2)
                                    );
                                    
                                    if (otherDistance < 25) {
                                        otherBot.alertLevel += 10 * otherBot.alertness;
                                        sendNetworkMessage('botUpdate', { 
                                            index: otherIndex, 
                                            alertLevel: otherBot.alertLevel 
                                        });
                                    }
                                }
                            });
                        }
                        
                        sendNetworkMessage('botUpdate', { 
                            index, 
                            alertLevel: bot.alertLevel,
                            position: bot.position,
                            patrolIndex: bot.patrolIndex
                        });
                    }
                }
            }
            
            // Chase player if alerted
            if (bot.alertLevel > 40 && distance < 25) {
                bot.targetDirection = { x: dx, z: dz };
                const chaseSpeed = bot.speed * (1 + bot.alertLevel / 100);
                bot.position.x += (dx / distance) * chaseSpeed;
                bot.position.z += (dz / distance) * chaseSpeed;
                
                // Face player
                if (botMeshes[index]) {
                    botMeshes[index].lookAt(
                        playerMesh.position.x,
                        playerMesh.position.y,
                        playerMesh.position.z
                    );
                }
                
                // Catch player
                if (distance < 2) {
                    sendToSolitary(`Caught by ${bot.rank} guard!`);
                    sendNetworkMessage('gameOver', { 
                        success: false, 
                        reason: `Caught by ${bot.rank} guard` 
                    });
                }
            }
        }

        // ============================================================================
        // ENHANCED: REALISTIC PLAYER CHARACTER
        // ============================================================================

        function createRealisticPlayer(playerId, isLocal) {
            const playerGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: isLocal ? 0xff3333 : 0x33ff33,
                roughness: 0.7,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.9;
            playerGroup.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf0c8a0,
                roughness: 0.8
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.8;
            playerGroup.add(head);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.7, 6);
            const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
            leftArm.position.set(-0.4, 1.2, 0);
            leftArm.rotation.z = Math.PI / 4;
            playerGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
            rightArm.position.set(0.4, 1.2, 0);
            rightArm.rotation.z = -Math.PI / 4;
            playerGroup.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 6);
            const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            leftLeg.position.set(-0.2, 0.4, 0);
            playerGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
            rightLeg.position.set(0.2, 0.4, 0);
            playerGroup.add(rightLeg);
            
            playerGroup.castShadow = true;
            playerGroup.receiveShadow = true;
            
            if (isLocal) {
                playerMesh = playerGroup;
                playerMesh.position.set(-10, 1, 0);
            } else {
                otherPlayerMesh = playerGroup;
                otherPlayerMesh.position.set(10, 1, 0);
            }
            
            scene.add(playerGroup);
            
            // Initialize player state
            if (!gameState.players[playerId]) {
                gameState.players[playerId] = {
                    id: playerId,
                    name: isLocal ? 'You' : 'Partner',
                    position: isLocal ? playerMesh.position : otherPlayerMesh.position,
                    health: 100,
                    contraband: 0,
                    reputation: 0,
                    inventory: [],
                    isLocal: isLocal,
                    mesh: playerGroup,
                    lastPositionUpdate: 0,
                    animationState: 'idle',
                    disguiseActive: false
                };
            } else {
                gameState.players[playerId].mesh = playerGroup;
                gameState.players[playerId].isLocal = isLocal;
            }
            
            // Update UI
            if (isLocal) {
                document.getElementById('playerName1').textContent = ' (You)';
            } else {
                document.getElementById('playerName2').textContent = ' (Partner)';
            }
            
            return playerGroup;
        }

        // ============================================================================
        // MODIFIED GAME START FUNCTIONS
        // ============================================================================

        function startGame() {
            if (!gameState.isHost || !gameState.connectionEstablished) {
                showMessage("Wait for player to connect first", "warning");
                return;
            }
            
            setLoadingText("Constructing realistic prison facility...");
            showLoadingScreen(true);
            
            // Initialize Three.js
            initThreeJS();
            
            // Generate realistic prison
            generateRealisticPrison(gameState.prisonSeed);
            
            // Create realistic player
            createRealisticPlayer(gameState.playerId, true);
            
            // Create position for other player
            const otherPlayerPositions = {};
            Object.keys(gameState.players).forEach(playerId => {
                if (playerId !== gameState.playerId) {
                    otherPlayerPositions[playerId] = { x: 10, y: 1, z: 0 };
                }
            });
            
            // Notify other player to start
            sendNetworkMessage('gameStart', {
                prisonSeed: gameState.prisonSeed,
                playerPositions: {
                    [gameState.playerId]: { x: -10, y: 1, z: 0 },
                    ...otherPlayerPositions
                }
            });
            
            // Start game locally
            setTimeout(() => {
                startGameLocal();
            }, 1000);
        }

        function startGameFromNetwork(data) {
            setLoadingText("Entering prison facility...");
            showLoadingScreen(true);
            
            // Store prison seed from host
            gameState.prisonSeed = data.prisonSeed;
            gameState.rng = new SeededRandom(gameState.prisonSeed);
            
            // Initialize Three.js
            initThreeJS();
            
            // Generate realistic prison with same seed
            generateRealisticPrison(gameState.prisonSeed);
            
            // Create realistic player at assigned position
            const myPosition = data.playerPositions[gameState.playerId];
            createRealisticPlayer(gameState.playerId, true);
            if (playerMesh && myPosition) {
                playerMesh.position.set(myPosition.x, myPosition.y, myPosition.z);
            }
            
            // Create other players
            Object.keys(data.playerPositions).forEach(playerId => {
                if (playerId !== gameState.playerId) {
                    const pos = data.playerPositions[playerId];
                    createRealisticPlayer(playerId, false);
                    if (otherPlayerMesh && pos) {
                        otherPlayerMesh.position.set(pos.x, pos.y, pos.z);
                    }
                }
            });
            
            // Start game
            setTimeout(() => {
                startGameLocal();
            }, 1000);
        }

        // ============================================================================
        // MODIFIED GAME LOOP
        // ============================================================================

        function animate() {
            if (!gameState.gameStarted) return;
            
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            gameState.lastUpdate += deltaTime;
            
            // Update at 60fps for network
            if (gameState.lastUpdate >= 1/60) {
                gameState.lastUpdate = 0;
                
                // Update local player
                updateLocalPlayer();
                
                // Update realistic bots
                updateRealisticBots(deltaTime);
                
                // Check collisions
                checkCollisions();
                
                // Update camera
                updateCamera();
                
                // Update time of day
                updateTimeOfDay(deltaTime);
                
                // Update player animations
                updatePlayerAnimation(deltaTime);
            }
            
            renderer.render(scene, camera);
        }

        function updatePlayerAnimation(deltaTime) {
            if (!playerMesh) return;
            
            const player = gameState.players[gameState.playerId];
            
            // Update walking/running animation
            if (keys['w'] || keys['a'] || keys['s'] || keys['d'] || 
                keys['arrowup'] || keys['arrowleft'] || keys['arrowdown'] || keys['arrowright']) {
                
                player.animationState = isRunning ? 'running' : 'walking';
                
                // Simple leg swing animation
                const time = Date.now() * 0.01;
                const swingAmount = isRunning ? 0.3 : 0.2;
                
                if (playerMesh.children[4]) { // Left leg
                    playerMesh.children[4].rotation.x = Math.sin(time) * swingAmount;
                }
                if (playerMesh.children[5]) { // Right leg
                    playerMesh.children[5].rotation.x = Math.sin(time + Math.PI) * swingAmount;
                }
                
                // Arm swing
                if (playerMesh.children[2]) { // Left arm
                    playerMesh.children[2].rotation.x = Math.sin(time + Math.PI) * swingAmount * 0.5;
                }
                if (playerMesh.children[3]) { // Right arm
                    playerMesh.children[3].rotation.x = Math.sin(time) * swingAmount * 0.5;
                }
            } else {
                player.animationState = 'idle';
                
                // Reset to idle position
                playerMesh.children.forEach((child, index) => {
                    if (index >= 4 && index <= 5) { // Legs
                        child.rotation.x = 0;
                    } else if (index >= 2 && index <= 3) { // Arms
                        child.rotation.x = 0;
                    }
                });
            }
            
            // Update disguise appearance
            if (player.disguiseActive && playerMesh.children[0]) {
                playerMesh.children[0].material.color.setHex(0x0000ff);
            } else if (playerMesh.children[0]) {
                playerMesh.children[0].material.color.setHex(player.isLocal ? 0xff3333 : 0x33ff33);
            }
        }

        // ============================================================================
        // ENHANCED ESCAPE MECHANICS
        // ============================================================================

        function startEscape(method) {
            const option = document.getElementById('escape' + method.charAt(0).toUpperCase() + method.slice(1));
            if (option.classList.contains('disabled')) {
                showMessage("You don't meet the requirements for this escape method!", 'warning');
                return;
            }
            
            const player = gameState.players[gameState.playerId];
            
            // Check if at correct location
            if (!checkEscapeLocation(method)) {
                showMessage(`You need to be at the right location for ${method} escape!`, 'warning');
                return;
            }
            
            toggleEscapeMenu();
            showMessage(`Initiating ${method} escape sequence... Coordinate with partner!`, 'info');
            
            gameState.escapeInProgress = true;
            player.escapeMethod = method;
            player.escapeStartTime = Date.now();
            
            sendNetworkMessage('escapeAttempt', {
                method: method,
                playerId: gameState.playerId,
                timestamp: Date.now(),
                location: { x: playerMesh.position.x, z: playerMesh.position.z }
            });
            
            // Start escape minigame with realistic timing
            const escapeTime = getEscapeTime(method);
            showMessage(`Escape in progress... ${escapeTime/1000} seconds remaining`, 'info');
            
            setTimeout(() => {
                const success = attemptRealisticEscape(method);
                
                if (success) {
                    escapeSuccess(method);
                } else {
                    escapeFailure(method);
                }
            }, escapeTime);
        }

        function checkEscapeLocation(method) {
            if (!playerMesh) return false;
            
            const halfSize = CONFIG.PRISON_SIZE / 2;
            
            switch(method) {
                case 'tunnel':
                    // Must be near outer wall
                    return Math.abs(playerMesh.position.x) > halfSize - 8 || 
                           Math.abs(playerMesh.position.z) > halfSize - 8;
                    
                case 'disguise':
                    // Must be near main gate
                    return Math.abs(playerMesh.position.x) < 15 && 
                           playerMesh.position.z > halfSize - 15;
                    
                case 'riot':
                    // Must be in yard or cafeteria
                    return (Math.abs(playerMesh.position.x) < 30 && Math.abs(playerMesh.position.z) < 30) ||
                           (playerMesh.position.x < -20 && playerMesh.position.x > -50 && 
                            playerMesh.position.z > -40 && playerMesh.position.z < -20);
                    
                case 'parole':
                    // Must be near warden's office (simulated)
                    return Math.abs(playerMesh.position.x) < 10 && 
                           playerMesh.position.z < -35;
            }
            
            return true;
        }

        function getEscapeTime(method) {
            const baseTimes = {
                tunnel: 15000,  // 15 seconds
                disguise: 10000, // 10 seconds
                riot: 12000,    // 12 seconds
                parole: 8000     // 8 seconds
            };
            
            const player = gameState.players[gameState.playerId];
            let time = baseTimes[method] || 10000;
            
            // Partner reduces time
            if (Object.keys(gameState.players).length > 1) {
                time *= 0.7;
            }
            
            // Items can reduce time
            if (method === 'tunnel' && player.inventory.includes('crowbar')) {
                time *= 0.8;
            }
            
            // Night reduces time
            if (gameState.isNight) {
                time *= 0.9;
            }
            
            return Math.max(5000, time); // Minimum 5 seconds
        }

        function attemptRealisticEscape(method) {
            const player = gameState.players[gameState.playerId];
            let successChance = 0.5;
            
            // Base chances with realism
            switch(method) {
                case 'tunnel': 
                    successChance = 0.6;
                    if (player.inventory.includes('shovel')) successChance += 0.2;
                    if (player.inventory.includes('flashlight')) successChance += 0.1;
                    break;
                    
                case 'disguise': 
                    successChance = 0.7;
                    if (player.inventory.includes('uniform')) successChance += 0.15;
                    if (player.inventory.includes('idcard')) successChance += 0.15;
                    break;
                    
                case 'riot': 
                    successChance = 0.4 + (player.reputation / 150);
                    if (player.contraband > 3) successChance += 0.1;
                    break;
                    
                case 'parole': 
                    successChance = 0.8 - (player.contraband * 0.08);
                    if (player.reputation > 30) successChance += 0.1;
                    break;
            }
            
            // Partner bonus
            if (Object.keys(gameState.players).length > 1) {
                successChance += 0.2;
            }
            
            // Night bonus
            if (gameState.isNight) {
                successChance += 0.15;
            }
            
            // Alert level penalty
            const maxAlert = Math.max(...gameState.bots.filter(b => b.type === 'guard').map(b => b.alertLevel));
            successChance -= (maxAlert / 200);
            
            return Math.random() < Math.min(0.95, Math.max(0.1, successChance));
        }

        // ============================================================================
        // INITIALIZATION - MODIFIED TO USE REALISTIC FUNCTIONS
        // ============================================================================

        // Replace the existing prison generation call in startGame functions
        // Already done above

        // Replace the existing bot update call
        // In the animate function, replace updateBots with updateRealisticBots
        // Already done above

        // Replace the existing player creation
        // In startGame and startGameFromNetwork, replace createPlayer with createRealisticPlayer
        // Already done above

        // ============================================================================
        // FIX: Update the game loop to use new functions
        // ============================================================================

        // In the animate function, we already updated to use updateRealisticBots
        // and added updatePlayerAnimation

        // ============================================================================
        // ADDITIONAL ENHANCEMENTS
        // ============================================================================

        function initThreeJS() {
            console.log('Initializing Three.js with realistic settings...');
            
            if (typeof THREE === 'undefined') {
                throw new Error('Three.js not loaded');
            }
            
            // Scene with realistic lighting
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 30, 150);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 40);
            
            // Renderer with enhanced settings
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                throw new Error('Canvas element not found');
            }
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            
            // Enhanced lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 200, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Add realistic ground with texture
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            
            // Create vertex displacements for uneven ground
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                if (i % 9 !== 0) continue; // Only adjust every third vertex
                const x = vertices[i];
                const z = vertices[i + 2];
                const distanceFromCenter = Math.sqrt(x*x + z*z);
                if (distanceFromCenter > 40) {
                    vertices[i + 1] = (Math.sin(x * 0.1) * Math.cos(z * 0.1)) * 0.5;
                }
            }
            groundGeometry.attributes.position.needsUpdate = true;
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a5c1a,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1;
            ground.receiveShadow = true;
            scene.add(ground);
            
            console.log('Three.js initialized with realistic settings');
        }

        // ============================================================================
        // UPDATE EXISTING FUNCTIONS FOR REALISM
        // ============================================================================

        function collectItem(type, index) {
            const player = gameState.players[gameState.playerId];
            
            if (!player.inventory.includes(type) && player.inventory.length < 8) {
                player.inventory.push(type);
                player.contraband++;
                
                // Mark item as collected
                if (itemMeshes[index]) {
                    // Fade out animation
                    const fadeOut = setInterval(() => {
                        if (itemMeshes[index].material.opacity > 0) {
                            itemMeshes[index].material.opacity -= 0.1;
                            if (itemMeshes[index].material.opacity <= 0) {
                                itemMeshes[index].visible = false;
                                clearInterval(fadeOut);
                            }
                        }
                    }, 50);
                    
                    itemMeshes[index].userData.collected = true;
                }
                if (gameState.items[index]) {
                    gameState.items[index].collected = true;
                }
                
                // Special effects for important items
                if (type === 'key' || type === 'idcard') {
                    showMessage(`Acquired ${getItemName(type)} - Valuable item!`, 'success');
                    // Flash player briefly
                    if (playerMesh) {
                        const originalColor = playerMesh.children[0].material.color.getHex();
                        playerMesh.children[0].material.color.setHex(0xffff00);
                        setTimeout(() => {
                            playerMesh.children[0].material.color.setHex(originalColor);
                        }, 300);
                    }
                } else {
                    showMessage(`Collected: ${getItemName(type)}`, 'success');
                }
                
                // Check for uniform collection
                if (type === 'uniform') {
                    player.disguiseActive = true;
                    showMessage("Disguise equipped! Guards are less likely to detect you.", 'info');
                }
                
                // Notify other player
                sendNetworkMessage('itemCollected', { index, type });
                
                // Update UI
                updateInventoryUI();
                updateEscapeOptions();
            }
        }

        // ============================================================================
        // ENHANCED SOLITARY CONFINEMENT
        // ============================================================================

        function sendToSolitary(reason) {
            gameState.gameStarted = false;
            
            // Stop all movement
            keys = {};
            isRunning = false;
            
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('solitaryScreen').style.display = 'flex';
            
            document.getElementById('failReason').textContent = reason;
            
            const realisticMessages = [
                "The guards found your contraband. Back to square one.",
                "Your escape attempt was too obvious. Better luck next time.",
                "Security protocols activated. You've been neutralized.",
                "The warden personally escorted you to solitary.",
                "Your partner ratted you out! Just kidding... or are we?",
                "The tunnel collapsed. Maybe engineering isn't your thing.",
                "That uniform didn't fit as well as you thought.",
                "The riot never stood a chance against the riot squad."
            ];
            
            const funnyMessage = realisticMessages[Math.floor(Math.random() * realisticMessages.length)];
            document.getElementById('funnyMessage').textContent = funnyMessage;
            
            // Show realistic hint for next attempt
            const escapeMethods = Object.keys(CONFIG.ESCAPE_HINTS);
            const randomMethod = escapeMethods[Math.floor(Math.random() * escapeMethods.length)];
            document.getElementById('escapeHint').textContent = 
                `ðŸ’¡ Intelligence Report: ${CONFIG.ESCAPE_HINTS[randomMethod]}`;
            
            // Animate solitary scene with more detail
            animateRealisticSolitaryScene();
            
            // Notify partner
            if (gameState.connectionEstablished) {
                sendNetworkMessage('gameOver', { 
                    success: false, 
                    reason: reason,
                    playerId: gameState.playerId
                });
            }
            
            // Play sound effect (would need audio context)
            console.log("SOLITARY CONFINEMENT ACTIVATED");
        }

        function animateRealisticSolitaryScene() {
            const animationDiv = document.getElementById('solitaryAnimation');
            animationDiv.innerHTML = '';
            animationDiv.className = 'real-cell';
            
            // Create detailed cell bars
            for (let i = 0; i < 10; i++) {
                const bar = document.createElement('div');
                bar.className = 'prison-bar';
                bar.style.left = (i * 35 + 10) + 'px';
                bar.style.height = '200px';
                bar.style.top = '50px';
                animationDiv.appendChild(bar);
            }
            
            // Create security camera in cell
            const camera = document.createElement('div');
            camera.className = 'security-camera';
            camera.style.left = '300px';
            camera.style.top = '20px';
            animationDiv.appendChild(camera);
            
            const cameraLight = document.createElement('div');
            cameraLight.className = 'camera-light';
            camera.appendChild(cameraLight);
            
            // Create inmate (player)
            const inmate = document.createElement('div');
            inmate.className = 'real-inmate';
            inmate.style.left = '180px';
            inmate.style.bottom = '20px';
            inmate.style.width = '40px';
            inmate.style.height = '60px';
            animationDiv.appendChild(inmate);
            
            // Create guard patrol
            const guard = document.createElement('div');
            guard.className = 'real-guard';
            guard.style.left = '0px';
            guard.style.bottom = '20px';
            guard.style.width = '45px';
            guard.style.height = '70px';
            animationDiv.appendChild(guard);
            
            // Animate guard patrol with stops
            let direction = 1;
            let isPaused = false;
            const guardInterval = setInterval(() => {
                if (document.getElementById('solitaryScreen').style.display !== 'flex') {
                    clearInterval(guardInterval);
                    return;
                }
                
                if (!isPaused) {
                    const currentLeft = parseInt(guard.style.left) || 0;
                    if (currentLeft > 320) {
                        direction = -1;
                        isPaused = true;
                        setTimeout(() => isPaused = false, 2000);
                    } else if (currentLeft < 0) {
                        direction = 1;
                        isPaused = true;
                        setTimeout(() => isPaused = false, 2000);
                    }
                    
                    guard.style.left = (currentLeft + direction * 2) + 'px';
                    
                    // Make inmate occasionally move
                    if (Math.random() < 0.05) {
                        inmate.style.left = (170 + Math.random() * 20) + 'px';
                    }
                    
                    // Camera sweep
                    camera.style.transform = `rotate(${Math.sin(Date.now() * 0.001) * 30}deg)`;
                }
            }, 50);
        }

        // ============================================================================
        // UPDATE THE ORIGINAL FUNCTIONS TO USE ENHANCED VERSIONS
        // ============================================================================

        // Replace the original prison generation call in the network message handlers
        // We'll modify the handleNetworkMessage to use the new functions

        // The main fixes are done. The error with updateBot is fixed by adding the function.
        // All other functions are enhanced for realism.

        console.log('Enhanced Cell Block Zero - All fixes and enhancements applied');
    </script>
</body>
</html>
