<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cell Block Zero - Maximum Security Escape</title>
    
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', 'Segoe UI', sans-serif;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            color: #e0e0ff;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        /* UI Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(ellipse at center, rgba(10, 15, 40, 0.95) 0%, rgba(5, 10, 30, 0.98) 100%);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }

        #lobbyScreen {
            display: flex;
            background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxkZWZzPjxwYXR0ZXJuIGlkPSJncmlkIiB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHBhdHRlcm5Vbml0cz0idXNlclNwYWNlT25Vc2UiIHBhdHRlcm5UcmFuc2Zvcm09InJvdGF0ZSg0NSkiPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InJnYmEoMCwgMjAsIDUwLCAwLjA1KSIvPjxwYXRoIGQ9Ik0gNDAgMCBMIDAgMCAwIDQwIiBmaWxsPSJub25lIiBzdHJva2U9InJnYmEoMCwgMTAwLCAyNTUsIDAuMSkiIHN0cm9rZS13aWR0aD0iMSIvPjwvcGF0dGVybj48L2RlZnM+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNncmlkKSIvPjwvc3ZnPg==');
        }

        #gameScreen {
            display: none;
        }

        #solitaryScreen {
            display: none;
            background: #000;
        }

        #loadingScreen {
            display: none;
            background: #000;
        }

        /* UI Elements */
        .ui-box {
            background: linear-gradient(145deg, rgba(10, 20, 40, 0.95), rgba(5, 15, 35, 0.98));
            border: 2px solid rgba(0, 150, 255, 0.5);
            border-radius: 15px;
            padding: 35px;
            max-width: 800px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 50, 150, 0.3),
                        inset 0 0 0 1px rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #fff;
            font-size: 4em;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0, 150, 255, 0.8),
                         0 0 60px rgba(0, 100, 255, 0.4),
                         2px 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 3px;
            font-weight: 900;
            background: linear-gradient(to right, #4facfe 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: #88ccff;
            font-size: 1.2em;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        h2 {
            color: #4facfe;
            margin: 25px 0;
            font-size: 2.2em;
            text-shadow: 0 2px 10px rgba(0, 100, 255, 0.3);
        }

        h3 {
            color: #ffcc00;
            margin: 15px 0;
            font-size: 1.5em;
        }

        p {
            margin: 15px 0;
            line-height: 1.6;
            font-size: 1.1em;
            color: #b0d0ff;
        }

        button {
            background: linear-gradient(145deg, #0066cc, #0044aa);
            color: white;
            border: none;
            padding: 16px 32px;
            margin: 15px;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0, 100, 200, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: linear-gradient(145deg, #0088ff, #0066cc);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 150, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: linear-gradient(145deg, #444, #222);
            border: 1px solid #666;
        }

        .btn-secondary:hover {
            background: linear-gradient(145deg, #666, #444);
        }

        input {
            background: rgba(20, 40, 80, 0.8);
            color: white;
            border: 2px solid rgba(0, 150, 255, 0.5);
            padding: 14px;
            margin: 10px;
            border-radius: 8px;
            font-size: 1.1em;
            width: 280px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.5);
        }

        /* Game UI */
        #connectionStatus {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 25px;
            background: rgba(10, 20, 40, 0.9);
            border: 2px solid #4facfe;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(5px);
        }

        .status-connected {
            border-color: #00ff88;
            color: #00ff88;
        }

        .status-connecting {
            border-color: #ffcc00;
            color: #ffcc00;
        }

        .status-disconnected {
            border-color: #ff4444;
            color: #ff4444;
        }

        #gameUI {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            gap: 20px;
        }

        .player-info {
            background: linear-gradient(145deg, rgba(20, 40, 80, 0.9), rgba(10, 30, 70, 0.9));
            border: 2px solid;
            padding: 20px;
            min-width: 280px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .player1 {
            border-color: #ff4444;
            background: linear-gradient(145deg, rgba(80, 20, 20, 0.9), rgba(60, 10, 10, 0.9));
        }

        .player2 {
            border-color: #00ff88;
            background: linear-gradient(145deg, rgba(20, 80, 40, 0.9), rgba(10, 60, 30, 0.9));
        }

        .player-info h3 {
            margin-top: 0;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .health-bar {
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 12px 0;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff8800);
            transition: width 0.3s ease;
            border-radius: 8px;
            position: relative;
        }

        .health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                rgba(255, 255, 255, 0.3) 0%, 
                rgba(255, 255, 255, 0.1) 50%, 
                rgba(255, 255, 255, 0.3) 100%);
            animation: shimmer 2s infinite;
        }

        /* Inventory */
        #inventory {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(145deg, rgba(20, 40, 80, 0.95), rgba(10, 30, 70, 0.95));
            border: 2px solid #ffcc00;
            padding: 20px;
            border-radius: 12px;
            display: none;
            min-width: 250px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .inventory-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 204, 0, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 204, 0, 0.3);
            transition: transform 0.2s;
        }

        .inventory-item:hover {
            transform: translateX(5px);
            background: rgba(255, 204, 0, 0.2);
        }

        .inventory-icon {
            width: 40px;
            height: 40px;
            margin-right: 15px;
            border: 2px solid #ffcc00;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            background: rgba(255, 204, 0, 0.1);
        }

        /* Objective */
        #objective {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(20, 10, 40, 0.95), rgba(10, 5, 30, 0.98));
            border: 2px solid #ff4444;
            padding: 50px;
            text-align: center;
            display: none;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(255, 68, 68, 0.3);
            max-width: 700px;
            width: 90%;
            backdrop-filter: blur(10px);
            animation: pulse 2s infinite;
        }

        /* Chat */
        #chat {
            position: absolute;
            bottom: 120px;
            left: 30px;
            width: 400px;
            max-height: 300px;
            background: linear-gradient(145deg, rgba(20, 40, 80, 0.95), rgba(10, 30, 70, 0.95));
            border: 2px solid #00aaff;
            padding: 20px;
            border-radius: 12px;
            display: none;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        #chatMessages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 20, 40, 0.5);
            border-radius: 8px;
            max-height: 200px;
        }

        .chat-message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 8px;
            word-break: break-word;
            animation: slideIn 0.3s;
        }

        .chat-message.you {
            background: linear-gradient(90deg, rgba(0, 100, 0, 0.3), rgba(0, 150, 0, 0.2));
            border-left: 4px solid #00ff88;
        }

        .chat-message.partner {
            background: linear-gradient(90deg, rgba(0, 50, 100, 0.3), rgba(0, 100, 150, 0.2));
            border-left: 4px solid #4facfe;
        }

        /* Escape Menu */
        #escapeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(20, 10, 40, 0.98), rgba(10, 5, 30, 0.98));
            border: 2px solid #ff4444;
            padding: 40px;
            display: none;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(255, 68, 68, 0.4);
            min-width: 750px;
            backdrop-filter: blur(10px);
        }

        .escape-option {
            padding: 25px;
            border: 2px solid #4facfe;
            cursor: pointer;
            text-align: center;
            background: rgba(0, 50, 100, 0.3);
            border-radius: 12px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .escape-option:hover {
            background: rgba(0, 100, 150, 0.4);
            transform: scale(1.05);
            border-color: #00ff88;
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.2);
        }

        .escape-option.ready {
            border-color: #00ff88;
            background: rgba(0, 100, 0, 0.4);
        }

        .escape-option.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
        }

        .escape-option.disabled:hover {
            transform: none;
            background: rgba(0, 50, 100, 0.3);
            box-shadow: none;
        }

        /* Solitary Screen */
        #solitaryScreen .ui-box {
            border-color: #ff4444;
            background: linear-gradient(145deg, rgba(40, 10, 10, 0.95), rgba(20, 5, 5, 0.98));
        }

        #solitaryAnimation {
            width: 100%;
            height: 300px;
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid #444;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
            border-radius: 12px;
        }

        .inmate-cell {
            position: absolute;
            width: 10px;
            height: 200px;
            background: linear-gradient(to bottom, #666, #333);
            top: 50px;
        }

        .guard-bot {
            position: absolute;
            width: 50px;
            height: 70px;
            background: linear-gradient(to bottom, #0000ff, #0044cc);
            border-radius: 25px 25px 5px 5px;
            bottom: 20px;
            transition: left 1s linear;
            box-shadow: 0 5px 15px rgba(0, 0, 255, 0.5);
        }

        .inmate {
            position: absolute;
            width: 40px;
            height: 60px;
            background: linear-gradient(to bottom, #ff0000, #880000);
            border-radius: 20px 20px 5px 5px;
            bottom: 20px;
        }

        /* Loading Screen */
        .spinner {
            width: 70px;
            height: 70px;
            border: 5px solid rgba(79, 172, 254, 0.3);
            border-radius: 50%;
            border-top-color: #4facfe;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: none;
            gap: 15px;
            pointer-events: none;
        }

        .mobile-btn {
            width: 80px;
            height: 80px;
            background: linear-gradient(145deg, rgba(0, 100, 200, 0.7), rgba(0, 50, 150, 0.7));
            border: 2px solid #4facfe;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 28px;
            font-weight: bold;
            pointer-events: auto;
            touch-action: manipulation;
            user-select: none;
            box-shadow: 0 5px 15px rgba(0, 100, 200, 0.3);
        }

        .mobile-btn:active {
            background: linear-gradient(145deg, rgba(0, 150, 255, 0.7), rgba(0, 100, 200, 0.7));
            transform: scale(0.95);
        }

        /* Message Display */
        #messageDisplay {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, rgba(20, 40, 80, 0.9), rgba(10, 30, 70, 0.9));
            border: 2px solid #4facfe;
            padding: 20px 40px;
            border-radius: 12px;
            display: none;
            z-index: 1001;
            text-align: center;
            max-width: 80%;
            word-break: break-word;
            backdrop-filter: blur(5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.3s;
        }

        /* Progress Bar */
        .progress-bar {
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 6px;
            overflow: hidden;
            margin: 12px 0;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            transition: width 0.3s;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                rgba(255, 255, 255, 0.3) 0%, 
                rgba(255, 255, 255, 0.1) 50%, 
                rgba(255, 255, 255, 0.3) 100%);
            animation: shimmer 2s infinite;
        }

        /* Waiting Overlay */
        #waitingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .waiting-box {
            background: linear-gradient(145deg, rgba(20, 40, 80, 0.95), rgba(10, 30, 70, 0.95));
            border: 2px solid #4facfe;
            padding: 50px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            animation: pulse 2s infinite;
            backdrop-filter: blur(10px);
        }

        /* Room Code Display */
        .room-code {
            font-size: 3.5em;
            font-weight: bold;
            color: #4facfe;
            text-shadow: 0 0 20px rgba(79, 172, 254, 0.7);
            margin: 20px 0;
            letter-spacing: 10px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 2px solid rgba(79, 172, 254, 0.3);
        }

        .code-copy {
            background: linear-gradient(145deg, #00cc88, #009966);
            margin-top: 10px;
        }

        .code-copy:hover {
            background: linear-gradient(145deg, #00ffaa, #00cc88);
        }

        /* Animation Classes */
        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(79, 172, 254, 0.7); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); box-shadow: 0 0 0 20px rgba(79, 172, 254, 0); }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideDown {
            from { transform: translate(-50%, -20px); opacity: 0; }
            to { transform: translate(-50%, 0); opacity: 1; }
        }

        /* Stats Display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            h1 { font-size: 2.5em; }
            h2 { font-size: 1.8em; }
            button { padding: 14px 24px; font-size: 1.1em; }
            .ui-box { padding: 20px; }
            #gameUI { flex-direction: column; gap: 15px; }
            .player-info { min-width: auto; width: 100%; }
            #escapeMenu { 
                grid-template-columns: 1fr; 
                min-width: 90%;
                padding: 20px;
            }
            #mobileControls { display: flex; }
            .room-code { font-size: 2.5em; letter-spacing: 5px; }
        }

        /* Icon Styles */
        .icon {
            margin-right: 10px;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(145deg, rgba(20, 40, 80, 0.95), rgba(10, 30, 70, 0.95));
            border-left: 5px solid #4facfe;
            padding: 20px;
            border-radius: 8px;
            display: none;
            z-index: 3000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s;
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid #4facfe;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Loading Screen -->
        <div id="loadingScreen" class="screen">
            <div class="ui-box">
                <h1><i class="fas fa-dungeon"></i> CELL BLOCK ZERO</h1>
                <div class="spinner"></div>
                <h2 id="loadingText">Initializing Maximum Security System...</h2>
                <p>Establishing secure connection...</p>
                <div class="progress-bar">
                    <div id="loadingProgress" class="progress-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Waiting Overlay -->
        <div id="waitingOverlay">
            <div class="waiting-box">
                <h2><i class="fas fa-users"></i> Waiting for Partner</h2>
                <div class="spinner"></div>
                <p id="waitingMessage">Connected to host. Awaiting game start...</p>
                <button onclick="cancelWaiting()" class="btn-secondary" style="margin-top: 20px;">
                    <i class="fas fa-times"></i> CANCEL
                </button>
            </div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobbyScreen" class="screen">
            <div class="ui-box">
                <h1><i class="fas fa-dungeon"></i> CELL BLOCK ZERO</h1>
                <div class="subtitle">MAXIMUM SECURITY ESCAPE</div>
                
                <div id="connectionStatus" class="status-disconnected">
                    <i class="fas fa-plug"></i>
                    <span>Status: Ready</span>
                </div>
                
                <div style="margin: 40px 0;">
                    <button onclick="hostGame()" id="hostBtn">
                        <i class="fas fa-crown"></i> HOST GAME
                    </button>
                    <button onclick="joinGame()" id="joinBtn">
                        <i class="fas fa-user-plus"></i> JOIN GAME
                    </button>
                    <button onclick="showTutorial()" id="tutorialBtn" class="btn-secondary">
                        <i class="fas fa-book"></i> HOW TO PLAY
                    </button>
                </div>
                
                <div id="joinSection" style="display: none; margin: 30px 0;">
                    <h3><i class="fas fa-key"></i> Enter Room Code</h3>
                    <input type="text" id="roomCode" placeholder="Enter 4-digit code" maxlength="4" pattern="[0-9]{4}">
                    <button onclick="connectToHost()" id="connectBtn">
                        <i class="fas fa-link"></i> CONNECT
                    </button>
                    <button onclick="cancelJoin()" class="btn-secondary">
                        <i class="fas fa-arrow-left"></i> BACK
                    </button>
                    <p id="connectStatus" style="margin-top: 15px; color: #ffcc00;"></p>
                </div>
                
                <div id="roomInfo" style="display: none; margin: 30px 0;">
                    <h3><i class="fas fa-door-open"></i> Room Created</h3>
                    <div class="room-code" id="displayCode">1234</div>
                    <button onclick="copyRoomCode()" class="code-copy">
                        <i class="fas fa-copy"></i> COPY CODE
                    </button>
                    <p id="connectionCount" style="margin: 15px 0; color: #88ccff;">
                        <i class="fas fa-user-clock"></i> Waiting for player 2...
                    </p>
                    <button onclick="startGame()" id="startBtn" disabled>
                        <i class="fas fa-play"></i> START GAME
                    </button>
                    <button onclick="cancelHost()" class="btn-secondary">
                        <i class="fas fa-times"></i> CANCEL
                    </button>
                </div>
                
                <div id="tutorialSection" style="display: none; margin: 30px 0; text-align: left;">
                    <h3><i class="fas fa-graduation-cap"></i> Prison Escape Guide</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <h4><i class="fas fa-user-friends"></i> Teamwork</h4>
                            <p>Cooperate with your partner to succeed</p>
                        </div>
                        <div class="stat-item">
                            <h4><i class="fas fa-tools"></i> Collect Items</h4>
                            <p>Find tools and uniforms to aid your escape</p>
                        </div>
                        <div class="stat-item">
                            <h4><i class="fas fa-robot"></i> Avoid Guards</h4>
                            <p>Stay out of sight and be stealthy</p>
                        </div>
                        <div class="stat-item">
                            <h4><i class="fas fa-door-open"></i> Escape Routes</h4>
                            <p>Choose from multiple escape methods</p>
                        </div>
                    </div>
                    <button onclick="hideTutorial()" style="margin-top: 20px;">
                        <i class="fas fa-arrow-left"></i> BACK TO MENU
                    </button>
                </div>
                
                <div style="margin-top: 40px;">
                    <h3><i class="fas fa-gamepad"></i> Controls</h3>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <strong>WASD:</strong> Move<br>
                            <strong>Space:</strong> Jump
                        </div>
                        <div class="stat-item">
                            <strong>E:</strong> Interact<br>
                            <strong>F:</strong> Fight
                        </div>
                        <div class="stat-item">
                            <strong>TAB:</strong> Inventory<br>
                            <strong>C:</strong> Chat
                        </div>
                        <div class="stat-item">
                            <strong>M:</strong> Escape Menu<br>
                            <strong>ESC:</strong> Pause
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="screen">
            <canvas id="gameCanvas"></canvas>
            
            <div id="connectionStatus" class="status-connected">
                <i class="fas fa-wifi"></i>
                <span>Connected</span>
            </div>
            
            <div id="gameUI">
                <div class="player-info player1">
                    <h3><i class="fas fa-user-injured"></i> Player 1 <span id="playerName1"></span></h3>
                    <div class="health-bar">
                        <div id="healthBar1" class="health-fill" style="width: 100%"></div>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <strong>Health:</strong> <span id="health1">100</span>
                        </div>
                        <div class="stat-item">
                            <strong>Contraband:</strong> <span id="contraband1">0</span>
                        </div>
                        <div class="stat-item">
                            <strong>Reputation:</strong> <span id="rep1">0</span>
                        </div>
                        <div class="stat-item">
                            <strong>Position:</strong> <span id="pos1">0,0</span>
                        </div>
                    </div>
                </div>
                
                <div class="player-info player2">
                    <h3><i class="fas fa-user-friends"></i> Player 2 <span id="playerName2"></span></h3>
                    <div class="health-bar">
                        <div id="healthBar2" class="health-fill" style="width: 100%"></div>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <strong>Health:</strong> <span id="health2">100</span>
                        </div>
                        <div class="stat-item">
                            <strong>Contraband:</strong> <span id="contraband2">0</span>
                        </div>
                        <div class="stat-item">
                            <strong>Reputation:</strong> <span id="rep2">0</span>
                        </div>
                        <div class="stat-item">
                            <strong>Position:</strong> <span id="pos2">0,0</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="inventory">
                <h3><i class="fas fa-backpack"></i> Inventory <span id="inventoryCount">(0)</span></h3>
                <div id="inventoryItems"></div>
                <div class="progress-bar">
                    <div id="escapeProgress" class="progress-fill" style="width: 0%"></div>
                </div>
                <p>Escape Preparation</p>
            </div>
            
            <div id="objective">
                <h2><i class="fas fa-flag"></i> ESCAPE MISSION</h2>
                <p id="objectiveText">Break out of maximum security prison with your partner!</p>
                <p id="objectiveSubtext">Collect items, avoid detection, and coordinate your escape.</p>
                <button onclick="hideObjective()">
                    <i class="fas fa-play-circle"></i> BEGIN ESCAPE
                </button>
            </div>
            
            <div id="chat">
                <div id="chatMessages"></div>
                <input type="text" id="chatInput" placeholder="Type your message... (Enter to send, ESC to close)">
            </div>
            
            <div id="escapeMenu">
                <h2 style="grid-column: span 2;"><i class="fas fa-door-open"></i> ESCAPE METHODS</h2>
                <div class="escape-option" onclick="startEscape('tunnel')" id="escapeTunnel">
                    <h3><i class="fas fa-digging"></i> Tunnel Digging</h3>
                    <p>Dig a tunnel under prison walls</p>
                    <p><strong>Requires:</strong> Shovel</p>
                </div>
                <div class="escape-option" onclick="startEscape('disguise')" id="escapeDisguise">
                    <h3><i class="fas fa-user-secret"></i> Guard Disguise</h3>
                    <p>Disguise as guard and walk out</p>
                    <p><strong>Requires:</strong> Uniform, ID Card</p>
                </div>
                <div class="escape-option" onclick="startEscape('riot')" id="escapeRiot">
                    <h3><i class="fas fa-fire"></i> Riot Chaos</h3>
                    <p>Start riot and escape in chaos</p>
                    <p><strong>Requires:</strong> High Reputation (50+)</p>
                </div>
                <div class="escape-option" onclick="startEscape('parole')" id="escapeParole">
                    <h3><i class="fas fa-gavel"></i> Legal Parole</h3>
                    <p>Get released "legally"</p>
                    <p><strong>Requires:</strong> Clean Record</p>
                </div>
                <button onclick="toggleEscapeMenu()" style="grid-column: span 2; margin-top: 20px;">
                    <i class="fas fa-arrow-left"></i> BACK
                </button>
            </div>
            
            <!-- Mobile Controls -->
            <div id="mobileControls">
                <div class="mobile-btn" ontouchstart="mobileKeyDown('w')" ontouchend="mobileKeyUp('w')">
                    <i class="fas fa-arrow-up"></i>
                </div>
                <div style="display: flex; gap: 15px;">
                    <div class="mobile-btn" ontouchstart="mobileKeyDown('a')" ontouchend="mobileKeyUp('a')">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="mobile-btn" ontouchstart="mobileKeyDown('s')" ontouchend="mobileKeyUp('s')">
                        <i class="fas fa-arrow-down"></i>
                    </div>
                    <div class="mobile-btn" ontouchstart="mobileKeyDown('d')" ontouchend="mobileKeyUp('d')">
                        <i class="fas fa-arrow-right"></i>
                    </div>
                </div>
                <div class="mobile-btn" ontouchstart="mobileKeyDown('e')" ontouchend="mobileKeyUp('e')">
                    <i class="fas fa-hand-paper"></i>
                </div>
                <div class="mobile-btn" ontouchstart="mobileKeyDown(' ')" ontouchend="mobileKeyUp(' ')">
                    <i class="fas fa-arrow-up"></i>
                </div>
            </div>
            
            <div id="messageDisplay"></div>
        </div>

        <!-- Solitary Screen -->
        <div id="solitaryScreen" class="screen">
            <div class="ui-box">
                <h1><i class="fas fa-lock"></i> SOLITARY CONFINEMENT <i class="fas fa-lock"></i></h1>
                <div id="solitaryAnimation"></div>
                <h2 id="failReason">Security Breach Detected!</h2>
                <p id="funnyMessage" style="font-size: 1.3em; color: #ff9900; margin: 20px 0;"></p>
                <div style="margin: 40px 0;">
                    <button onclick="retryGame()">
                        <i class="fas fa-redo"></i> TRY AGAIN
                    </button>
                    <button onclick="returnToLobby()" class="btn-secondary">
                        <i class="fas fa-home"></i> MAIN MENU
                    </button>
                </div>
                <p style="margin-top: 20px; color: #ffcc00;">
                    <i class="fas fa-exclamation-triangle"></i> Prison layout has been modified!
                </p>
                <p id="escapeHint" style="color: #4facfe; font-style: italic; margin-top: 15px;"></p>
            </div>
        </div>
    </div>

    <!-- Notification Element -->
    <div id="notification" class="notification"></div>

    <script>
        // ============================================================================
        // ENHANCED RNG SYSTEM
        // ============================================================================
        class EnhancedRandom {
            constructor(seed) {
                this.seed = seed || Date.now();
                this.current = this.seed;
            }
            
            next() {
                this.current = (this.current * 9301 + 49297) % 233280;
                return this.current / 233280;
            }
            
            random() {
                return this.next();
            }
            
            range(min, max) {
                return min + this.next() * (max - min);
            }
            
            int(min, max) {
                return Math.floor(this.range(min, max));
            }
            
            choice(array) {
                return array[this.int(0, array.length)];
            }
            
            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        // ============================================================================
        // GAME CONFIGURATION - ENHANCED
        // ============================================================================
        const CONFIG = {
            PRISON_SIZE: 120,
            CELL_COUNT: 24,
            GUARD_COUNT: 8,
            INMATE_BOT_COUNT: 15,
            DAY_CYCLE: 300,
            ITEM_TYPES: [
                { id: 'shovel', name: 'Steel Shovel', color: '#8B4513', icon: 'ðŸªš', value: 10 },
                { id: 'uniform', name: 'Guard Uniform', color: '#0000ff', icon: 'ðŸ‘•', value: 15 },
                { id: 'idcard', name: 'Security ID', color: '#ffff00', icon: 'ðŸªª', value: 20 },
                { id: 'cigarettes', name: 'Cigarettes', color: '#f5f5f5', icon: 'ðŸš¬', value: 5 },
                { id: 'donut', name: 'Fresh Donut', color: '#ff69b4', icon: 'ðŸ©', value: 8 },
                { id: 'key', name: 'Master Key', color: '#ffd700', icon: 'ðŸ”‘', value: 25 },
                { id: 'crowbar', name: 'Titanium Crowbar', color: '#808080', icon: 'ðŸ”§', value: 12 },
                { id: 'rope', name: 'Climbing Rope', color: '#8B4513', icon: 'ðŸª¢', value: 15 },
                { id: 'wirecutters', name: 'Wire Cutters', color: '#2E8B57', icon: 'âœ‚ï¸', value: 18 },
                { id: 'flashlight', name: 'Tactical Flashlight', color: '#FFD700', icon: 'ðŸ”¦', value: 10 }
            ],
            ESCAPE_REQUIREMENTS: {
                tunnel: ['shovel', 'wirecutters'],
                disguise: ['uniform', 'idcard'],
                riot: ['reputation_60'],
                parole: ['clean_record']
            },
            ESCAPE_HINTS: [
                "Guards change shifts every 2 minutes - time your moves",
                "Night time offers better concealment but more patrols",
                "Check ventilation shafts for hidden items",
                "Some inmate bots can be bribed with cigarettes",
                "The laundry room always has spare uniforms",
                "Western wall section has weaker security",
                "Kitchen area has multiple hiding spots"
            ],
            GUARD_TYPES: [
                { type: 'patrol', speed: 0.04, vision: 20, aggression: 0.3 },
                { type: 'stationary', speed: 0.02, vision: 15, aggression: 0.6 },
                { type: 'roaming', speed: 0.05, vision: 25, aggression: 0.4 }
            ]
        };

        // ============================================================================
        // ENHANCED GAME STATE
        // ============================================================================
        let gameState = {
            players: {},
            bots: [],
            items: [],
            prisonLayout: [],
            timeOfDay: 0.5,
            isNight: false,
            gameStarted: false,
            escapeInProgress: false,
            playerId: null,
            peer: null,
            dataChannel: null,
            isHost: false,
            roomCode: null,
            connectionEstablished: false,
            lastUpdate: 0,
            fps: 60,
            gameLoaded: false,
            prisonSeed: Date.now(),
            rng: null,
            connectionCheckInterval: null,
            audioContext: null,
            soundEnabled: true,
            playerName: 'Inmate',
            stats: {
                gamesPlayed: 0,
                escapes: 0,
                itemsCollected: 0,
                timePlayed: 0
            }
        };

        // ============================================================================
        // THREE.JS VARIABLES
        // ============================================================================
        let scene, camera, renderer;
        let playerMesh, otherPlayerMesh;
        let botMeshes = [], itemMeshes = [], wallMeshes = [], cellMeshes = [];
        let clock = new THREE.Clock();
        let moveSpeed = 0.18;
        let isRunning = false;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // ============================================================================
        // INPUT STATE
        // ============================================================================
        const keys = {};
        const keyState = { x: 0, y: 0, down: false };
        let touchControls = {};

        // ============================================================================
        // LOBBY FUNCTIONS - FIXED CONNECTION
        // ============================================================================

        function joinGame() {
            document.getElementById('joinSection').style.display = 'block';
            document.getElementById('hostBtn').disabled = true;
            document.getElementById('joinBtn').disabled = true;
            document.getElementById('tutorialBtn').disabled = true;
            document.getElementById('roomCode').focus();
        }

        function showTutorial() {
            document.getElementById('tutorialSection').style.display = 'block';
        }

        function hideTutorial() {
            document.getElementById('tutorialSection').style.display = 'none';
        }

        function cancelJoin() {
            document.getElementById('joinSection').style.display = 'none';
            document.getElementById('hostBtn').disabled = false;
            document.getElementById('joinBtn').disabled = false;
            document.getElementById('tutorialBtn').disabled = false;
            document.getElementById('connectStatus').textContent = '';
            updateConnectionStatus('ready', 'Ready to play');
        }

        function cancelHost() {
            if (gameState.peer) {
                gameState.peer.close();
            }
            if (gameState.connectionCheckInterval) {
                clearInterval(gameState.connectionCheckInterval);
            }
            localStorage.removeItem('hostOffer');
            localStorage.removeItem('iceCandidates');
            document.getElementById('roomInfo').style.display = 'none';
            document.getElementById('hostBtn').disabled = false;
            document.getElementById('joinBtn').disabled = false;
            document.getElementById('tutorialBtn').disabled = false;
            updateConnectionStatus('disconnected', 'Ready to play');
            showNotification('Room cancelled', 'info');
        }

        function cancelWaiting() {
            document.getElementById('waitingOverlay').style.display = 'none';
            if (gameState.peer) {
                gameState.peer.close();
            }
            gameState.connectionEstablished = false;
            updateConnectionStatus('disconnected', 'Connection cancelled');
            showNotification("Connection cancelled", "info");
        }

        // ============================================================================
        // INITIALIZATION - ENHANCED
        // ============================================================================
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('Cell Block Zero - Maximum Security Initializing');
            
            // Check for WebRTC support
            if (!navigator.mediaDevices || !window.RTCPeerConnection) {
                alert("ERROR: WebRTC not supported in this browser.\nPlease use Chrome, Firefox, or Edge.");
                return;
            }
            
            // Check for Three.js
            if (typeof THREE === 'undefined') {
                alert("ERROR: Three.js failed to load.\nPlease check your internet connection.");
                return;
            }
            
            // Initialize RNG with current time
            gameState.rng = new EnhancedRandom(Date.now());
            
            // Load saved stats
            loadGameStats();
            
            // Initialize UI
            updateConnectionStatus('ready', 'Ready to play');
            
            // Show controls for mobile
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                document.getElementById('mobileControls').style.display = 'flex';
            }
            
            // Test WebRTC connectivity
            testWebRTC();
            
            console.log('Game initialized successfully');
            gameState.gameLoaded = true;
            
            // Preload with animation
            simulateLoading();
        });

        function simulateLoading() {
            let progress = 0;
            const interval = setInterval(() => {
                progress += 10;
                document.getElementById('loadingProgress').style.width = `${progress}%`;
                
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        showNotification('System initialized', 'success');
                    }, 500);
                }
            }, 200);
        }

        function updateConnectionStatus(status, message) {
            const element = document.getElementById('connectionStatus');
            if (element) {
                element.innerHTML = `<i class="fas fa-${getStatusIcon(status)}"></i><span>Status: ${message}</span>`;
                element.className = `status-${status}`;
            }
        }

        function getStatusIcon(status) {
            switch(status) {
                case 'connected': return 'check-circle';
                case 'connecting': return 'sync-alt';
                case 'ready': return 'check';
                default: return 'times-circle';
            }
        }

        function showWaitingScreen(message) {
            document.getElementById('waitingOverlay').style.display = 'flex';
            document.getElementById('waitingMessage').textContent = message;
        }

        function hideWaitingScreen() {
            document.getElementById('waitingOverlay').style.display = 'none';
        }

        // ============================================================================
        // ENHANCED NETWORKING - FIXED WEBRTC CONNECTION
        // ============================================================================
        function hostGame() {
            if (!gameState.gameLoaded) {
                showNotification("Game still loading...", "warning");
                return;
            }
            
            document.getElementById('hostBtn').disabled = true;
            document.getElementById('joinBtn').disabled = true;
            document.getElementById('tutorialBtn').disabled = true;
            updateConnectionStatus('connecting', 'Creating secure room...');
            
            gameState.isHost = true;
            gameState.playerId = 'host_' + generateSecureId();
            gameState.roomCode = generate4DigitCode();
            gameState.prisonSeed = Date.now();
            gameState.rng = new EnhancedRandom(gameState.prisonSeed);
            
            // Create optimized peer connection
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10,
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            };
            
            gameState.peer = new RTCPeerConnection(configuration);
            
            // Create reliable data channel
            gameState.dataChannel = gameState.peer.createDataChannel('cellblock-zero', {
                ordered: true,
                maxRetransmits: 5,
                maxPacketLifeTime: 3000
            });
            
            setupDataChannel(gameState.dataChannel);
            
            // Enhanced ICE candidate handling
            gameState.peer.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Host ICE candidate generated');
                    const candidates = JSON.parse(localStorage.getItem('iceCandidates') || '[]');
                    candidates.push({
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    });
                    localStorage.setItem('iceCandidates', JSON.stringify(candidates));
                }
            };
            
            // Enhanced connection state handling
            gameState.peer.onconnectionstatechange = () => {
                console.log('Host connection state:', gameState.peer.connectionState);
                switch(gameState.peer.connectionState) {
                    case 'connected':
                        updateConnectionStatus('connected', 'Player connected!');
                        document.getElementById('startBtn').disabled = false;
                        document.getElementById('connectionCount').innerHTML = '<i class="fas fa-user-check"></i> Player connected! Ready to start!';
                        showNotification("Player connected successfully!", "success");
                        break;
                    case 'failed':
                        updateConnectionStatus('disconnected', 'Connection failed');
                        showNotification("Connection failed. Please try again.", "error");
                        break;
                }
            };
            
            // Create and store offer with retry logic
            createOfferWithRetry(3);
        }

        async function createOfferWithRetry(retries) {
            try {
                const offer = await gameState.peer.createOffer({
                    offerToReceiveAudio: false,
                    offerToReceiveVideo: false
                });
                
                await gameState.peer.setLocalDescription(offer);
                
                // Store offer with metadata
                const hostData = {
                    sdp: gameState.peer.localDescription,
                    roomCode: gameState.roomCode,
                    playerId: gameState.playerId,
                    prisonSeed: gameState.prisonSeed,
                    timestamp: Date.now(),
                    expires: Date.now() + 180000 // 3 minutes
                };
                
                localStorage.setItem('hostOffer', JSON.stringify(hostData));
                localStorage.setItem('iceCandidates', '[]');
                localStorage.removeItem('playerAnswer');
                localStorage.removeItem('playerIceCandidate');
                
                // Show room info
                document.getElementById('roomInfo').style.display = 'block';
                document.getElementById('displayCode').textContent = gameState.roomCode;
                updateConnectionStatus('connecting', `Room code: ${gameState.roomCode}`);
                
                console.log('Host room created:', gameState.roomCode);
                showNotification(`Room created! Code: ${gameState.roomCode}`, "success");
                
                // Start connection polling
                startConnectionPolling();
                
            } catch (error) {
                console.error('Error creating offer:', error);
                if (retries > 0) {
                    console.log(`Retrying... ${retries} attempts left`);
                    setTimeout(() => createOfferWithRetry(retries - 1), 1000);
                } else {
                    updateConnectionStatus('disconnected', 'Failed to create room');
                    showNotification("Failed to create room. Please try again.", "error");
                    document.getElementById('hostBtn').disabled = false;
                    document.getElementById('joinBtn').disabled = false;
                    document.getElementById('tutorialBtn').disabled = false;
                }
            }
        }

        function startConnectionPolling() {
            if (gameState.connectionCheckInterval) {
                clearInterval(gameState.connectionCheckInterval);
            }
            
            gameState.connectionCheckInterval = setInterval(() => {
                if (gameState.connectionEstablished) {
                    clearInterval(gameState.connectionCheckInterval);
                    return;
                }
                
                try {
                    const playerAnswer = localStorage.getItem('playerAnswer');
                    if (playerAnswer) {
                        const answer = JSON.parse(playerAnswer);
                        
                        if (answer.roomCode === gameState.roomCode && 
                            Date.now() < (answer.expires || Date.now() + 60000)) {
                            
                            console.log('Accepting connection from joiner');
                            gameState.peer.setRemoteDescription(new RTCSessionDescription(answer.sdp))
                                .then(() => {
                                    console.log('Remote description set successfully');
                                    
                                    // Add ICE candidates from joiner
                                    const candidateData = localStorage.getItem('playerIceCandidate');
                                    if (candidateData) {
                                        const candidates = JSON.parse(candidateData);
                                        if (candidates.roomCode === gameState.roomCode) {
                                            candidates.candidates.forEach(candidate => {
                                                gameState.peer.addIceCandidate(new RTCIceCandidate(candidate))
                                                    .catch(e => console.warn('ICE candidate add warning:', e));
                                            });
                                        }
                                    }
                                    
                                    localStorage.removeItem('playerAnswer');
                                    localStorage.removeItem('playerIceCandidate');
                                })
                                .catch(error => {
                                    console.error('Error setting remote description:', error);
                                });
                        } else {
                            localStorage.removeItem('playerAnswer');
                        }
                    }
                } catch (e) {
                    console.error('Connection polling error:', e);
                }
            }, 500);
        }

        async function connectToHost() {
            const roomCodeInput = document.getElementById('roomCode');
            const roomCode = roomCodeInput.value.trim();
            const connectBtn = document.getElementById('connectBtn');
            const connectStatus = document.getElementById('connectStatus');
            
            if (!roomCode || !/^\d{4}$/.test(roomCode)) {
                showNotification("Please enter a valid 4-digit code", "error");
                roomCodeInput.focus();
                return;
            }
            
            connectBtn.disabled = true;
            connectBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> CONNECTING...';
            connectStatus.innerHTML = '<i class="fas fa-search"></i> Searching for room...';
            updateConnectionStatus('connecting', 'Connecting to host...');
            
            gameState.isHost = false;
            gameState.playerId = 'joiner_' + generateSecureId();
            gameState.roomCode = roomCode;
            
            // Clear any old data
            localStorage.removeItem('playerAnswer');
            localStorage.removeItem('playerIceCandidate');
            
            // Search for host with timeout
            const searchTimeout = setTimeout(() => {
                connectBtn.disabled = false;
                connectBtn.innerHTML = '<i class="fas fa-link"></i> CONNECT';
                connectStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Room not found. Make sure host created room first.';
                updateConnectionStatus('disconnected', 'Room not found');
                showNotification("Room not found. Check code and try again.", "error");
            }, 10000);
            
            try {
                const hostData = await findHostOffer(roomCode);
                clearTimeout(searchTimeout);
                
                if (!hostData) {
                    connectBtn.disabled = false;
                    connectBtn.innerHTML = '<i class="fas fa-link"></i> CONNECT';
                    connectStatus.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Room not found or expired';
                    updateConnectionStatus('disconnected', 'Room not found');
                    showNotification("Room not found or expired", "error");
                    return;
                }
                
                gameState.prisonSeed = hostData.prisonSeed || Date.now();
                gameState.rng = new EnhancedRandom(gameState.prisonSeed);
                
                connectStatus.innerHTML = '<i class="fas fa-check"></i> Room found! Connecting...';
                
                // Create peer connection
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' }
                    ],
                    iceCandidatePoolSize: 10
                };
                
                gameState.peer = new RTCPeerConnection(configuration);
                
                // Set up data channel listener
                gameState.peer.ondatachannel = (event) => {
                    console.log('Data channel received');
                    gameState.dataChannel = event.channel;
                    setupDataChannel(gameState.dataChannel);
                };
                
                // Handle ICE candidates
                gameState.peer.onicecandidate = (event) => {
                    if (event.candidate) {
                        const candidateData = {
                            type: 'iceCandidate',
                            candidates: [{
                                candidate: event.candidate.candidate,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex
                            }],
                            roomCode: roomCode,
                            timestamp: Date.now()
                        };
                        localStorage.setItem('playerIceCandidate', JSON.stringify(candidateData));
                    }
                };
                
                // Handle connection state
                gameState.peer.onconnectionstatechange = () => {
                    console.log('Joiner connection state:', gameState.peer.connectionState);
                    if (gameState.peer.connectionState === 'connected') {
                        updateConnectionStatus('connected', 'Connected to host!');
                        connectStatus.innerHTML = '<i class="fas fa-check-circle"></i> Connected! Waiting for host...';
                        showWaitingScreen("Connected to host! Waiting for game to start...");
                    } else if (gameState.peer.connectionState === 'failed') {
                        updateConnectionStatus('disconnected', 'Connection failed');
                        connectStatus.innerHTML = '<i class="fas fa-times-circle"></i> Connection failed';
                    }
                };
                
                // Set remote description and create answer
                await gameState.peer.setRemoteDescription(new RTCSessionDescription(hostData.sdp));
                const answer = await gameState.peer.createAnswer();
                await gameState.peer.setLocalDescription(answer);
                
                // Store answer for host
                localStorage.setItem('playerAnswer', JSON.stringify({
                    sdp: gameState.peer.localDescription,
                    roomCode: roomCode,
                    playerId: gameState.playerId,
                    timestamp: Date.now(),
                    expires: Date.now() + 60000
                }));
                
                connectStatus.innerHTML = '<i class="fas fa-check-circle"></i> Connected! Waiting for host...';
                connectBtn.innerHTML = '<i class="fas fa-check"></i> CONNECTED';
                
                // Add stored ICE candidates from host
                const iceCandidates = JSON.parse(localStorage.getItem('iceCandidates') || '[]');
                iceCandidates.forEach(candidate => {
                    if (candidate) {
                        gameState.peer.addIceCandidate(new RTCIceCandidate(candidate))
                            .catch(e => console.warn('ICE candidate warning:', e));
                    }
                });
                
                console.log('Joiner connected to room:', roomCode);
                showNotification("Successfully connected to host!", "success");
                
            } catch (error) {
                console.error('Connection error:', error);
                clearTimeout(searchTimeout);
                updateConnectionStatus('disconnected', 'Connection failed');
                connectStatus.innerHTML = '<i class="fas fa-times-circle"></i> Connection failed';
                connectBtn.disabled = false;
                connectBtn.innerHTML = '<i class="fas fa-link"></i> CONNECT';
                showNotification("Connection failed: " + error.message, "error");
            }
        }

        async function findHostOffer(roomCode, maxAttempts = 20) {
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    const hostData = localStorage.getItem('hostOffer');
                    if (hostData) {
                        const data = JSON.parse(hostData);
                        
                        // Check if room code matches and offer hasn't expired
                        if (data.roomCode === roomCode && 
                            Date.now() < (data.expires || data.timestamp + 180000)) {
                            return data;
                        }
                    }
                } catch (e) {
                    console.warn('Error reading host data:', e);
                }
                
                // Wait before next attempt
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            return null;
        }

        function setupDataChannel(channel) {
            console.log('Setting up enhanced data channel...');
            
            channel.onopen = () => {
                console.log('Data channel opened!');
                gameState.connectionEstablished = true;
                updateConnectionStatus('connected', 'Connected to partner');
                
                if (gameState.isHost) {
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('connectionCount').innerHTML = '<i class="fas fa-user-check"></i> Player connected! Ready to start!';
                    showNotification("Player connected successfully!", "success");
                } else {
                    showWaitingScreen("Connected! Waiting for host to start the game...");
                    showNotification("Connected to host! Waiting for game start...", "success");
                }
                
                sendNetworkMessage('playerJoin', {
                    playerId: gameState.playerId,
                    name: gameState.playerName,
                    isHost: gameState.isHost,
                    stats: gameState.stats
                });
            };
            
            channel.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleNetworkMessage(data);
                } catch (e) {
                    console.error('Error parsing network message:', e);
                }
            };
            
            channel.onclose = () => {
                console.log('Data channel closed');
                gameState.connectionEstablished = false;
                updateConnectionStatus('disconnected', 'Disconnected from partner');
                
                if (gameState.gameStarted) {
                    showNotification("Partner disconnected!", "warning");
                } else {
                    hideWaitingScreen();
                }
            };
            
            channel.onerror = (error) => {
                console.error('Data channel error:', error);
                showNotification("Network error occurred", "error");
            };
        }

        function sendNetworkMessage(type, data) {
            if (gameState.dataChannel && gameState.dataChannel.readyState === 'open') {
                const message = {
                    type: type,
                    sender: gameState.playerId,
                    data: data,
                    timestamp: Date.now(),
                    sequence: Math.random().toString(36).substr(2, 9)
                };
                try {
                    gameState.dataChannel.send(JSON.stringify(message));
                } catch (e) {
                    console.error('Error sending network message:', e);
                }
            }
        }

        function handleNetworkMessage(message) {
            switch (message.type) {
                case 'playerJoin':
                    handlePlayerJoin(message);
                    break;
                case 'playerUpdate':
                    updatePlayer(message.sender, message.data);
                    break;
                case 'gameStart':
                    startGameFromNetwork(message.data);
                    break;
                case 'itemCollected':
                    collectItemRemote(message.data);
                    break;
                case 'botUpdate':
                    updateBot(message.data);
                    break;
                case 'escapeAttempt':
                    handleEscapeAttempt(message.data);
                    break;
                case 'chat':
                    displayChatMessage(message.sender, message.data, false);
                    break;
                case 'gameOver':
                    handleGameOver(message.data);
                    break;
                case 'ping':
                    sendNetworkMessage('pong', { timestamp: message.data.timestamp });
                    break;
                case 'syncRequest':
                    handleSyncRequest(message.data);
                    break;
            }
        }

        function handlePlayerJoin(message) {
            const { playerId, name, isHost, stats } = message.data;
            
            if (playerId === gameState.playerId) return;
            
            if (!gameState.players[playerId]) {
                gameState.players[playerId] = {
                    id: playerId,
                    name: name || `Player ${isHost ? '1' : '2'}`,
                    position: { x: 10, y: 1, z: 0 },
                    health: 100,
                    contraband: 0,
                    reputation: 0,
                    inventory: [],
                    isLocal: false,
                    stats: stats || {}
                };
                
                document.getElementById('playerName2').textContent = ` (${gameState.players[playerId].name})`;
                updateConnectionStatus('connected', `Connected to ${gameState.players[playerId].name}`);
                
                if (gameState.isHost && !gameState.gameStarted) {
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('connectionCount').innerHTML = 
                        `<i class="fas fa-user-check"></i> ${gameState.players[playerId].name} connected! Ready to start!`;
                    showNotification(`${gameState.players[playerId].name} connected!`, "success");
                }
            }
        }

        // ============================================================================
        // ENHANCED GAME START
        // ============================================================================
        function startGame() {
            if (!gameState.isHost || !gameState.connectionEstablished) {
                showNotification("Wait for player to connect first", "warning");
                return;
            }
            
            showLoadingScreen(true);
            document.getElementById('loadingText').textContent = 'Generating prison layout...';
            
            // Initialize Three.js
            try {
                initThreeJS();
                
                // Generate enhanced prison
                generateEnhancedPrison(gameState.prisonSeed);
                
                // Create local player
                createPlayer(gameState.playerId, true);
                
                // Get player positions
                const playerPositions = {};
                Object.keys(gameState.players).forEach(playerId => {
                    playerPositions[playerId] = { 
                        x: gameState.rng.range(-15, 15), 
                        y: 1, 
                        z: gameState.rng.range(-15, 15) 
                    };
                });
                
                // Notify other player to start
                sendNetworkMessage('gameStart', {
                    prisonSeed: gameState.prisonSeed,
                    playerPositions: playerPositions,
                    gameTime: Date.now()
                });
                
                // Start countdown
                let countdown = 3;
                const countdownInterval = setInterval(() => {
                    document.getElementById('loadingText').textContent = `Starting in ${countdown}...`;
                    if (countdown <= 0) {
                        clearInterval(countdownInterval);
                        startGameLocal();
                    }
                    countdown--;
                }, 1000);
                
            } catch (error) {
                console.error('Error starting game:', error);
                showNotification("Error starting game: " + error.message, "error");
                showLoadingScreen(false);
            }
        }

        function startGameFromNetwork(data) {
            console.log('Starting game from network signal...');
            showLoadingScreen(true);
            document.getElementById('loadingText').textContent = 'Loading prison layout...';
            
            gameState.prisonSeed = data.prisonSeed;
            gameState.rng = new EnhancedRandom(gameState.prisonSeed);
            gameState.gameTime = data.gameTime || Date.now();
            
            try {
                initThreeJS();
                generateEnhancedPrison(gameState.prisonSeed);
                
                const myPosition = data.playerPositions[gameState.playerId] || { x: 10, y: 1, z: 0 };
                createPlayer(gameState.playerId, true);
                
                if (playerMesh && myPosition) {
                    playerMesh.position.set(myPosition.x, myPosition.y, myPosition.z);
                    if (gameState.players[gameState.playerId]) {
                        gameState.players[gameState.playerId].position = playerMesh.position;
                    }
                }
                
                // Start countdown
                let countdown = 3;
                const countdownInterval = setInterval(() => {
                    document.getElementById('loadingText').textContent = `Starting in ${countdown}...`;
                    if (countdown <= 0) {
                        clearInterval(countdownInterval);
                        startGameLocal();
                    }
                    countdown--;
                }, 1000);
                
            } catch (error) {
                console.error('Error joining game:', error);
                showNotification("Error joining game: " + error.message, "error");
                showLoadingScreen(false);
                hideWaitingScreen();
            }
        }

        function startGameLocal() {
            console.log('Starting game locally...');
            gameState.gameStarted = true;
            gameState.stats.gamesPlayed++;
            saveGameStats();
            
            // Hide all overlays
            showLoadingScreen(false);
            hideWaitingScreen();
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            
            // Show objective with animation
            const objective = document.getElementById('objective');
            objective.style.display = 'block';
            objective.style.animation = 'slideDown 0.5s';
            document.getElementById('objectiveText').textContent = "BREAK OUT OF MAXIMUM SECURITY";
            document.getElementById('objectiveSubtext').textContent = "Coordinate with your partner. Collect items, avoid guards, and escape!";
            
            // Start game loop
            animate();
            setupEventListeners();
            
            // Start game timer
            gameState.gameStartTime = Date.now();
            
            console.log('Game started successfully!');
            showNotification("Game started! Good luck inmates!", "success");
        }

        function showLoadingScreen(show) {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = show ? 'flex' : 'none';
            }
        }

        // ============================================================================
        // ENHANCED THREE.JS INITIALIZATION
        // ============================================================================
        function initThreeJS() {
            console.log('Initializing enhanced Three.js...');
            
            if (typeof THREE === 'undefined') {
                throw new Error('Three.js not loaded');
            }
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 10, 150);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 40);
            camera.lookAt(0, 0, 0);
            
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                throw new Error('Canvas element not found');
            }
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            // Enhanced lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 200, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Add hemisphere light for better outdoor feel
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x006400, 0.3);
            scene.add(hemisphereLight);
            
            // Enhanced ground
            const groundGeometry = new THREE.PlaneGeometry(400, 400);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a5c1a,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add grass texture effect
            const grassGeometry = new THREE.PlaneGeometry(400, 400, 20, 20);
            const grassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a8b2a,
                roughness: 1,
                metalness: 0
            });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = -0.49;
            
            // Displace vertices for terrain effect
            const positionAttribute = grassGeometry.getAttribute('position');
            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const z = positionAttribute.getZ(i);
                const distance = Math.sqrt(x * x + z * z);
                const noise = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 0.5;
                positionAttribute.setY(i, noise);
            }
            positionAttribute.needsUpdate = true;
            scene.add(grass);
            
            console.log('Three.js initialized successfully');
        }

        // ============================================================================
        // ENHANCED PRISON GENERATION
        // ============================================================================
        function generateEnhancedPrison(seed = Date.now()) {
            console.log('Generating enhanced prison with seed:', seed);
            
            const rng = new EnhancedRandom(seed);
            
            // Clear existing objects
            [wallMeshes, itemMeshes, botMeshes, cellMeshes].forEach(array => {
                array.forEach(mesh => {
                    if (mesh && mesh.parent) {
                        scene.remove(mesh);
                    }
                });
                array.length = 0;
            });
            
            gameState.items = [];
            gameState.bots = [];
            
            // Outer walls - more detailed
            const wallHeight = 10;
            const wallThickness = 3;
            const halfSize = CONFIG.PRISON_SIZE / 2;
            
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.8,
                metalness: 0.2
            });
            
            const barbedWireMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                roughness: 0.3,
                metalness: 0.7
            });
            
            // Main perimeter walls
            const walls = [
                { pos: [0, wallHeight/2, -halfSize], size: [CONFIG.PRISON_SIZE, wallHeight, wallThickness] },
                { pos: [0, wallHeight/2, halfSize], size: [CONFIG.PRISON_SIZE, wallHeight, wallThickness] },
                { pos: [halfSize, wallHeight/2, 0], size: [wallThickness, wallHeight, CONFIG.PRISON_SIZE] },
                { pos: [-halfSize, wallHeight/2, 0], size: [wallThickness, wallHeight, CONFIG.PRISON_SIZE] }
            ];
            
            walls.forEach(wall => {
                const geometry = new THREE.BoxGeometry(...wall.size);
                const mesh = new THREE.Mesh(geometry, wallMaterial);
                mesh.position.set(...wall.pos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                wallMeshes.push(mesh);
                
                // Add barbed wire on top
                const wireGeometry = new THREE.CylinderGeometry(0.2, 0.2, wall.size[0] - 2, 8);
                const wire = new THREE.Mesh(wireGeometry, barbedWireMaterial);
                wire.position.set(wall.pos[0], wall.pos[1] + wallHeight/2 + 1, wall.pos[2]);
                wire.castShadow = true;
                scene.add(wire);
                wallMeshes.push(wire);
            });
            
            // Watch towers at corners
            const towerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.6
            });
            
            const towerPositions = [
                [halfSize - 5, 15, halfSize - 5],
                [halfSize - 5, 15, -halfSize + 5],
                [-halfSize + 5, 15, halfSize - 5],
                [-halfSize + 5, 15, -halfSize + 5]
            ];
            
            towerPositions.forEach(pos => {
                const towerGeometry = new THREE.BoxGeometry(8, 20, 8);
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.set(...pos);
                tower.castShadow = true;
                tower.receiveShadow = true;
                scene.add(tower);
                wallMeshes.push(tower);
                
                // Tower platform
                const platformGeometry = new THREE.BoxGeometry(10, 2, 10);
                const platform = new THREE.Mesh(platformGeometry, towerMaterial);
                platform.position.set(pos[0], pos[1] + 11, pos[2]);
                scene.add(platform);
                wallMeshes.push(platform);
            });
            
            // Cell blocks - more varied
            const cellMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.7
            });
            
            for (let i = 0; i < CONFIG.CELL_COUNT; i++) {
                const row = Math.floor(i / 6);
                const col = i % 6;
                const x = (col - 2.5) * 18;
                const z = (row - 1.5) * 18;
                
                const cellGeometry = new THREE.BoxGeometry(10, 5, 8);
                const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                cell.position.set(x, 2.5, z);
                cell.castShadow = true;
                cell.receiveShadow = true;
                scene.add(cell);
                cellMeshes.push(cell);
                
                // Cell door
                const doorGeometry = new THREE.BoxGeometry(2, 4, 0.5);
                const door = new THREE.Mesh(doorGeometry, new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
                door.position.set(x + 4, 2, z);
                scene.add(door);
                cellMeshes.push(door);
            }
            
            // Administrative buildings
            const adminMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.5
            });
            
            const adminBuildings = [
                { pos: [0, 4, -40], size: [30, 8, 20], name: 'Wardens Office' },
                { pos: [40, 3, 0], size: [20, 6, 25], name: 'Guard Quarters' },
                { pos: [-40, 3, 0], size: [25, 6, 25], name: 'Infirmary' }
            ];
            
            adminBuildings.forEach(building => {
                const geometry = new THREE.BoxGeometry(...building.size);
                const mesh = new THREE.Mesh(geometry, adminMaterial);
                mesh.position.set(...building.pos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                wallMeshes.push(mesh);
            });
            
            // Generate items in logical locations
            CONFIG.ITEM_TYPES.forEach((itemType, index) => {
                let x, z;
                
                // Place items in logical locations
                switch(itemType.id) {
                    case 'shovel':
                        x = rng.range(-60, -30);
                        z = rng.range(-60, 60);
                        break;
                    case 'uniform':
                        x = rng.range(30, 60);
                        z = rng.range(-20, 20);
                        break;
                    case 'idcard':
                        x = rng.range(-10, 10);
                        z = rng.range(-60, -40);
                        break;
                    case 'key':
                        x = rng.range(0, 20);
                        z = rng.range(30, 60);
                        break;
                    default:
                        x = rng.range(-50, 50);
                        z = rng.range(-50, 50);
                }
                
                let geometry;
                switch(itemType.id) {
                    case 'shovel':
                        geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                        break;
                    case 'uniform':
                        geometry = new THREE.BoxGeometry(1.2, 0.3, 1.8);
                        break;
                    case 'crowbar':
                        geometry = new THREE.CylinderGeometry(0.15, 0.15, 1.2, 8);
                        break;
                    case 'wirecutters':
                        geometry = new THREE.BoxGeometry(0.5, 0.1, 0.3);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(0.6, 0.1, 0.8);
                }
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: itemType.color,
                    roughness: 0.4,
                    metalness: 0.6,
                    emissive: itemType.color,
                    emissiveIntensity: 0.1
                });
                
                const item = new THREE.Mesh(geometry, material);
                item.position.set(x, 1.5, z);
                item.rotation.y = rng.range(0, Math.PI * 2);
                item.castShadow = true;
                item.userData = {
                    type: itemType.id,
                    collected: false,
                    index: index,
                    value: itemType.value,
                    name: itemType.name
                };
                
                // Add pulsing animation
                item.userData.pulseSpeed = 0.02 + rng.random() * 0.03;
                item.userData.pulsePhase = rng.random() * Math.PI * 2;
                
                scene.add(item);
                itemMeshes.push(item);
                
                gameState.items.push({
                    type: itemType.id,
                    position: { x, y: 1.5, z },
                    collected: false,
                    value: itemType.value
                });
            });
            
            // Generate enhanced bots with personalities
            for (let i = 0; i < CONFIG.GUARD_COUNT; i++) {
                const guardType = rng.choice(CONFIG.GUARD_TYPES);
                const x = rng.range(-40, 40);
                const z = rng.range(-40, 40);
                
                const geometry = new THREE.CylinderGeometry(0.7, 0.7, 2.2, 12);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x0000ff,
                    roughness: 0.2,
                    metalness: 0.8
                });
                
                const bot = new THREE.Mesh(geometry, material);
                bot.position.set(x, 1.1, z);
                bot.castShadow = true;
                scene.add(bot);
                botMeshes.push(bot);
                
                const patrolPath = [];
                const waypointCount = guardType.type === 'stationary' ? 2 : 4;
                for (let j = 0; j < waypointCount; j++) {
                    patrolPath.push({
                        x: x + rng.range(-15, 15),
                        z: z + rng.range(-15, 15)
                    });
                }
                
                gameState.bots.push({
                    type: 'guard',
                    guardType: guardType.type,
                    position: { x, y: 1.1, z },
                    patrolPath,
                    patrolIndex: 0,
                    alertLevel: 0,
                    personality: rng.choice(['strict', 'lazy', 'vigilant', 'corrupt']),
                    speed: guardType.speed,
                    vision: guardType.vision,
                    aggression: guardType.aggression,
                    lastDetection: 0,
                    state: 'patrolling'
                });
            }
            
            // Inmate bots with behaviors
            for (let i = 0; i < CONFIG.INMATE_BOT_COUNT; i++) {
                const x = rng.range(-30, 30);
                const z = rng.range(-30, 30);
                
                const geometry = new THREE.BoxGeometry(1.2, 2.2, 1.2);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xaa0000,
                    roughness: 0.7
                });
                
                const bot = new THREE.Mesh(geometry, material);
                bot.position.set(x, 1.1, z);
                bot.castShadow = true;
                scene.add(bot);
                botMeshes.push(bot);
                
                const personality = rng.choice(['lazy', 'violent', 'helpful', 'nervous', 'reckless']);
                let speed;
                switch(personality) {
                    case 'violent': speed = 0.04; break;
                    case 'nervous': speed = 0.03; break;
                    case 'reckless': speed = 0.05; break;
                    default: speed = 0.02;
                }
                
                gameState.bots.push({
                    type: 'inmate',
                    position: { x, y: 1.1, z },
                    personality: personality,
                    speed: speed,
                    activity: 'wandering',
                    lastActivityChange: 0,
                    mood: rng.choice(['calm', 'agitated', 'bored', 'curious']),
                    interactionCooldown: 0
                });
            }
            
            // Add environmental props
            addEnvironmentalProps(rng);
            
            console.log('Enhanced prison generated');
        }

        function addEnvironmentalProps(rng) {
            // Light posts
            const lightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                roughness: 0.1,
                metalness: 0.9
            });
            
            const lightPositions = [
                [40, 8, 40], [40, 8, -40], [-40, 8, 40], [-40, 8, -40],
                [0, 8, 40], [0, 8, -40], [40, 8, 0], [-40, 8, 0]
            ];
            
            lightPositions.forEach(pos => {
                const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, 15, 8);
                const pole = new THREE.Mesh(poleGeometry, lightMaterial);
                pole.position.set(pos[0], 7.5, pos[1]);
                scene.add(pole);
                
                const lightGeometry = new THREE.SphereGeometry(1.5, 16, 16);
                const light = new THREE.Mesh(lightGeometry, new THREE.MeshStandardMaterial({ 
                    color: 0xffffcc,
                    emissive: 0xffffcc,
                    emissiveIntensity: 0.5
                }));
                light.position.set(pos[0], 15, pos[1]);
                scene.add(light);
                
                // Add point light
                const pointLight = new THREE.PointLight(0xffffcc, 1, 50);
                pointLight.position.set(pos[0], 13, pos[1]);
                scene.add(pointLight);
            });
            
            // Obstacles and cover
            const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.8
            });
            
            for (let i = 0; i < 20; i++) {
                const x = rng.range(-50, 50);
                const z = rng.range(-50, 50);
                
                // Avoid placing in important areas
                if (Math.abs(x) < 30 && Math.abs(z) < 30) continue;
                
                const width = rng.range(2, 6);
                const height = rng.range(1.5, 3);
                const depth = rng.range(2, 6);
                
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
                obstacle.position.set(x, height/2, z);
                obstacle.castShadow = true;
                scene.add(obstacle);
            }
        }

        // ============================================================================
        // ENHANCED PLAYER MANAGEMENT
        // ============================================================================
        function createPlayer(playerId, isLocal) {
            const geometry = new THREE.CapsuleGeometry(0.5, 1.5, 8, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color: isLocal ? 0xff4444 : 0x00ff88,
                roughness: 0.5,
                metalness: 0.3,
                emissive: isLocal ? 0xff0000 : 0x00ff00,
                emissiveIntensity: 0.1
            });
            
            const player = new THREE.Mesh(geometry, material);
            player.castShadow = true;
            
            if (isLocal) {
                playerMesh = player;
                playerMesh.position.set(isLocal ? -15 : 15, 1.5, 0);
            } else {
                otherPlayerMesh = player;
                otherPlayerMesh.position.set(isLocal ? -15 : 15, 1.5, 0);
            }
            
            scene.add(player);
            
            if (!gameState.players[playerId]) {
                gameState.players[playerId] = {
                    id: playerId,
                    name: isLocal ? 'You' : 'Partner',
                    position: player.position,
                    health: 100,
                    contraband: 0,
                    reputation: 0,
                    inventory: [],
                    isLocal: isLocal,
                    mesh: player,
                    lastUpdate: Date.now()
                };
            } else {
                gameState.players[playerId].mesh = player;
                gameState.players[playerId].isLocal = isLocal;
            }
            
            if (isLocal) {
                document.getElementById('playerName1').textContent = ' (You)';
            } else {
                document.getElementById('playerName2').textContent = ' (Partner)';
            }
            
            return player;
        }

        function updatePlayer(playerId, data) {
            if (!gameState.players[playerId]) return;
            
            const player = gameState.players[playerId];
            const now = Date.now();
            
            // Smooth position interpolation
            if (player.mesh && !player.isLocal) {
                if (data.x !== undefined) {
                    player.targetX = data.x;
                    player.targetZ = data.z;
                    player.targetY = data.y || 1.5;
                    player.targetRY = data.ry || 0;
                    player.lastUpdate = now;
                }
                
                // Interpolate position
                if (player.targetX !== undefined) {
                    const alpha = Math.min(1, (now - player.lastUpdate) / 100);
                    player.mesh.position.x += (player.targetX - player.mesh.position.x) * alpha;
                    player.mesh.position.z += (player.targetZ - player.mesh.position.z) * alpha;
                    player.mesh.position.y += (player.targetY - player.mesh.position.y) * alpha;
                    player.mesh.rotation.y += (player.targetRY - player.mesh.rotation.y) * alpha;
                }
            }
            
            // Update stats
            if (data.health !== undefined) player.health = data.health;
            if (data.contraband !== undefined) player.contraband = data.contraband;
            if (data.reputation !== undefined) player.reputation = data.reputation;
            if (data.inventory !== undefined) player.inventory = data.inventory;
            
            if (playerId !== gameState.playerId) {
                updatePlayerUI(2, player);
            }
        }

        // ============================================================================
        // ENHANCED GAME LOOP
        // ============================================================================
        function animate() {
            if (!gameState.gameStarted) {
                requestAnimationFrame(animate);
                return;
            }
            
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            gameState.lastUpdate += deltaTime;
            
            if (gameState.lastUpdate >= 1/60) {
                gameState.lastUpdate = 0;
                
                updateLocalPlayer();
                updateEnhancedBots(deltaTime);
                updateItems(deltaTime);
                checkCollisions();
                updateCamera();
                updateTimeOfDay(deltaTime);
                
                // Update game timer
                if (gameState.gameStartTime) {
                    gameState.stats.timePlayed += deltaTime;
                }
            }
            
            renderer.render(scene, camera);
        }

        function updateLocalPlayer() {
            if (!playerMesh || !gameState.players[gameState.playerId]) return;
            
            const player = gameState.players[gameState.playerId];
            const speed = isRunning ? moveSpeed * 1.8 : moveSpeed;
            
            // Movement
            const moveX = (keys['d'] || keys['arrowright'] ? 1 : 0) - (keys['a'] || keys['arrowleft'] ? 1 : 0);
            const moveZ = (keys['s'] || keys['arrowdown'] ? 1 : 0) - (keys['w'] || keys['arrowup'] ? 1 : 0);
            
            if (moveX !== 0 || moveZ !== 0) {
                const moveLength = Math.sqrt(moveX * moveX + moveZ * moveZ);
                const normalizedX = moveX / moveLength;
                const normalizedZ = moveZ / moveLength;
                
                playerMesh.position.x += normalizedX * speed;
                playerMesh.position.z += normalizedZ * speed;
                
                // Rotate player towards movement direction
                if (moveX !== 0) {
                    playerMesh.rotation.y = Math.atan2(normalizedX, normalizedZ);
                }
            }
            
            // Jump
            if (keys[' '] && playerMesh.position.y <= 1.6) {
                playerMesh.position.y += 0.25;
            }
            
            // Gravity
            if (playerMesh.position.y > 1.5) {
                playerMesh.position.y -= 0.08;
            }
            
            // Boundary check
            const halfSize = CONFIG.PRISON_SIZE / 2 - 8;
            playerMesh.position.x = Math.max(-halfSize, Math.min(halfSize, playerMesh.position.x));
            playerMesh.position.z = Math.max(-halfSize, Math.min(halfSize, playerMesh.position.z));
            
            player.position = playerMesh.position;
            
            // Network update
            if (gameState.connectionEstablished && Date.now() - (player.lastNetworkUpdate || 0) > 100) {
                sendNetworkMessage('playerUpdate', {
                    x: playerMesh.position.x,
                    y: playerMesh.position.y,
                    z: playerMesh.position.z,
                    ry: playerMesh.rotation.y,
                    health: player.health,
                    contraband: player.contraband,
                    reputation: player.reputation,
                    inventory: player.inventory
                });
                player.lastNetworkUpdate = Date.now();
            }
            
            updatePlayerUI(1, player);
        }

        function updateEnhancedBots(deltaTime) {
            const now = Date.now();
            
            gameState.bots.forEach((bot, index) => {
                if (!botMeshes[index]) return;
                
                const mesh = botMeshes[index];
                
                if (bot.type === 'guard') {
                    updateGuardBot(bot, index, deltaTime, now);
                } else if (bot.type === 'inmate') {
                    updateInmateBot(bot, index, deltaTime, now);
                }
                
                // Update mesh position
                mesh.position.set(bot.position.x, bot.position.y, bot.position.z);
                
                // Visual state updates
                updateBotVisuals(bot, mesh);
            });
        }

        function updateGuardBot(bot, index, deltaTime, now) {
            // State machine for guard behavior
            switch(bot.state) {
                case 'patrolling':
                    updatePatrol(bot, deltaTime);
                    checkPlayerDetection(bot, index, now);
                    break;
                    
                case 'alert':
                    if (bot.alertTarget && playerMesh) {
                        const dx = bot.alertTarget.x - bot.position.x;
                        const dz = bot.alertTarget.z - bot.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance > 2) {
                            bot.position.x += (dx / distance) * bot.speed * 1.5;
                            bot.position.z += (dz / distance) * bot.speed * 1.5;
                        } else {
                            bot.state = 'investigating';
                            bot.investigateTime = now + 3000;
                        }
                    }
                    break;
                    
                case 'investigating':
                    if (now > bot.investigateTime) {
                        bot.state = 'patrolling';
                        bot.alertLevel *= 0.5;
                    }
                    break;
                    
                case 'chasing':
                    if (playerMesh && bot.alertLevel > 50) {
                        const dx = playerMesh.position.x - bot.position.x;
                        const dz = playerMesh.position.z - bot.position.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance < 2) {
                            // Caught player!
                            sendToSolitary("Caught by guard during chase!");
                        } else {
                            bot.position.x += (dx / distance) * bot.speed * 2;
                            bot.position.z += (dz / distance) * bot.speed * 2;
                        }
                        
                        // Alert other guards
                        if (distance < 30 && Math.random() < 0.1) {
                            alertNearbyGuards(bot.position, index);
                        }
                    } else {
                        bot.state = 'patrolling';
                    }
                    break;
            }
            
            // Natural alert decay
            if (bot.alertLevel > 0) {
                bot.alertLevel -= deltaTime * (bot.personality === 'vigilant' ? 5 : 10);
                if (bot.alertLevel < 0) bot.alertLevel = 0;
            }
        }

        function updatePatrol(bot, deltaTime) {
            if (!bot.patrolPath || bot.patrolPath.length === 0) return;
            
            const target = bot.patrolPath[bot.patrolIndex];
            const dx = target.x - bot.position.x;
            const dz = target.z - bot.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance < 1) {
                bot.patrolIndex = (bot.patrolIndex + 1) % bot.patrolPath.length;
                // Add some randomness to wait time
                if (Math.random() < 0.3 && bot.guardType !== 'stationary') {
                    bot.waitingUntil = Date.now() + 1000 + Math.random() * 2000;
                }
            } else {
                if (!bot.waitingUntil || Date.now() > bot.waitingUntil) {
                    bot.position.x += (dx / distance) * bot.speed;
                    bot.position.z += (dz / distance) * bot.speed;
                }
            }
        }

        function checkPlayerDetection(bot, index, now) {
            if (!playerMesh || bot.alertLevel > 50 || now - bot.lastDetection < 1000) return;
            
            const dx = playerMesh.position.x - bot.position.x;
            const dz = playerMesh.position.z - bot.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance < bot.vision) {
                // Line of sight check (simplified)
                const canSee = true; // In full game, implement raycasting
                
                if (canSee) {
                    const detectionChance = (1 - distance/bot.vision) * bot.aggression;
                    
                    // Stealth factors
                    if (gameState.isNight) detectionChance *= 0.7;
                    if (isRunning) detectionChance *= 1.3;
                    
                    if (Math.random() < detectionChance * 0.1) {
                        bot.alertLevel += 30;
                        bot.lastDetection = now;
                        
                        if (bot.alertLevel > 50) {
                            bot.state = 'chasing';
                            showNotification("Guard spotted you!", 'warning');
                            
                            // Network update
                            sendNetworkMessage('botUpdate', { 
                                index, 
                                alertLevel: bot.alertLevel,
                                state: bot.state 
                            });
                        }
                    }
                }
            }
        }

        function alertNearbyGuards(position, sourceIndex) {
            gameState.bots.forEach((bot, index) => {
                if (index !== sourceIndex && bot.type === 'guard') {
                    const dx = bot.position.x - position.x;
                    const dz = bot.position.z - position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 40) {
                        bot.alertLevel += 20;
                        if (bot.alertLevel > 40) {
                            bot.state = 'alert';
                            bot.alertTarget = { x: position.x, z: position.z };
                        }
                    }
                }
            });
        }

        function updateInmateBot(bot, deltaTime, now) {
            // Behavior based on personality
            switch(bot.personality) {
                case 'lazy':
                    if (Math.random() < 0.01) {
                        bot.position.x += (Math.random() - 0.5) * 0.5;
                        bot.position.z += (Math.random() - 0.5) * 0.5;
                    }
                    break;
                    
                case 'violent':
                    if (Math.random() < 0.02) {
                        bot.position.x += (Math.random() - 0.5) * 2;
                        bot.position.z += (Math.random() - 0.5) * 2;
                    }
                    break;
                    
                case 'helpful':
                    // Move towards items
                    if (Math.random() < 0.015) {
                        const nearestItem = findNearestItem(bot.position);
                        if (nearestItem) {
                            const dx = nearestItem.x - bot.position.x;
                            const dz = nearestItem.z - bot.position.z;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            if (distance > 1) {
                                bot.position.x += (dx / distance) * bot.speed;
                                bot.position.z += (dz / distance) * bot.speed;
                            }
                        }
                    }
                    break;
                    
                default:
                    if (Math.random() < 0.01) {
                        bot.position.x += (Math.random() - 0.5) * 1.5;
                        bot.position.z += (Math.random() - 0.5) * 1.5;
                    }
            }
            
            // Boundary check
            const halfSize = CONFIG.PRISON_SIZE / 2 - 10;
            bot.position.x = Math.max(-halfSize, Math.min(halfSize, bot.position.x));
            bot.position.z = Math.max(-halfSize, Math.min(halfSize, bot.position.z));
            
            // Mood changes
            if (now - bot.lastActivityChange > 10000) {
                bot.mood = gameState.rng.choice(['calm', 'agitated', 'bored', 'curious']);
                bot.lastActivityChange = now;
            }
        }

        function updateBotVisuals(bot, mesh) {
            // Update guard alert level visuals
            if (bot.type === 'guard') {
                if (bot.alertLevel > 50) {
                    mesh.material.color.setHex(0xff0000);
                    mesh.material.emissive.setHex(0xff0000);
                    mesh.material.emissiveIntensity = 0.3;
                } else if (bot.alertLevel > 20) {
                    mesh.material.color.setHex(0xff8800);
                    mesh.material.emissive.setHex(0xff8800);
                    mesh.material.emissiveIntensity = 0.1;
                } else {
                    mesh.material.color.setHex(0x0000ff);
                    mesh.material.emissive.setHex(0x0000ff);
                    mesh.material.emissiveIntensity = 0.05;
                }
            }
        }

        function updateItems(deltaTime) {
            itemMeshes.forEach((item, index) => {
                if (item && !item.userData.collected) {
                    // Pulsing animation
                    const pulse = Math.sin(Date.now() * item.userData.pulseSpeed + item.userData.pulsePhase) * 0.2;
                    item.position.y = 1.5 + pulse;
                    item.rotation.y += deltaTime * 0.5;
                    
                    // Glow effect
                    item.material.emissiveIntensity = 0.1 + Math.abs(pulse) * 0.2;
                }
            });
        }

        function findNearestItem(position) {
            let nearest = null;
            let nearestDistance = Infinity;
            
            gameState.items.forEach(item => {
                if (!item.collected) {
                    const dx = item.position.x - position.x;
                    const dz = item.position.z - position.z;
                    const distance = dx * dx + dz * dz;
                    
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearest = item.position;
                    }
                }
            });
            
            return nearest;
        }

        function updateBot(data) {
            const { index, alertLevel, state } = data;
            
            if (gameState.bots[index]) {
                if (alertLevel !== undefined) {
                    gameState.bots[index].alertLevel = alertLevel;
                }
                if (state !== undefined) {
                    gameState.bots[index].state = state;
                }
            }
        }

        function checkCollisions() {
            if (!playerMesh) return;
            
            const player = gameState.players[gameState.playerId];
            
            // Item collection
            itemMeshes.forEach((item, index) => {
                if (item && !item.userData.collected) {
                    const distance = playerMesh.position.distanceTo(item.position);
                    if (distance < 2) {
                        collectItem(item.userData.type, index);
                    }
                }
            });
            
            // Guard collision
            gameState.bots.forEach((bot, index) => {
                if (bot.type === 'guard' && bot.state === 'chasing') {
                    const dx = playerMesh.position.x - bot.position.x;
                    const dz = playerMesh.position.z - bot.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 2.5) {
                        sendToSolitary("Caught by pursuing guard!");
                    }
                }
            });
            
            // Boundary collision
            const halfSize = CONFIG.PRISON_SIZE / 2 - 1;
            if (Math.abs(playerMesh.position.x) > halfSize || 
                Math.abs(playerMesh.position.z) > halfSize) {
                playerMesh.position.x = Math.max(-halfSize, Math.min(halfSize, playerMesh.position.x));
                playerMesh.position.z = Math.max(-halfSize, Math.min(halfSize, playerMesh.position.z));
            }
        }

        function updateCamera() {
            if (!playerMesh) return;
            
            const cameraDistance = 20;
            const cameraHeight = 12;
            
            // Smooth camera follow
            const targetX = playerMesh.position.x;
            const targetZ = playerMesh.position.z + cameraDistance;
            const targetY = playerMesh.position.y + cameraHeight;
            
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.z += (targetZ - camera.position.z) * 0.1;
            camera.position.y += (targetY - camera.position.y) * 0.1;
            
            camera.lookAt(
                playerMesh.position.x,
                playerMesh.position.y + 2,
                playerMesh.position.z
            );
        }

        function updateTimeOfDay(deltaTime) {
            gameState.timeOfDay += deltaTime / CONFIG.DAY_CYCLE;
            if (gameState.timeOfDay >= 1) gameState.timeOfDay = 0;
            
            const wasNight = gameState.isNight;
            gameState.isNight = gameState.timeOfDay < 0.25 || gameState.timeOfDay > 0.75;
            
            // Update lighting based on time
            const timeFactor = Math.sin(gameState.timeOfDay * Math.PI * 2);
            const ambientIntensity = 0.3 + timeFactor * 0.2;
            scene.children.forEach(child => {
                if (child.isLight) {
                    if (child.type === 'AmbientLight') {
                        child.intensity = ambientIntensity;
                    } else if (child.type === 'DirectionalLight') {
                        child.intensity = 0.5 + timeFactor * 0.3;
                    }
                }
            });
            
            // Day/Night transition notification
            if (wasNight !== gameState.isNight && gameState.gameStarted) {
                showNotification(gameState.isNight ? "Night has fallen" : "Morning has come", "info");
            }
        }

        // ============================================================================
        // ENHANCED GAME MECHANICS
        // ============================================================================
        function collectItem(type, index) {
            const player = gameState.players[gameState.playerId];
            
            if (!player.inventory.includes(type)) {
                player.inventory.push(type);
                player.contraband++;
                gameState.stats.itemsCollected++;
                
                const itemType = CONFIG.ITEM_TYPES.find(i => i.id === type);
                const itemValue = itemType ? itemType.value : 10;
                player.reputation += itemValue;
                
                if (itemMeshes[index]) {
                    itemMeshes[index].visible = false;
                    itemMeshes[index].userData.collected = true;
                }
                if (gameState.items[index]) {
                    gameState.items[index].collected = true;
                }
                
                sendNetworkMessage('itemCollected', { index, type, value: itemValue });
                updateInventoryUI();
                updateEscapeOptions();
                
                showNotification(`Acquired: ${itemType ? itemType.name : type} (+${itemValue} rep)`, 'success');
                
                // Save stats
                saveGameStats();
            }
        }

        function collectItemRemote(data) {
            const { index, type, value } = data;
            if (itemMeshes[index]) {
                itemMeshes[index].visible = false;
                itemMeshes[index].userData.collected = true;
            }
            
            const itemType = CONFIG.ITEM_TYPES.find(i => i.id === type);
            showNotification(`Partner found: ${itemType ? itemType.name : type}`, 'info');
        }

        function updateInventoryUI() {
            const player = gameState.players[gameState.playerId];
            const inventoryDiv = document.getElementById('inventoryItems');
            const countSpan = document.getElementById('inventoryCount');
            
            inventoryDiv.innerHTML = '';
            countSpan.textContent = `(${player.inventory.length})`;
            
            player.inventory.forEach((itemId, index) => {
                const itemType = CONFIG.ITEM_TYPES.find(i => i.id === itemId);
                if (!itemType) return;
                
                const div = document.createElement('div');
                div.className = 'inventory-item';
                div.innerHTML = `
                    <div class="inventory-icon" style="background: ${itemType.color}20; border-color: ${itemType.color}">
                        ${itemType.icon}
                    </div>
                    <div style="flex: 1;">
                        <div style="font-weight: bold;">${itemType.name}</div>
                        <div style="font-size: 0.9em; color: #88ccff;">Value: ${itemType.value} rep</div>
                    </div>
                `;
                inventoryDiv.appendChild(div);
            });
            
            const progress = calculateEscapeProgress();
            document.getElementById('escapeProgress').style.width = `${progress}%`;
        }

        function calculateEscapeProgress() {
            const player = gameState.players[gameState.playerId];
            let progress = 0;
            
            // Items contribute to progress
            progress += player.inventory.length * 8;
            
            // Reputation contributes
            progress += Math.min(player.reputation, 100) * 0.3;
            
            // Penalty for guard alerts
            const alertCount = gameState.bots.filter(b => b.type === 'guard' && b.alertLevel > 30).length;
            progress -= alertCount * 5;
            
            // Bonus for partner coordination
            if (Object.keys(gameState.players).length > 1) {
                progress += 10;
            }
            
            return Math.max(0, Math.min(100, progress));
        }

        function updateEscapeOptions() {
            const player = gameState.players[gameState.playerId];
            
            Object.keys(CONFIG.ESCAPE_REQUIREMENTS).forEach(method => {
                const option = document.getElementById('escape' + method.charAt(0).toUpperCase() + method.slice(1));
                if (!option) return;
                
                const requirements = CONFIG.ESCAPE_REQUIREMENTS[method];
                let canEscape = true;
                let missingRequirements = [];
                
                requirements.forEach(req => {
                    if (req.includes('reputation')) {
                        const needed = parseInt(req.split('_')[1]);
                        if (player.reputation < needed) {
                            canEscape = false;
                            missingRequirements.push(`${needed} reputation`);
                        }
                    } else if (req === 'clean_record') {
                        if (player.contraband > 0) {
                            canEscape = false;
                            missingRequirements.push('clean record');
                        }
                    } else {
                        if (!player.inventory.includes(req)) {
                            canEscape = false;
                            const item = CONFIG.ITEM_TYPES.find(i => i.id === req);
                            missingRequirements.push(item ? item.name : req);
                        }
                    }
                });
                
                if (canEscape) {
                    option.classList.add('ready');
                    option.classList.remove('disabled');
                    option.title = 'Ready to attempt!';
                } else {
                    option.classList.remove('ready');
                    option.classList.add('disabled');
                    option.title = `Missing: ${missingRequirements.join(', ')}`;
                }
            });
        }

        // ============================================================================
        // ENHANCED ESCAPE MECHANICS
        // ============================================================================
        function toggleEscapeMenu() {
            const menu = document.getElementById('escapeMenu');
            menu.style.display = menu.style.display === 'grid' ? 'none' : 'grid';
            
            if (menu.style.display === 'grid') {
                updateEscapeOptions();
            }
        }

        function startEscape(method) {
            const option = document.getElementById('escape' + method.charAt(0).toUpperCase() + method.slice(1));
            if (option.classList.contains('disabled')) {
                const requirements = option.title.replace('Missing: ', '');
                showNotification(`Cannot escape: Need ${requirements}`, 'warning');
                return;
            }
            
            toggleEscapeMenu();
            showNotification(`Initiating ${method} escape plan...`, 'info');
            
            gameState.escapeInProgress = true;
            
            sendNetworkMessage('escapeAttempt', {
                method: method,
                playerId: gameState.playerId,
                timestamp: Date.now()
            });
            
            // Show escape progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                if (!gameState.escapeInProgress) {
                    clearInterval(progressInterval);
                    return;
                }
                
                progress += 5;
                showNotification(`Escape progress: ${progress}%`, 'info');
                
                if (progress >= 100) {
                    clearInterval(progressInterval);
                    const success = attemptEscape(method);
                    
                    if (success) {
                        escapeSuccess(method);
                    } else {
                        escapeFailure(method);
                    }
                    gameState.escapeInProgress = false;
                }
            }, 500);
        }

        function attemptEscape(method) {
            const player = gameState.players[gameState.playerId];
            let successChance = 0.5;
            
            // Base chances based on method
            switch(method) {
                case 'tunnel': 
                    successChance = 0.6;
                    if (player.inventory.includes('crowbar')) successChance += 0.1;
                    break;
                case 'disguise': 
                    successChance = 0.7;
                    if (player.reputation > 30) successChance += 0.1;
                    break;
                case 'riot': 
                    successChance = 0.5 + (player.reputation / 200);
                    break;
                case 'parole': 
                    successChance = 0.8 - (player.contraband * 0.05);
                    break;
            }
            
            // Partner coordination bonus
            if (Object.keys(gameState.players).length > 1) {
                successChance += 0.2;
            }
            
            // Time of day modifier
            if (gameState.isNight) {
                successChance += 0.15;
            } else {
                successChance += 0.05;
            }
            
            // Guard alert penalty
            const alertCount = gameState.bots.filter(b => b.type === 'guard' && b.alertLevel > 40).length;
            successChance -= alertCount * 0.1;
            
            return Math.random() < Math.min(0.95, Math.max(0.05, successChance));
        }

        function escapeSuccess(method) {
            gameState.stats.escapes++;
            saveGameStats();
            
            const funnyMessages = {
                tunnel: [
                    "You emerged in a field of freedom! The tunnel held.",
                    "Dirt-covered but victorious! The guards never saw it coming.",
                    "Your engineering skills paid off! Freedom tastes like soil."
                ],
                disguise: [
                    "The guards saluted you on the way out! Perfect uniform fit.",
                    "Walked right through the front gate. Confidence is key.",
                    "Security didn't even blink. That ID card was flawless."
                ],
                riot: [
                    "Chaos was your best friend! Slipped away unnoticed.",
                    "While guards dealt with the riot, you made your exit.",
                    "The distraction worked perfectly! Freedom in the confusion."
                ],
                parole: [
                    "Paperwork processed! You're officially a free citizen.",
                    "Legal loopholes for the win! The system worked for once.",
                    "Released on good behavior. Who said crime doesn't pay?"
                ]
            };
            
            const messages = funnyMessages[method] || ["You made it out! Freedom!"];
            const message = messages[Math.floor(Math.random() * messages.length)];
            
            const escapeTime = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            const minutes = Math.floor(escapeTime / 60);
            const seconds = escapeTime % 60;
            
            alert(`ðŸŽ‰ ESCAPE SUCCESSFUL! ðŸŽ‰\n\n` +
                  `Method: ${method.toUpperCase()}\n` +
                  `Time: ${minutes}m ${seconds}s\n` +
                  `Items Collected: ${gameState.players[gameState.playerId].inventory.length}\n` +
                  `Reputation: ${gameState.players[gameState.playerId].reputation}\n\n` +
                  `${message}\n\n` +
                  `Refresh to play again.`);
            
            sendNetworkMessage('gameOver', { 
                success: true, 
                method: method,
                time: escapeTime,
                stats: gameState.stats 
            });
        }

        function escapeFailure(method) {
            const failureReasons = {
                tunnel: ["Tunnel collapsed! Too much groundwater.", "Discovered by patrol dogs!", "Hit a concrete foundation."],
                disguise: ["ID card was expired!", "Uniform didn't fit right.", "Recognized by former cellmate guard."],
                riot: ["Nobody showed up to your riot!", "Guards were ready and waiting.", "Other inmates snitched."],
                parole: ["Warden denied your parole.", "Paperwork got 'lost'.", "Previous escape attempt discovered."]
            };
            
            const reasons = failureReasons[method] || ["Something went wrong!"];
            const reason = reasons[Math.floor(Math.random() * reasons.length)];
            
            sendToSolitary(`${reason} ${method} escape failed.`);
            sendNetworkMessage('gameOver', { success: false, method: method, reason: reason });
        }

        function handleEscapeAttempt(data) {
            const { method, playerId } = data;
            showNotification(`Partner attempting ${method} escape...`, 'info');
        }

        // ============================================================================
        // ENHANCED FAILURE SYSTEM
        // ============================================================================
        function sendToSolitary(reason) {
            gameState.gameStarted = false;
            
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('solitaryScreen').style.display = 'flex';
            
            document.getElementById('failReason').textContent = reason;
            
            const funnyMessages = [
                "The guards are having donuts while you contemplate your choices...",
                "At least the rats are good listeners. Tell them your plans!",
                "Solitary: where great escape plans go to think about what they've done.",
                "You had time to count the bricks. There are 1,247. Exactly.",
                "The warden sends his regards... and a bill for damages.",
                "Even the cockroaches are giving you judgmental looks.",
                "Welcome to your 'quiet time' vacation package!",
                "The only thing escaping now is your sanity.",
                "Great attempt! (Said no one in solitary.)",
                "At least the food is consistently terrible here."
            ];
            
            const funnyMessage = funnyMessages[Math.floor(Math.random() * funnyMessages.length)];
            document.getElementById('funnyMessage').textContent = funnyMessage;
            
            const hint = CONFIG.ESCAPE_HINTS[Math.floor(Math.random() * CONFIG.ESCAPE_HINTS.length)];
            document.getElementById('escapeHint').textContent = `ðŸ’¡ Pro Tip: ${hint}`;
            
            animateSolitaryScene();
            
            if (gameState.connectionEstablished) {
                sendNetworkMessage('gameOver', { success: false, reason: reason });
            }
        }

        function handleGameOver(data) {
            if (data.success) {
                const timeStr = data.time ? `${Math.floor(data.time/60)}m ${data.time%60}s` : '';
                showNotification(`Partner escaped via ${data.method}! (${timeStr})`, 'success');
            } else {
                showNotification(`Partner caught: ${data.reason || 'Escape failed'}`, 'warning');
            }
        }

        function animateSolitaryScene() {
            const animationDiv = document.getElementById('solitaryAnimation');
            animationDiv.innerHTML = '';
            
            // Create prison bars
            for (let i = 0; i < 10; i++) {
                const bar = document.createElement('div');
                bar.className = 'inmate-cell';
                bar.style.left = (i * 45 + 10) + 'px';
                bar.style.height = '180px';
                bar.style.background = `linear-gradient(to right, #666, #333, #666)`;
                animationDiv.appendChild(bar);
            }
            
            // Create inmate
            const inmate = document.createElement('div');
            inmate.className = 'inmate';
            inmate.style.left = '220px';
            inmate.style.background = 'linear-gradient(to bottom, #cc0000, #660000)';
            animationDiv.appendChild(inmate);
            
            // Create guard
            const guard = document.createElement('div');
            guard.className = 'guard-bot';
            guard.style.left = '0px';
            guard.style.background = 'linear-gradient(to bottom, #0000cc, #000066)';
            animationDiv.appendChild(guard);
            
            // Animation
            let direction = 1;
            let guardPos = 0;
            const guardInterval = setInterval(() => {
                if (document.getElementById('solitaryScreen').style.display !== 'flex') {
                    clearInterval(guardInterval);
                    return;
                }
                
                guardPos += direction * 60;
                if (guardPos > 350) direction = -1;
                if (guardPos < 0) direction = 1;
                
                guard.style.left = guardPos + 'px';
                
                // Inmate occasional movement
                if (Math.random() < 0.2) {
                    inmate.style.left = (210 + Math.random() * 20) + 'px';
                }
                
                // Random guard stop
                if (Math.random() < 0.1) {
                    setTimeout(() => {
                        guard.style.background = 'linear-gradient(to bottom, #ff0000, #990000)';
                        setTimeout(() => {
                            guard.style.background = 'linear-gradient(to bottom, #0000cc, #000066)';
                        }, 500);
                    }, 100);
                }
            }, 1200);
        }

        // ============================================================================
        // ENHANCED UI FUNCTIONS
        // ============================================================================
        function updatePlayerUI(playerNum, player) {
            const num = playerNum === 1 ? '1' : '2';
            const healthElement = document.getElementById(`health${num}`);
            const healthBarElement = document.getElementById(`healthBar${num}`);
            const contrabandElement = document.getElementById(`contraband${num}`);
            const repElement = document.getElementById(`rep${num}`);
            const posElement = document.getElementById(`pos${num}`);
            
            if (healthElement) healthElement.textContent = Math.floor(player.health);
            if (healthBarElement) {
                healthBarElement.style.width = `${player.health}%`;
                healthBarElement.style.background = player.health > 50 ? 
                    'linear-gradient(90deg, #00ff88, #00cc66)' :
                    player.health > 20 ?
                    'linear-gradient(90deg, #ff8800, #cc6600)' :
                    'linear-gradient(90deg, #ff4444, #cc0000)';
            }
            if (contrabandElement) contrabandElement.textContent = player.contraband;
            if (repElement) repElement.textContent = Math.floor(player.reputation);
            
            if (posElement && player.position) {
                posElement.textContent = 
                    `${Math.round(player.position.x)},${Math.round(player.position.z)}`;
            }
        }

        function showNotification(text, type = 'info') {
            const notification = document.getElementById('notification');
            if (!notification) return;
            
            const icons = {
                info: 'info-circle',
                success: 'check-circle',
                warning: 'exclamation-triangle',
                error: 'times-circle'
            };
            
            const colors = {
                info: '#4facfe',
                success: '#00ff88',
                warning: '#ffcc00',
                error: '#ff4444'
            };
            
            notification.innerHTML = `
                <i class="fas fa-${icons[type]}" style="color: ${colors[type]}; margin-right: 10px;"></i>
                <span>${text}</span>
            `;
            notification.style.borderLeftColor = colors[type];
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        function showMessage(text, type = 'info') {
            const messageDiv = document.getElementById('messageDisplay');
            if (!messageDiv) return;
            
            messageDiv.textContent = text;
            messageDiv.style.display = 'block';
            
            const colors = {
                info: '#4facfe',
                success: '#00ff88',
                warning: '#ffcc00',
                error: '#ff4444'
            };
            messageDiv.style.borderColor = colors[type] || colors.info;
            messageDiv.style.color = colors[type] || colors.info;
            
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 3000);
        }

        function hideObjective() {
            const objective = document.getElementById('objective');
            if (objective) {
                objective.style.display = 'none';
            }
        }

        function returnToLobby() {
            if (gameState.peer) {
                gameState.peer.close();
            }
            if (gameState.connectionCheckInterval) {
                clearInterval(gameState.connectionCheckInterval);
            }
            gameState.gameStarted = false;
            document.getElementById('solitaryScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'flex';
            document.getElementById('hostBtn').disabled = false;
            document.getElementById('joinBtn').disabled = false;
            document.getElementById('tutorialBtn').disabled = false;
            updateConnectionStatus('disconnected', 'Ready to play');
            
            saveGameStats();
        }

        function retryGame() {
            // Clean up Three.js
            if (scene) {
                while(scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
            }
            
            if (renderer) {
                renderer.dispose();
            }
            
            // Reset game state
            gameState.gameStarted = false;
            gameState.escapeInProgress = false;
            gameState.timeOfDay = 0.5;
            
            // New seed for different layout
            gameState.prisonSeed = Date.now() + Math.floor(Math.random() * 10000);
            gameState.rng = new EnhancedRandom(gameState.prisonSeed);
            
            // Clear meshes
            playerMesh = null;
            otherPlayerMesh = null;
            botMeshes = [];
            itemMeshes = [];
            wallMeshes = [];
            cellMeshes = [];
            
            // Switch screens
            document.getElementById('solitaryScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            
            try {
                // Reinitialize
                initThreeJS();
                generateEnhancedPrison(gameState.prisonSeed);
                createPlayer(gameState.playerId, true);
                
                // Reset player stats
                const player = gameState.players[gameState.playerId];
                if (player) {
                    player.health = 100;
                    player.contraband = 0;
                    player.reputation = 0;
                    player.inventory = [];
                }
                
                // Start game
                gameState.gameStarted = true;
                gameState.gameStartTime = Date.now();
                animate();
                
                showNotification("New attempt! Prison layout changed.", 'success');
            } catch (e) {
                console.error('Error in retry:', e);
                showNotification("Error restarting game", 'error');
                returnToLobby();
            }
        }

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        function generateSecureId() {
            return Math.random().toString(36).substr(2, 12) + Date.now().toString(36);
        }

        function generate4DigitCode() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        function copyRoomCode() {
            const code = document.getElementById('displayCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showNotification(`Room code ${code} copied to clipboard!`, 'success');
            }).catch(err => {
                console.error('Failed to copy:', err);
                showNotification("Failed to copy code", "error");
            });
        }

        function loadGameStats() {
            try {
                const saved = localStorage.getItem('cellblockZero_stats');
                if (saved) {
                    gameState.stats = JSON.parse(saved);
                }
            } catch (e) {
                console.log('No saved stats found');
            }
        }

        function saveGameStats() {
            try {
                localStorage.setItem('cellblockZero_stats', JSON.stringify(gameState.stats));
            } catch (e) {
                console.error('Failed to save stats:', e);
            }
        }

        function testWebRTC() {
            if (!window.RTCPeerConnection) {
                showNotification("WebRTC not supported", "error");
                return false;
            }
            
            try {
                const testPC = new RTCPeerConnection();
                testPC.close();
                return true;
            } catch (e) {
                showNotification("WebRTC connection test failed", "warning");
                return false;
            }
        }

        // ============================================================================
        // INPUT HANDLING
        // ============================================================================
        function setupEventListeners() {
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                
                if (key === 'shift') isRunning = true;
                
                switch(key) {
                    case 'e':
                        if (!gameState.escapeInProgress) attemptInteraction();
                        break;
                    case 'f':
                        if (!gameState.escapeInProgress) attemptFight();
                        break;
                    case 'tab':
                        toggleInventory();
                        e.preventDefault();
                        break;
                    case 'c':
                        toggleChat();
                        e.preventDefault();
                        break;
                    case 'm':
                        if (!gameState.escapeInProgress) toggleEscapeMenu();
                        e.preventDefault();
                        break;
                    case 'enter':
                        if (document.getElementById('chat').style.display === 'block') {
                            sendChatMessage();
                            e.preventDefault();
                        }
                        break;
                    case 'escape':
                        if (document.getElementById('chat').style.display === 'block') {
                            toggleChat();
                        } else if (document.getElementById('escapeMenu').style.display === 'grid') {
                            toggleEscapeMenu();
                        } else if (document.getElementById('inventory').style.display === 'block') {
                            toggleInventory();
                        } else if (gameState.gameStarted) {
                            showNotification("Game paused - Press ESC again to continue", "info");
                        }
                        e.preventDefault();
                        break;
                }
            });
            
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = false;
                
                if (key === 'shift') isRunning = false;
            });
            
            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            window.addEventListener('resize', () => {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
            
            // Prevent right-click menu
            window.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Mobile touch events
            window.addEventListener('touchstart', (e) => {
                e.preventDefault();
            }, { passive: false });
        }

        function mobileKeyDown(key) {
            keys[key] = true;
            if (key === 'e') attemptInteraction();
            if (key === ' ') playerMesh.position.y += 0.25;
        }

        function mobileKeyUp(key) {
            keys[key] = false;
        }

        // ============================================================================
        // INTERACTION FUNCTIONS
        // ============================================================================
        function attemptInteraction() {
            // Item interaction
            itemMeshes.forEach((item, index) => {
                if (item && !item.userData.collected && playerMesh) {
                    const distance = playerMesh.position.distanceTo(item.position);
                    if (distance < 2.5) {
                        collectItem(item.userData.type, index);
                    }
                }
            });
            
            // Bot interaction
            gameState.bots.forEach((bot, index) => {
                if (playerMesh && bot.position) {
                    const dx = playerMesh.position.x - bot.position.x;
                    const dz = playerMesh.position.z - bot.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 3.5) {
                        if (bot.type === 'guard') {
                            const player = gameState.players[gameState.playerId];
                            if (player.inventory.includes('donut')) {
                                player.reputation += 15;
                                player.inventory = player.inventory.filter(i => i !== 'donut');
                                updateInventoryUI();
                                bot.alertLevel = Math.max(0, bot.alertLevel - 40);
                                showNotification('Guard bribed with donut! Reputation +15', 'success');
                            } else if (player.inventory.includes('cigarettes')) {
                                player.reputation += 8;
                                player.inventory = player.inventory.filter(i => i !== 'cigarettes');
                                updateInventoryUI();
                                bot.alertLevel = Math.max(0, bot.alertLevel - 20);
                                showNotification('Guard distracted with cigarettes', 'info');
                            }
                        } else if (bot.type === 'inmate') {
                            tradeWithInmate(bot.personality, bot.mood);
                        }
                    }
                }
            });
        }

        function attemptFight() {
            const player = gameState.players[gameState.playerId];
            
            gameState.bots.forEach((bot, index) => {
                if (bot.type === 'guard' && playerMesh) {
                    const dx = playerMesh.position.x - bot.position.x;
                    const dz = playerMesh.position.z - bot.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 3) {
                        let successChance = 0.4;
                        
                        // Bonuses
                        if (player.inventory.includes('crowbar')) successChance += 0.3;
                        if (player.reputation > 30) successChance += 0.2;
                        if (gameState.isNight) successChance += 0.1;
                        
                        const success = Math.random() < successChance;
                        
                        if (success) {
                            showNotification('Guard knocked out temporarily! Reputation +10', 'success');
                            bot.alertLevel = 100;
                            bot.state = 'chasing';
                            player.reputation += 10;
                            player.health -= 10; // Still takes some damage
                        } else {
                            showNotification('Fight failed! Health -30', 'warning');
                            player.health -= 30;
                            bot.alertLevel = 100;
                            bot.state = 'chasing';
                            
                            if (player.health <= 0) {
                                sendToSolitary('Lost a fight with a guard');
                            }
                        }
                        
                        sendNetworkMessage('botUpdate', { 
                            index, 
                            alertLevel: bot.alertLevel,
                            state: bot.state 
                        });
                        updatePlayerUI(1, player);
                    }
                }
            });
        }

        function tradeWithInmate(personality, mood) {
            const player = gameState.players[gameState.playerId];
            const messages = {
                lazy: ["Zzz... come back later...", "Too tired to talk.", "Maybe after a nap..."],
                violent: ["What you lookin' at?! Got a problem?!", "Back off before I make you!", "You want trouble?!"],
                helpful: ["Need something? I might know a thing or two...", "Looking for help? You came to the right guy.", "I've been here a while. Need advice?"],
                nervous: ["Don't draw attention to us!", "The guards are watching...", "Quick, what do you want?"],
                reckless: ["Let's cause some trouble!", "I'm bored. Got any ideas?", "Want to stir things up?"]
            };
            
            const moodMessages = {
                calm: ["I'm feeling okay today.", "Things are quiet for now.", "No complaints."],
                agitated: ["I can't stand this place!", "Need to get out of here!", "This is driving me crazy!"],
                bored: ["Another day in paradise...", "So bored I could scream.", "Nothing ever happens."],
                curious: ["Heard anything interesting?", "What's new with you?", "Got any gossip?"]
            };
            
            const personalityMsg = messages[personality] ? 
                messages[personality][Math.floor(Math.random() * messages[personality].length)] : 
                "What do you want?";
            
            const moodMsg = moodMessages[mood] ? 
                moodMessages[mood][Math.floor(Math.random() * moodMessages[mood].length)] : 
                "";
            
            showNotification(`Inmate: "${personalityMsg} ${moodMsg}"`, 'info');
            
            if (personality === 'helpful' && player.contraband > 0) {
                const tips = CONFIG.ESCAPE_HINTS;
                const tip = tips[Math.floor(Math.random() * tips.length)];
                showNotification(`ðŸ’¡ Inmate Tip: ${tip}`, 'success');
                player.reputation += 5;
                updatePlayerUI(1, player);
            }
            
            if (personality === 'reckless' && Math.random() < 0.3) {
                showNotification("Inmate caused a distraction! Guards are busy.", 'success');
                gameState.bots.forEach(bot => {
                    if (bot.type === 'guard' && bot.alertLevel > 0) {
                        bot.alertLevel *= 0.5;
                    }
                });
            }
        }

        // ============================================================================
        // CHAT SYSTEM
        // ============================================================================
        function toggleChat() {
            const chat = document.getElementById('chat');
            if (chat.style.display === 'block') {
                chat.style.display = 'none';
            } else {
                chat.style.display = 'flex';
                document.getElementById('chatInput').focus();
            }
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (message && gameState.connectionEstablished) {
                displayChatMessage('You', message, true);
                sendNetworkMessage('chat', message);
                input.value = '';
            }
        }

        function displayChatMessage(sender, message, isLocal) {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isLocal ? 'you' : 'partner'}`;
            const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            messageDiv.innerHTML = `
                <div style="font-weight: bold; color: ${isLocal ? '#00ff88' : '#4facfe'}">
                    ${sender} <span style="font-size: 0.8em; color: #888;">${time}</span>
                </div>
                <div>${message}</div>
            `;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function toggleInventory() {
            const inventory = document.getElementById('inventory');
            if (inventory.style.display === 'block') {
                inventory.style.display = 'none';
            } else {
                inventory.style.display = 'block';
                updateInventoryUI();
            }
        }

        // ============================================================================
        // SYNC FUNCTION
        // ============================================================================
        function handleSyncRequest(data) {
            // Send current game state to requesting player
            sendNetworkMessage('syncResponse', {
                players: gameState.players,
                bots: gameState.bots,
                items: gameState.items,
                timeOfDay: gameState.timeOfDay
            });
        }

        // ============================================================================
        // ERROR HANDLING
        // ============================================================================
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            showNotification(`Error: ${event.message}`, 'error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            showNotification('Network error occurred', 'error');
        });

        // ============================================================================
        // CLEANUP ON EXIT
        // ============================================================================
        window.addEventListener('beforeunload', () => {
            if (gameState.peer) {
                gameState.peer.close();
            }
            if (gameState.connectionCheckInterval) {
                clearInterval(gameState.connectionCheckInterval);
            }
            if (renderer) {
                renderer.dispose();
            }
            
            // Clear localStorage
            localStorage.removeItem('hostOffer');
            localStorage.removeItem('iceCandidates');
            localStorage.removeItem('playerAnswer');
            localStorage.removeItem('playerIceCandidate');
            
            // Save stats
            saveGameStats();
        });

        console.log('Cell Block Zero - Enhanced Edition Ready!');
    </script>
</body>
</html>
