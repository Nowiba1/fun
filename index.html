<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER RUNNER 2077 | WebGL Parkour FPS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', 'Arial Narrow', sans-serif;
            background: #000;
            color: #0ff;
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #uiOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s;
        }
        
        .cyberpunk-logo {
            font-size: 4rem;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px #ff00ff;
            margin-bottom: 30px;
            animation: glitch 3s infinite;
        }
        
        .loading-bar-container {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            border-radius: 2px;
            transition: width 0.3s;
        }
        
        .loading-text {
            color: #0ff;
            font-size: 1.2rem;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        /* Settings Panel */
        #settingsPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: all;
        }
        
        .settings-title {
            font-size: 3rem;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 40px;
            text-transform: uppercase;
        }
        
        .settings-container {
            width: 800px;
            max-width: 90%;
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        .settings-section {
            margin-bottom: 25px;
        }
        
        .section-title {
            color: #ff00ff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            border-bottom: 1px solid #00ffff;
            padding-bottom: 5px;
            text-transform: uppercase;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            transition: background 0.3s;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
        }
        
        .control-label {
            color: #0ff;
            font-size: 0.9rem;
        }
        
        .control-key {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #ff00ff;
            padding: 5px 15px;
            border-radius: 4px;
            min-width: 80px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .control-key:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .control-key.editing {
            animation: pulse 1s infinite;
            background: rgba(255, 0, 255, 0.3);
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            grid-column: 1 / -1;
            justify-content: center;
        }
        
        .settings-button {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            color: #000;
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.3s;
        }
        
        .settings-button:hover {
            transform: scale(1.05);
        }
        
        .settings-button.reset {
            background: linear-gradient(45deg, #ff3300, #ff9900);
        }
        
        /* Main HUD */
        .hud {
            padding: 20px;
        }
        
        .top-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .mission-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-left: 3px solid #ff00ff;
            max-width: 400px;
        }
        
        .mission-title {
            color: #ff00ff;
            font-size: 1.2rem;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .mission-objective {
            color: #0ff;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .stats-container {
            display: flex;
            gap: 30px;
        }
        
        .stat-box {
            text-align: center;
            min-width: 100px;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #0ff;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
        }
        
        /* Health and Energy Bars */
        .bars-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 300px;
        }
        
        .bar {
            margin-bottom: 15px;
        }
        
        .bar-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .bar-name {
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }
        
        .bar-value {
            color: #ff00ff;
            font-weight: bold;
        }
        
        .bar-track {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s;
            position: relative;
        }
        
        .health-bar .bar-fill {
            background: linear-gradient(90deg, #ff0000, #ff3300);
            box-shadow: 0 0 10px #ff3300;
        }
        
        .energy-bar .bar-fill {
            background: linear-gradient(90deg, #00ffff, #0088ff);
            box-shadow: 0 0 10px #00ffff;
        }
        
        /* Weapons */
        .weapon-hud {
            position: fixed;
            bottom: 30px;
            right: 30px;
            text-align: right;
        }
        
        .weapon-name {
            color: #ff00ff;
            font-size: 1.5rem;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .ammo-count {
            color: #0ff;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .ammo-type {
            color: rgba(0, 255, 255, 0.5);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Crosshair */
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        .crosshair-inner {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .crosshair-line {
            position: absolute;
            background: #00ffff;
            box-shadow: 0 0 5px #00ffff;
        }
        
        .crosshair-line.top {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
        }
        
        .crosshair-line.bottom {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
        }
        
        .crosshair-line.left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 2px;
        }
        
        .crosshair-line.right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 2px;
        }
        
        /* Abilities HUD */
        .abilities-hud {
            position: fixed;
            bottom: 150px;
            right: 30px;
            display: flex;
            gap: 15px;
        }
        
        .ability-slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .ability-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .ability-key {
            position: absolute;
            bottom: 5px;
            font-size: 0.8rem;
            color: #ff00ff;
        }
        
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 0, 255, 0.5);
            transition: height 0.1s;
        }
        
        /* Minimap */
        .minimap-container {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            overflow: hidden;
            padding: 10px;
        }
        
        .minimap-title {
            color: #ff00ff;
            text-align: center;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .minimap {
            width: 100%;
            height: calc(100% - 30px);
            background: rgba(0, 20, 40, 0.9);
            position: relative;
        }
        
        /* Controls Help */
        .controls-help {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 10px 20px;
            color: #0ff;
            font-size: 0.8rem;
            display: none;
        }
        
        .controls-help.show {
            display: block;
        }
        
        /* Messages */
        .message-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            text-align: center;
            width: 80%;
        }
        
        .message {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00ff;
            padding: 20px 40px;
            margin-bottom: 10px;
            color: #0ff;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
        }
        
        .message.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Pause Menu */
        #pauseMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: all;
        }
        
        .pause-title {
            font-size: 4rem;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 50px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        
        .pause-menu {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 300px;
        }
        
        .pause-button {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #0ff;
            padding: 20px;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .pause-button:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #ff00ff;
            transform: scale(1.05);
        }
        
        /* Grid Overlay */
        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 1;
        }
        
        /* Animations */
        @keyframes glitch {
            0% { transform: translate(0); }
            2% { transform: translate(-2px, 2px); }
            4% { transform: translate(-2px, -2px); }
            6% { transform: translate(2px, 2px); }
            8% { transform: translate(2px, -2px); }
            10% { transform: translate(0); }
            100% { transform: translate(0); }
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.5; transform: scale(1); }
        }
        
        /* Key Display */
        .key-display {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ffff;
            padding: 2px 8px;
            margin: 0 3px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="cyberpunk-logo">CYBER RUNNER 2077</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">INITIALIZING NEURAL LINK...</div>
    </div>

    <!-- Settings Panel -->
    <div id="settingsPanel">
        <div class="settings-title">CONTROL CONFIGURATION</div>
        <div class="settings-container">
            <div class="settings-section">
                <div class="section-title">MOVEMENT</div>
                <div class="control-item">
                    <span class="control-label">Move Forward</span>
                    <div class="control-key" data-action="forward">W</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Move Backward</span>
                    <div class="control-key" data-action="backward">S</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Move Left</span>
                    <div class="control-key" data-action="left">A</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Move Right</span>
                    <div class="control-key" data-action="right">D</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Jump</span>
                    <div class="control-key" data-action="jump">Space</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Sprint</span>
                    <div class="control-key" data-action="sprint">Shift</div>
                </div>
            </div>
            
            <div class="settings-section">
                <div class="section-title">COMBAT</div>
                <div class="control-item">
                    <span class="control-label">Shoot</span>
                    <div class="control-key" data-action="shoot">Mouse Left</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Aim Down Sights</span>
                    <div class="control-key" data-action="aim">Mouse Right</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Reload</span>
                    <div class="control-key" data-action="reload">R</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Weapon 1</span>
                    <div class="control-key" data-action="weapon1">1</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Weapon 2</span>
                    <div class="control-key" data-action="weapon2">2</div>
                </div>
            </div>
            
            <div class="settings-section">
                <div class="section-title">ABILITIES</div>
                <div class="control-item">
                    <span class="control-label">Cyber Dash</span>
                    <div class="control-key" data-action="ability1">Q</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Neural Scan</span>
                    <div class="control-key" data-action="ability2">E</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Time Dilation</span>
                    <div class="control-key" data-action="ability3">F</div>
                </div>
            </div>
            
            <div class="settings-section">
                <div class="section-title">GAME CONTROLS</div>
                <div class="control-item">
                    <span class="control-label">Pause Game</span>
                    <div class="control-key" data-action="pause">Escape</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Show Controls</span>
                    <div class="control-key" data-action="help">H</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Settings</span>
                    <div class="control-key" data-action="settings">F1</div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="settings-button" id="saveSettings">SAVE SETTINGS</button>
                <button class="settings-button reset" id="resetSettings">RESET TO DEFAULT</button>
                <button class="settings-button" id="closeSettings">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameContainer"></canvas>

    <!-- UI Overlay -->
    <div id="uiOverlay">
        <!-- Grid Overlay -->
        <div class="grid-overlay"></div>
        
        <!-- HUD -->
        <div class="hud">
            <div class="top-bar">
                <div class="mission-info">
                    <div class="mission-title" id="missionTitle">INFILTRATE MEGACORP TOWER</div>
                    <div class="mission-objective" id="missionObjective">Upload virus to central server ‚Ä¢ Eliminate security</div>
                </div>
                <div class="stats-container">
                    <div class="stat-box">
                        <div class="stat-value" id="scoreValue">0</div>
                        <div class="stat-label">CREDITS</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="killCount">0</div>
                        <div class="stat-label">ELIMINATIONS</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="timeValue">00:00</div>
                        <div class="stat-label">MISSION TIME</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Health and Energy Bars -->
        <div class="bars-container">
            <div class="bar health-bar">
                <div class="bar-label">
                    <div class="bar-name">NEURAL INTEGRITY</div>
                    <div class="bar-value" id="healthValue">100%</div>
                </div>
                <div class="bar-track">
                    <div class="bar-fill" id="healthBar" style="width: 100%"></div>
                </div>
            </div>
            <div class="bar energy-bar">
                <div class="bar-label">
                    <div class="bar-name">CYBERNETIC ENERGY</div>
                    <div class="bar-value" id="energyValue">100%</div>
                </div>
                <div class="bar-track">
                    <div class="bar-fill" id="energyBar" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <!-- Weapon HUD -->
        <div class="weapon-hud">
            <div class="weapon-name" id="weaponName">PLASMA RIFLE</div>
            <div class="ammo-count" id="ammoCount">‚àû/‚àû</div>
            <div class="ammo-type" id="ammoType">ENERGY CELLS</div>
        </div>

        <!-- Abilities -->
        <div class="abilities-hud">
            <div class="ability-slot" id="ability1">
                <div class="ability-icon">‚ö°</div>
                <div class="ability-key" id="ability1Key">Q</div>
                <div class="ability-cooldown" id="ability1Cooldown"></div>
            </div>
            <div class="ability-slot" id="ability2">
                <div class="ability-icon">üëÅÔ∏è</div>
                <div class="ability-key" id="ability2Key">E</div>
                <div class="ability-cooldown" id="ability2Cooldown"></div>
            </div>
            <div class="ability-slot" id="ability3">
                <div class="ability-icon">üåÄ</div>
                <div class="ability-key" id="ability3Key">F</div>
                <div class="ability-cooldown" id="ability3Cooldown"></div>
            </div>
        </div>

        <!-- Minimap -->
        <div class="minimap-container">
            <div class="minimap-title">TACTICAL DISPLAY</div>
            <div class="minimap" id="minimap"></div>
        </div>

        <!-- Crosshair -->
        <div class="crosshair">
            <div class="crosshair-inner">
                <div class="crosshair-dot"></div>
                <div class="crosshair-line top"></div>
                <div class="crosshair-line bottom"></div>
                <div class="crosshair-line left"></div>
                <div class="crosshair-line right"></div>
            </div>
        </div>

        <!-- Controls Help -->
        <div class="controls-help" id="controlsHelp">
            Press <span class="key-display">H</span> to hide controls ‚Ä¢ Press <span class="key-display">F1</span> to configure
        </div>

        <!-- Messages -->
        <div class="message-container" id="messageContainer"></div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu">
        <div class="pause-title">PAUSED</div>
        <div class="pause-menu">
            <div class="pause-button" id="resumeButton">RESUME MISSION</div>
            <div class="pause-button" id="settingsButton">CONTROLS CONFIG</div>
            <div class="pause-button" id="restartButton">RESTART LEVEL</div>
            <div class="pause-button" id="quitButton">DISCONNECT</div>
        </div>
    </div>

    <script>
        // ================================
        // GAME CONFIGURATION
        // ================================
        const CONFIG = {
            // Graphics
            BLOOM_STRENGTH: 1.5,
            BLOOM_RADIUS: 0.4,
            BLOOM_THRESHOLD: 0.85,
            FOG_DENSITY: 0.002,
            FOG_COLOR: 0x000022,
            
            // Player
            PLAYER_SPEED: 5,
            PLAYER_JUMP_FORCE: 8,
            PLAYER_SPRINT_MULTIPLIER: 1.8,
            PLAYER_HEALTH: 100,
            PLAYER_ENERGY: 100,
            PLAYER_ENERGY_REGEN: 0.5,
            
            // Gameplay
            GRAVITY: -20,
            ENEMY_COUNT: 15,
            OBJECTIVE_DISTANCE: 200,
            TIME_LIMIT: 600,
            
            // Weapons
            WEAPONS: {
                plasma: {
                    name: 'PLASMA RIFLE',
                    damage: 25,
                    fireRate: 10,
                    energyCost: 5,
                    accuracy: 0.95,
                    ammoType: 'ENERGY CELLS'
                },
                railgun: {
                    name: 'RAILGUN',
                    damage: 75,
                    fireRate: 2,
                    energyCost: 20,
                    accuracy: 1.0,
                    ammoType: 'KINETIC ROUNDS'
                }
            },
            
            // Abilities
            ABILITIES: {
                dash: {
                    name: 'CYBER DASH',
                    cooldown: 3,
                    energyCost: 15,
                    duration: 0.3,
                    speedMultiplier: 5
                },
                scan: {
                    name: 'NEURAL SCAN',
                    cooldown: 8,
                    energyCost: 10,
                    duration: 5,
                    revealRadius: 50
                },
                timeWarp: {
                    name: 'TIME DILATION',
                    cooldown: 15,
                    energyCost: 30,
                    duration: 4,
                    slowFactor: 0.3
                }
            }
        };

        // ================================
        // CUSTOM CONTROLS SYSTEM
        // ================================
        const DEFAULT_CONTROLS = {
            forward: 'KeyW',
            backward: 'KeyS',
            left: 'KeyA',
            right: 'KeyD',
            jump: 'Space',
            sprint: 'ShiftLeft',
            shoot: 'Mouse0',
            aim: 'Mouse2',
            reload: 'KeyR',
            weapon1: 'Digit1',
            weapon2: 'Digit2',
            ability1: 'KeyQ',
            ability2: 'KeyE',
            ability3: 'KeyF',
            pause: 'Escape',
            help: 'KeyH',
            settings: 'F1'
        };

        let userControls = JSON.parse(localStorage.getItem('cyberrunner_controls')) || {...DEFAULT_CONTROLS};
        let editingControl = null;
        let keyBindings = {};

        function initializeControls() {
            // Convert control mapping to key bindings
            keyBindings = {};
            for (const [action, key] of Object.entries(userControls)) {
                keyBindings[key] = action;
            }
            
            // Update UI display
            updateControlDisplay();
        }

        function updateControlDisplay() {
            // Update control key displays
            for (const [action, key] of Object.entries(userControls)) {
                const element = document.querySelector(`.control-key[data-action="${action}"]`);
                if (element) {
                    element.textContent = formatKeyName(key);
                }
            }
            
            // Update ability key displays
            document.getElementById('ability1Key').textContent = formatKeyName(userControls.ability1);
            document.getElementById('ability2Key').textContent = formatKeyName(userControls.ability2);
            document.getElementById('ability3Key').textContent = formatKeyName(userControls.ability3);
        }

        function formatKeyName(keyCode) {
            const keyMap = {
                'KeyW': 'W',
                'KeyA': 'A',
                'KeyS': 'S',
                'KeyD': 'D',
                'KeyQ': 'Q',
                'KeyE': 'E',
                'KeyR': 'R',
                'KeyF': 'F',
                'KeyH': 'H',
                'Space': 'Space',
                'ShiftLeft': 'Shift',
                'ShiftRight': 'Shift',
                'Digit1': '1',
                'Digit2': '2',
                'Escape': 'Esc',
                'F1': 'F1',
                'Mouse0': 'Mouse L',
                'Mouse2': 'Mouse R'
            };
            
            return keyMap[keyCode] || keyCode.replace('Key', '').replace('Digit', '').replace('Arrow', '');
        }

        function saveControls() {
            localStorage.setItem('cyberrunner_controls', JSON.stringify(userControls));
            initializeControls();
            showMessage('CONTROLS SAVED', 'Custom controls have been saved');
        }

        function resetControls() {
            userControls = {...DEFAULT_CONTROLS};
            updateControlDisplay();
            showMessage('CONTROLS RESET', 'Default controls restored');
        }

        function setupControlListeners() {
            // Control key click listeners
            document.querySelectorAll('.control-key').forEach(element => {
                element.addEventListener('click', () => {
                    if (editingControl) {
                        editingControl.classList.remove('editing');
                    }
                    
                    editingControl = element;
                    editingControl.classList.add('editing');
                    editingControl.textContent = 'Press any key...';
                });
            });
            
            // Global key listener for control editing
            document.addEventListener('keydown', (e) => {
                if (editingControl) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = editingControl.dataset.action;
                    const keyCode = e.code;
                    
                    // Don't allow duplicate key bindings
                    for (const [existingAction, existingKey] of Object.entries(userControls)) {
                        if (existingKey === keyCode && existingAction !== action) {
                            showMessage('KEY ALREADY BOUND', `This key is already bound to ${existingAction}`);
                            return;
                        }
                    }
                    
                    userControls[action] = keyCode;
                    editingControl.classList.remove('editing');
                    editingControl.textContent = formatKeyName(keyCode);
                    editingControl = null;
                }
            });
            
            // Mouse button binding
            document.addEventListener('mousedown', (e) => {
                if (editingControl) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = editingControl.dataset.action;
                    const mouseCode = `Mouse${e.button}`;
                    
                    // Don't allow duplicate key bindings
                    for (const [existingAction, existingKey] of Object.entries(userControls)) {
                        if (existingKey === mouseCode && existingAction !== action) {
                            showMessage('BUTTON ALREADY BOUND', `This button is already bound to ${existingAction}`);
                            return;
                        }
                    }
                    
                    userControls[action] = mouseCode;
                    editingControl.classList.remove('editing');
                    editingControl.textContent = formatKeyName(mouseCode);
                    editingControl = null;
                }
            });
            
            // Settings buttons
            document.getElementById('saveSettings').addEventListener('click', saveControls);
            document.getElementById('resetSettings').addEventListener('click', resetControls);
            document.getElementById('closeSettings').addEventListener('click', () => {
                document.getElementById('settingsPanel').style.display = 'none';
                if (game.state === 'paused') {
                    document.getElementById('pauseMenu').style.display = 'flex';
                }
            });
        }

        // ================================
        // GAME STATE
        // ================================
        let game = {
            // Core
            scene: null,
            camera: null,
            renderer: null,
            composer: null,
            clock: null,
            
            // Player
            player: {
                mesh: null,
                position: new THREE.Vector3(0, 10, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: new THREE.Euler(0, 0, 0),
                health: CONFIG.PLAYER_HEALTH,
                energy: CONFIG.PLAYER_ENERGY,
                score: 0,
                kills: 0,
                weapon: 'plasma',
                abilities: {
                    dash: { active: false, cooldown: 0 },
                    scan: { active: false, cooldown: 0 },
                    timeWarp: { active: false, cooldown: 0 }
                }
            },
            
            // World
            world: {
                platforms: [],
                enemies: [],
                pickups: [],
                buildings: [],
                lights: [],
                particles: []
            },
            
            // Game State
            state: 'loading',
            timeElapsed: 0,
            objectiveComplete: false,
            gameOver: false,
            
            // Input
            keys: {},
            mouse: { x: 0, y: 0, buttons: {} },
            
            // UI
            ui: {
                controlsVisible: true,
                lastMessageTime: 0
            }
        };

        // ================================
        // INITIALIZATION
        // ================================
        async function init() {
            try {
                // Initialize controls
                initializeControls();
                setupControlListeners();
                
                // Initialize Three.js
                initThreeJS();
                
                // Create game world
                await createWorld();
                
                // Set up player (FIXED: Use CylinderGeometry instead of CapsuleGeometry)
                createPlayer();
                
                // Set up enemies
                createEnemies();
                
                // Set up pickups
                createPickups();
                
                // Set up lighting
                setupLighting();
                
                // Set up post-processing
                setupPostProcessing();
                
                // Set up event listeners
                setupEventListeners();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        game.state = 'playing';
                        showMessage('INFILTRATION PROTOCOL ACTIVE', 'Get to the upload point');
                        
                        // Show controls help
                        document.getElementById('controlsHelp').classList.add('show');
                        setTimeout(() => {
                            document.getElementById('controlsHelp').classList.remove('show');
                        }, 5000);
                    }, 1000);
                }, 500);
                
                // Start game loop
                game.clock = new THREE.Clock();
                animate();
                
            } catch (error) {
                console.error('Failed to initialize game:', error);
                showMessage('SYSTEM ERROR', 'Failed to initialize neural interface');
            }
        }

        function initThreeJS() {
            // Scene
            game.scene = new THREE.Scene();
            game.scene.fog = new THREE.Fog(CONFIG.FOG_COLOR, 10, 1000);
            
            // Camera
            game.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            game.camera.position.set(0, 10, 20);
            
            // Renderer
            game.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameContainer'),
                antialias: true,
                alpha: true
            });
            game.renderer.setSize(window.innerWidth, window.innerHeight);
            game.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            game.renderer.shadowMap.enabled = true;
            game.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }

        async function createWorld() {
            // Skybox
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000033,
                side: THREE.BackSide
            });
            const skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            game.scene.add(skybox);
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x111122,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.position.y = -5;
            game.scene.add(ground);
            
            // Create cyberpunk cityscape
            createCityscape();
            
            // Create platforms for parkour
            createParkourCourse();
            
            // Add decorative particles
            createParticles();
        }

        function createCityscape() {
            // Create futuristic buildings
            const buildingColors = [0x222233, 0x333344, 0x223355, 0x334466];
            const buildingHeights = [50, 75, 100, 125, 150];
            
            for (let i = 0; i < 20; i++) {
                const width = 15 + Math.random() * 20;
                const depth = 15 + Math.random() * 20;
                const height = buildingHeights[Math.floor(Math.random() * buildingHeights.length)];
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: 0x000011
                });
                const building = new THREE.Mesh(geometry, material);
                
                // Position buildings around the edges
                const angle = (i / 20) * Math.PI * 2;
                const radius = 150 + Math.random() * 100;
                building.position.x = Math.cos(angle) * radius;
                building.position.z = Math.sin(angle) * radius;
                building.position.y = height / 2 - 5;
                
                building.castShadow = true;
                building.receiveShadow = true;
                
                game.scene.add(building);
                game.world.buildings.push(building);
            }
            
            // Create main tower (objective)
            const towerGeometry = new THREE.CylinderGeometry(20, 30, 300, 8);
            const towerMaterial = new THREE.MeshStandardMaterial({
                color: 0xaa00ff,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x220044
            });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.set(0, 150, -CONFIG.OBJECTIVE_DISTANCE);
            tower.castShadow = true;
            game.scene.add(tower);
            
            // Add glow to tower
            const towerLight = new THREE.PointLight(0xff00ff, 2, 200);
            towerLight.position.copy(tower.position);
            towerLight.position.y += 150;
            game.scene.add(towerLight);
        }

        function createParkourCourse() {
            const platformColors = [0x00aaff, 0xff00aa, 0xaa00ff, 0x00ffaa];
            
            let lastPosition = new THREE.Vector3(0, 5, 0);
            
            for (let i = 0; i < 30; i++) {
                const color = platformColors[Math.floor(Math.random() * platformColors.length)];
                const platform = createBoxPlatform(lastPosition, color);
                
                if (platform) {
                    game.scene.add(platform);
                    game.world.platforms.push(platform);
                    
                    // Update last position for next platform
                    lastPosition.x += (Math.random() - 0.5) * 40;
                    lastPosition.y += (Math.random() - 0.5) * 15;
                    lastPosition.z -= 15 + Math.random() * 20;
                    
                    // Ensure minimum height
                    lastPosition.y = Math.max(5, lastPosition.y);
                    
                    // Add some obstacles
                    if (Math.random() > 0.7) {
                        addObstacles(platform.position);
                    }
                }
            }
        }

        function createBoxPlatform(position, color) {
            const geometry = new THREE.BoxGeometry(15, 2, 15);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.6,
                emissive: color,
                emissiveIntensity: 0.2
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.copy(position);
            platform.castShadow = true;
            platform.receiveShadow = true;
            
            // Add edge glow using lines (FIXED: No emissiveIntensity issue)
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ffff,
                linewidth: 2
            });
            const line = new THREE.LineSegments(edges, lineMaterial);
            platform.add(line);
            
            return platform;
        }

        function addObstacles(position) {
            // Create laser fences (FIXED: Remove emissiveIntensity)
            const count = 3 + Math.floor(Math.random() * 3);
            const spacing = 4;
            
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.CylinderGeometry(0.2, 0.2, 15, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000
                });
                const laser = new THREE.Mesh(geometry, material);
                
                laser.position.copy(position);
                laser.position.x += (i - (count - 1) / 2) * spacing;
                laser.position.y += 7.5;
                
                game.scene.add(laser);
                game.world.platforms.push(laser);
            }
        }

        function createParticles() {
            for (let i = 0; i < 100; i++) {
                const geometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.3);
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0x00ffff : 0xff00ff,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.set(
                    (Math.random() - 0.5) * 300,
                    20 + Math.random() * 100,
                    (Math.random() - 0.5) * 300
                );
                
                particle.userData = {
                    speed: 0.1 + Math.random() * 0.3,
                    amplitude: 5 + Math.random() * 10,
                    offset: Math.random() * Math.PI * 2
                };
                
                game.scene.add(particle);
                game.world.particles.push(particle);
            }
        }

        function createPlayer() {
            // Create player using CylinderGeometry instead of CapsuleGeometry (FIXED)
            const geometry = new THREE.CylinderGeometry(1, 1, 4, 8);
            const material = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x002244
            });
            game.player.mesh = new THREE.Mesh(geometry, material);
            game.player.mesh.position.copy(game.player.position);
            game.player.mesh.castShadow = true;
            game.scene.add(game.player.mesh);
            
            // Create player weapon
            createWeapon();
        }

        function createWeapon() {
            const weaponGroup = new THREE.Group();
            
            // Weapon body
            const bodyGeometry = new THREE.BoxGeometry(3, 0.8, 0.8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                roughness: 0.2,
                metalness: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            weaponGroup.add(body);
            
            // Weapon barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
            const barrelMaterial = new THREE.MeshStandardMaterial({
                color: 0x888899,
                roughness: 0.1,
                metalness: 0.9
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.z = -1.5;
            weaponGroup.add(barrel);
            
            // Energy core
            const coreGeometry = new THREE.SphereGeometry(0.3);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.z = 0.5;
            weaponGroup.add(core);
            
            weaponGroup.position.set(1, -0.5, -2);
            game.player.mesh.add(weaponGroup);
        }

        function createEnemies() {
            for (let i = 0; i < CONFIG.ENEMY_COUNT; i++) {
                const enemy = createDrone();
                
                // Position enemy on a platform
                if (game.world.platforms.length > 0) {
                    const platform = game.world.platforms[Math.floor(Math.random() * game.world.platforms.length)];
                    enemy.position.copy(platform.position);
                    enemy.position.y += 5;
                    enemy.position.x += (Math.random() - 0.5) * 10;
                    enemy.position.z += (Math.random() - 0.5) * 10;
                }
                
                game.scene.add(enemy);
                game.world.enemies.push({
                    mesh: enemy,
                    health: 100,
                    type: 'drone',
                    lastShot: 0,
                    target: null,
                    state: 'patrol'
                });
            }
        }

        function createDrone() {
            const group = new THREE.Group();
            
            // Drone body
            const bodyGeometry = new THREE.SphereGeometry(1.5, 8, 6);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                emissive: 0x331100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            
            // Drone wings
            const wingGeometry = new THREE.BoxGeometry(4, 0.2, 1);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444
            });
            
            for (let i = 0; i < 4; i++) {
                const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                wing.rotation.y = (i / 4) * Math.PI * 2;
                group.add(wing);
            }
            
            // Red eye
            const eyeGeometry = new THREE.SphereGeometry(0.4);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                emissive: 0xff0000
            });
            const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eye.position.z = 1.5;
            group.add(eye);
            
            return group;
        }

        function createPickups() {
            const pickupTypes = ['health', 'energy', 'ammo', 'score'];
            
            for (let i = 0; i < 20; i++) {
                const type = pickupTypes[Math.floor(Math.random() * pickupTypes.length)];
                const pickup = createPickup(type);
                
                // Position pickup
                pickup.position.set(
                    (Math.random() - 0.5) * 200,
                    5 + Math.random() * 20,
                    (Math.random() - 0.5) * 200 - 100
                );
                
                game.scene.add(pickup);
                game.world.pickups.push({
                    mesh: pickup,
                    type: type,
                    value: type === 'score' ? 100 : 25,
                    collected: false
                });
            }
        }

        function createPickup(type) {
            const group = new THREE.Group();
            let color;
            
            switch(type) {
                case 'health':
                    color = 0xff0000;
                    break;
                case 'energy':
                    color = 0x00ffff;
                    break;
                case 'ammo':
                    color = 0xffff00;
                    break;
                case 'score':
                    color = 0x00ff00;
                    break;
            }
            
            // Create floating crystal
            const geometry = new THREE.OctahedronGeometry(1);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                emissive: color
            });
            const crystal = new THREE.Mesh(geometry, material);
            group.add(crystal);
            
            return group;
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x222233, 0.3);
            game.scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0x4466ff, 0.5);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            game.scene.add(directionalLight);
            
            // Neon lights
            for (let i = 0; i < 10; i++) {
                const color = Math.random() > 0.5 ? 0xff00ff : 0x00ffff;
                const light = new THREE.PointLight(color, 1, 30);
                light.position.set(
                    (Math.random() - 0.5) * 200,
                    10 + Math.random() * 20,
                    (Math.random() - 0.5) * 200
                );
                game.scene.add(light);
                game.world.lights.push(light);
            }
        }

        function setupPostProcessing() {
            try {
                game.composer = new THREE.EffectComposer(game.renderer);
                
                // Render pass
                const renderPass = new THREE.RenderPass(game.scene, game.camera);
                game.composer.addPass(renderPass);
                
                // Bloom pass
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    CONFIG.BLOOM_STRENGTH,
                    CONFIG.BLOOM_RADIUS,
                    CONFIG.BLOOM_THRESHOLD
                );
                game.composer.addPass(bloomPass);
                
                // Copy pass
                const copyPass = new THREE.ShaderPass(THREE.CopyShader);
                copyPass.renderToScreen = true;
                game.composer.addPass(copyPass);
            } catch (error) {
                console.warn('Post-processing not available, using standard renderer');
                game.composer = null;
            }
        }

        function setupEventListeners() {
            // Keyboard events using custom controls
            document.addEventListener('keydown', (e) => {
                const action = keyBindings[e.code];
                if (action) {
                    game.keys[action] = true;
                    
                    // Handle special actions
                    switch(action) {
                        case 'pause':
                            togglePause();
                            break;
                        case 'help':
                            toggleControlsHelp();
                            break;
                        case 'settings':
                            openSettings();
                            break;
                        case 'weapon1':
                            switchWeapon('plasma');
                            break;
                        case 'weapon2':
                            switchWeapon('railgun');
                            break;
                        case 'reload':
                            reloadWeapon();
                            break;
                        case 'ability1':
                            activateAbility('dash');
                            break;
                        case 'ability2':
                            activateAbility('scan');
                            break;
                        case 'ability3':
                            activateAbility('timeWarp');
                            break;
                    }
                }
                
                // Prevent default for game keys
                if (action && game.state === 'playing') {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                const action = keyBindings[e.code];
                if (action) {
                    game.keys[action] = false;
                }
            });
            
            // Mouse events
            document.addEventListener('mousedown', (e) => {
                const mouseCode = `Mouse${e.button}`;
                const action = keyBindings[mouseCode];
                
                if (action) {
                    game.mouse.buttons[action] = true;
                    
                    if (action === 'shoot' && game.state === 'playing') {
                        shoot();
                    }
                }
                
                if (game.state === 'playing') {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                const mouseCode = `Mouse${e.button}`;
                const action = keyBindings[mouseCode];
                
                if (action) {
                    game.mouse.buttons[action] = false;
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                game.mouse.x = e.clientX;
                game.mouse.y = e.clientY;
                
                if (document.pointerLockElement === document.getElementById('gameContainer')) {
                    updatePlayerRotation(e.movementX, e.movementY);
                }
            });
            
            // Pointer lock
            document.getElementById('gameContainer').addEventListener('click', () => {
                if (game.state === 'playing') {
                    document.getElementById('gameContainer').requestPointerLock();
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                game.camera.aspect = window.innerWidth / window.innerHeight;
                game.camera.updateProjectionMatrix();
                game.renderer.setSize(window.innerWidth, window.innerHeight);
                if (game.composer) {
                    game.composer.setSize(window.innerWidth, window.innerHeight);
                }
            });
            
            // Pause menu buttons
            document.getElementById('resumeButton').addEventListener('click', () => {
                togglePause();
            });
            
            document.getElementById('settingsButton').addEventListener('click', () => {
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('settingsPanel').style.display = 'flex';
            });
            
            document.getElementById('restartButton').addEventListener('click', () => {
                location.reload();
            });
            
            document.getElementById('quitButton').addEventListener('click', () => {
                if (confirm('Are you sure you want to quit?')) {
                    window.close();
                }
            });
        }

        // ================================
        // GAME LOGIC
        // ================================
        function updatePlayerRotation(deltaX, deltaY) {
            const sensitivity = 0.002;
            
            // Update player rotation
            game.player.rotation.y -= deltaX * sensitivity;
            game.player.rotation.x -= deltaY * sensitivity;
            
            // Clamp vertical rotation
            game.player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, game.player.rotation.x));
            
            // Apply rotation to mesh
            game.player.mesh.rotation.y = game.player.rotation.y;
        }

        function updatePlayer(deltaTime) {
            // Calculate movement direction using custom controls
            const moveDirection = new THREE.Vector3(0, 0, 0);
            
            if (game.keys.forward) moveDirection.z -= 1;
            if (game.keys.backward) moveDirection.z += 1;
            if (game.keys.left) moveDirection.x -= 1;
            if (game.keys.right) moveDirection.x += 1;
            
            // Normalize movement
            if (moveDirection.length() > 0) {
                moveDirection.normalize();
                
                // Apply rotation to movement direction
                const yaw = game.player.rotation.y;
                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                
                const rotatedX = moveDirection.x * cosYaw - moveDirection.z * sinYaw;
                const rotatedZ = moveDirection.x * sinYaw + moveDirection.z * cosYaw;
                
                moveDirection.x = rotatedX;
                moveDirection.z = rotatedZ;
                
                // Calculate speed
                let speed = CONFIG.PLAYER_SPEED;
                if (game.keys.sprint) {
                    speed *= CONFIG.PLAYER_SPRINT_MULTIPLIER;
                }
                
                if (game.player.abilities.dash.active) {
                    speed *= CONFIG.ABILITIES.dash.speedMultiplier;
                }
                
                // Apply movement
                game.player.velocity.x = moveDirection.x * speed;
                game.player.velocity.z = moveDirection.z * speed;
            } else {
                // Slow down when not moving
                game.player.velocity.x *= 0.9;
                game.player.velocity.z *= 0.9;
            }
            
            // Jump using custom control
            if (game.keys.jump && game.player.velocity.y === 0) {
                game.player.velocity.y = CONFIG.PLAYER_JUMP_FORCE;
            }
            
            // Apply gravity
            game.player.velocity.y += CONFIG.GRAVITY * deltaTime;
            
            // Apply velocity
            game.player.position.x += game.player.velocity.x * deltaTime;
            game.player.position.y += game.player.velocity.y * deltaTime;
            game.player.position.z += game.player.velocity.z * deltaTime;
            
            // Ground collision
            if (game.player.position.y < 1) {
                game.player.position.y = 1;
                game.player.velocity.y = 0;
            }
            
            // Update player mesh position
            game.player.mesh.position.copy(game.player.position);
            
            // Update camera position (first-person)
            const cameraOffset = new THREE.Vector3(0, 1, 0);
            cameraOffset.applyEuler(game.player.rotation);
            game.camera.position.copy(game.player.position).add(cameraOffset);
            game.camera.rotation.copy(game.player.rotation);
            
            // Regenerate energy
            if (game.player.energy < CONFIG.PLAYER_ENERGY) {
                game.player.energy += CONFIG.PLAYER_ENERGY_REGEN * deltaTime;
                game.player.energy = Math.min(game.player.energy, CONFIG.PLAYER_ENERGY);
                updateEnergyBar();
            }
            
            // Update ability cooldowns
            updateAbilities(deltaTime);
        }

        function updateEnemies(deltaTime) {
            const now = Date.now();
            
            for (const enemy of game.world.enemies) {
                if (enemy.health <= 0) continue;
                
                // Calculate distance to player
                const distanceToPlayer = enemy.mesh.position.distanceTo(game.player.position);
                
                switch(enemy.state) {
                    case 'patrol':
                        // Random patrol movement
                        if (!enemy.target || Math.random() < 0.01) {
                            enemy.target = new THREE.Vector3(
                                enemy.mesh.position.x + (Math.random() - 0.5) * 20,
                                enemy.mesh.position.y,
                                enemy.mesh.position.z + (Math.random() - 0.5) * 20
                            );
                        }
                        
                        // Move toward target
                        const direction = enemy.target.clone().sub(enemy.mesh.position).normalize();
                        enemy.mesh.position.add(direction.multiplyScalar(2 * deltaTime));
                        
                        // Switch to attack if player is close
                        if (distanceToPlayer < 30) {
                            enemy.state = 'attack';
                        }
                        break;
                        
                    case 'attack':
                        // Face player
                        const lookAtPlayer = game.player.position.clone().sub(enemy.mesh.position).normalize();
                        enemy.mesh.lookAt(enemy.mesh.position.clone().add(lookAtPlayer));
                        
                        // Shoot at player
                        if (now - enemy.lastShot > 1000 && distanceToPlayer < 50) {
                            shootEnemy(enemy);
                            enemy.lastShot = now;
                        }
                        
                        // Return to patrol if player is far
                        if (distanceToPlayer > 40) {
                            enemy.state = 'patrol';
                        }
                        break;
                }
            }
        }

        function shootEnemy(enemy) {
            // Create projectile
            const projectileGeometry = new THREE.SphereGeometry(0.3);
            const projectileMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                emissive: 0xff0000
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            
            // Position projectile at enemy
            projectile.position.copy(enemy.mesh.position);
            projectile.position.y += 1;
            
            // Calculate direction to player
            const direction = game.player.position.clone().sub(projectile.position).normalize();
            
            // Add velocity
            projectile.userData = {
                velocity: direction.multiplyScalar(50),
                damage: 10,
                lifetime: 3
            };
            
            game.scene.add(projectile);
            game.world.particles.push(projectile);
        }

        function updateParticles(deltaTime) {
            for (let i = game.world.particles.length - 1; i >= 0; i--) {
                const particle = game.world.particles[i];
                
                if (particle.userData.lifetime !== undefined) {
                    // Timed particle
                    particle.userData.lifetime -= deltaTime;
                    if (particle.userData.lifetime <= 0) {
                        game.scene.remove(particle);
                        game.world.particles.splice(i, 1);
                        continue;
                    }
                    
                    // Fade out
                    if (particle.material.opacity !== undefined) {
                        particle.material.opacity = particle.userData.lifetime / particle.userData.maxLifetime;
                    }
                }
                
                if (particle.userData.velocity) {
                    // Projectile movement
                    particle.position.add(particle.userData.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Check collision with player
                    if (particle.position.distanceTo(game.player.position) < 1) {
                        takeDamage(particle.userData.damage || 10);
                        game.scene.remove(particle);
                        game.world.particles.splice(i, 1);
                    }
                } else if (particle.userData.speed) {
                    // Floating particle animation
                    particle.position.y += Math.sin(Date.now() * 0.001 + particle.userData.offset) * 0.1;
                    particle.rotation.y += 0.01;
                }
            }
        }

        function updatePickups() {
            for (let i = game.world.pickups.length - 1; i >= 0; i--) {
                const pickup = game.world.pickups[i];
                
                if (pickup.collected) continue;
                
                // Rotate pickup
                pickup.mesh.rotation.y += 0.02;
                pickup.mesh.position.y += Math.sin(Date.now() * 0.002 + i) * 0.05;
                
                // Check collision with player
                if (pickup.mesh.position.distanceTo(game.player.position) < 2) {
                    collectPickup(pickup, i);
                }
            }
        }

        function collectPickup(pickup, index) {
            pickup.collected = true;
            
            switch(pickup.type) {
                case 'health':
                    game.player.health = Math.min(CONFIG.PLAYER_HEALTH, game.player.health + pickup.value);
                    updateHealthBar();
                    showMessage('NEURAL INTEGRITY RESTORED', '+25 integrity');
                    break;
                case 'energy':
                    game.player.energy = Math.min(CONFIG.PLAYER_ENERGY, game.player.energy + pickup.value);
                    updateEnergyBar();
                    showMessage('ENERGY RESTORED', '+25 cybernetic energy');
                    break;
                case 'ammo':
                    showMessage('AMMO CACHE FOUND', 'Weapons recharged');
                    break;
                case 'score':
                    game.player.score += pickup.value;
                    updateScore();
                    showMessage('CREDITS ACQUIRED', '+100 credits');
                    break;
            }
            
            // Remove pickup
            game.scene.remove(pickup.mesh);
            game.world.pickups.splice(index, 1);
        }

        function updateAbilities(deltaTime) {
            for (const [name, ability] of Object.entries(game.player.abilities)) {
                if (ability.cooldown > 0) {
                    ability.cooldown -= deltaTime;
                    updateAbilityCooldown(name, ability.cooldown / CONFIG.ABILITIES[name].cooldown);
                }
                
                if (ability.active) {
                    ability.duration -= deltaTime;
                    if (ability.duration <= 0) {
                        deactivateAbility(name);
                    }
                }
            }
        }

        function activateAbility(name) {
            const ability = game.player.abilities[name];
            const config = CONFIG.ABILITIES[name];
            
            if (ability.cooldown > 0 || game.player.energy < config.energyCost) {
                return;
            }
            
            ability.active = true;
            ability.duration = config.duration;
            ability.cooldown = config.cooldown;
            game.player.energy -= config.energyCost;
            
            updateEnergyBar();
            updateAbilityCooldown(name, 1);
            
            // Ability effects
            switch(name) {
                case 'dash':
                    showMessage('CYBER DASH ACTIVATED', 'Movement speed increased');
                    break;
                case 'scan':
                    showMessage('NEURAL SCAN ACTIVE', 'Enemies highlighted');
                    break;
                case 'timeWarp':
                    showMessage('TIME DILATION', 'Enemy movement slowed');
                    break;
            }
        }

        function deactivateAbility(name) {
            const ability = game.player.abilities[name];
            ability.active = false;
        }

        function shoot() {
            const weapon = CONFIG.WEAPONS[game.player.weapon];
            
            if (game.player.energy < weapon.energyCost) {
                return;
            }
            
            game.player.energy -= weapon.energyCost;
            updateEnergyBar();
            
            // Create projectile
            const geometry = new THREE.SphereGeometry(0.2);
            const material = new THREE.MeshBasicMaterial({
                color: game.player.weapon === 'plasma' ? 0x00ffff : 0xff00ff,
                emissive: game.player.weapon === 'plasma' ? 0x00ffff : 0xff00ff
            });
            const projectile = new THREE.Mesh(geometry, material);
            
            // Position at camera
            projectile.position.copy(game.camera.position);
            
            // Calculate direction
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyEuler(game.camera.rotation);
            
            // Add some spread based on accuracy
            const spread = (1 - weapon.accuracy) * 0.1;
            direction.x += (Math.random() - 0.5) * spread;
            direction.y += (Math.random() - 0.5) * spread;
            direction.z += (Math.random() - 0.5) * spread;
            direction.normalize();
            
            projectile.userData = {
                velocity: direction.multiplyScalar(100),
                damage: weapon.damage,
                lifetime: 2
            };
            
            game.scene.add(projectile);
            game.world.particles.push(projectile);
            
            // Check hits
            checkHit(projectile);
        }

        function checkHit(projectile) {
            for (let i = game.world.enemies.length - 1; i >= 0; i--) {
                const enemy = game.world.enemies[i];
                
                if (enemy.health <= 0) continue;
                
                // Simple sphere collision
                const distance = projectile.position.distanceTo(enemy.mesh.position);
                const hitRadius = 3;
                
                if (distance < hitRadius) {
                    // Hit enemy
                    enemy.health -= projectile.userData.damage;
                    
                    // Remove projectile
                    game.scene.remove(projectile);
                    const particleIndex = game.world.particles.indexOf(projectile);
                    if (particleIndex > -1) {
                        game.world.particles.splice(particleIndex, 1);
                    }
                    
                    // Check if enemy died
                    if (enemy.health <= 0) {
                        enemyKilled(enemy, i);
                    }
                    
                    break;
                }
            }
        }

        function enemyKilled(enemy, index) {
            // Add score
            game.player.score += 100;
            game.player.kills++;
            
            updateScore();
            updateKillCount();
            
            // Show message
            showMessage('TARGET ELIMINATED', '+100 credits');
            
            // Remove enemy
            game.scene.remove(enemy.mesh);
            game.world.enemies.splice(index, 1);
            
            // Check objective
            checkObjective();
        }

        function takeDamage(amount) {
            game.player.health -= amount;
            updateHealthBar();
            
            // Check death
            if (game.player.health <= 0) {
                gameOver();
            }
        }

        function checkObjective() {
            // Check if all enemies are dead
            if (game.world.enemies.length === 0 && !game.objectiveComplete) {
                game.objectiveComplete = true;
                showMessage('OBJECTIVE COMPLETE', 'All hostiles eliminated. Proceed to extraction.');
            }
            
            // Check if player reached the tower
            const distanceToTower = game.player.position.distanceTo(new THREE.Vector3(0, 150, -CONFIG.OBJECTIVE_DISTANCE));
            if (distanceToTower < 50 && !game.objectiveComplete) {
                game.objectiveComplete = true;
                showMessage('SERVER REACHED', 'Uploading virus... Complete. Mission successful!');
                
                // Add bonus score
                game.player.score += 1000;
                updateScore();
            }
        }

        function switchWeapon(weaponType) {
            if (game.player.weapon !== weaponType) {
                game.player.weapon = weaponType;
                updateWeaponHUD();
                showMessage('WEAPON SWITCHED', CONFIG.WEAPONS[weaponType].name + ' equipped');
            }
        }

        function reloadWeapon() {
            if (game.player.energy < CONFIG.PLAYER_ENERGY) {
                showMessage('ENERGY TRANSFER', 'Cybernetic systems recharged');
                game.player.energy = CONFIG.PLAYER_ENERGY;
                updateEnergyBar();
            }
        }

        // ================================
        // UI FUNCTIONS
        // ================================
        function updateHealthBar() {
            const percent = (game.player.health / CONFIG.PLAYER_HEALTH) * 100;
            document.getElementById('healthBar').style.width = percent + '%';
            document.getElementById('healthValue').textContent = Math.round(percent) + '%';
        }

        function updateEnergyBar() {
            const percent = (game.player.energy / CONFIG.PLAYER_ENERGY) * 100;
            document.getElementById('energyBar').style.width = percent + '%';
            document.getElementById('energyValue').textContent = Math.round(percent) + '%';
        }

        function updateScore() {
            document.getElementById('scoreValue').textContent = game.player.score;
        }

        function updateKillCount() {
            document.getElementById('killCount').textContent = game.player.kills;
        }

        function updateTime() {
            game.timeElapsed += 1;
            const minutes = Math.floor(game.timeElapsed / 60);
            const seconds = game.timeElapsed % 60;
            document.getElementById('timeValue').textContent = 
                minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
        }

        function updateWeaponHUD() {
            const weapon = CONFIG.WEAPONS[game.player.weapon];
            document.getElementById('weaponName').textContent = weapon.name;
            document.getElementById('ammoType').textContent = weapon.ammoType;
            document.getElementById('ammoCount').textContent = '‚àû/‚àû';
        }

        function updateAbilityCooldown(abilityName, cooldownPercent) {
            const element = document.getElementById(abilityName + 'Cooldown');
            if (element) {
                element.style.height = (cooldownPercent * 100) + '%';
            }
        }

        function showMessage(title, text) {
            const messageContainer = document.getElementById('messageContainer');
            const message = document.createElement('div');
            message.className = 'message show';
            message.innerHTML = `
                <div style="color:#ff00ff; margin-bottom:5px;">${title}</div>
                <div style="color:#00ffff; font-size:0.9rem;">${text}</div>
            `;
            
            messageContainer.appendChild(message);
            
            // Remove after delay
            setTimeout(() => {
                message.classList.remove('show');
                setTimeout(() => {
                    if (message.parentNode) {
                        message.parentNode.removeChild(message);
                    }
                }, 300);
            }, 3000);
        }

        function togglePause() {
            if (game.state === 'playing') {
                game.state = 'paused';
                document.getElementById('pauseMenu').style.display = 'flex';
                document.exitPointerLock();
            } else if (game.state === 'paused') {
                game.state = 'playing';
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('settingsPanel').style.display = 'none';
            }
        }

        function toggleControlsHelp() {
            game.ui.controlsVisible = !game.ui.controlsVisible;
            document.getElementById('controlsHelp').classList.toggle('show', game.ui.controlsVisible);
        }

        function openSettings() {
            if (game.state === 'playing') {
                game.state = 'paused';
                document.exitPointerLock();
            }
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('settingsPanel').style.display = 'flex';
        }

        function gameOver() {
            game.state = 'gameOver';
            showMessage('NEURAL INTEGRITY CRITICAL', 'Mission failed. Disconnecting...');
            
            setTimeout(() => {
                location.reload();
            }, 3000);
        }

        // ================================
        // GAME LOOP
        // ================================
        function animate() {
            requestAnimationFrame(animate);
            
            if (game.state === 'loading') return;
            
            const deltaTime = game.clock.getDelta();
            
            if (game.state === 'playing') {
                // Update game logic
                updatePlayer(deltaTime);
                updateEnemies(deltaTime);
                updateParticles(deltaTime);
                updatePickups();
                
                // Update time every second
                if (Date.now() - game.ui.lastMessageTime > 1000) {
                    updateTime();
                    game.ui.lastMessageTime = Date.now();
                }
            }
            
            // Render
            if (game.composer) {
                game.composer.render();
            } else {
                game.renderer.render(game.scene, game.camera);
            }
        }

        // ================================
        // LOADING PROGRESS
        // ================================
        function updateLoadingProgress(progress, text) {
            document.getElementById('loadingBar').style.width = progress + '%';
            document.getElementById('loadingText').textContent = text;
        }

        // Simulate loading
        const loadingSteps = [
            { progress: 10, text: 'INITIALIZING NEURAL LINK...' },
            { progress: 25, text: 'LOADING CYBERNETIC ENHANCEMENTS...' },
            { progress: 40, text: 'CALIBRATING OPTICS...' },
            { progress: 60, text: 'SYNCHRONIZING WEAPONS SYSTEMS...' },
            { progress: 80, text: 'GENERATING ENVIRONMENT...' },
            { progress: 95, text: 'FINALIZING INFILTRATION PROTOCOL...' },
            { progress: 100, text: 'READY FOR DEPLOYMENT' }
        ];

        let currentStep = 0;
        const loadingInterval = setInterval(() => {
            if (currentStep < loadingSteps.length) {
                updateLoadingProgress(
                    loadingSteps[currentStep].progress,
                    loadingSteps[currentStep].text
                );
                currentStep++;
            } else {
                clearInterval(loadingInterval);
                init();
            }
        }, 500);

        // Initialize when page loads
        window.addEventListener('load', () => {
            // Loading already simulated
        });
    </script>
</body>
</html>
