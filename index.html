<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER RUNNER 2077 | WebGL Parkour FPS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', 'Arial Narrow', sans-serif;
            background: #000;
            color: #0ff;
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #uiOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s;
        }
        
        .cyberpunk-logo {
            font-size: 4rem;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px #ff00ff;
            margin-bottom: 30px;
            animation: glitch 3s infinite;
        }
        
        .loading-bar-container {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            border-radius: 2px;
            transition: width 0.3s;
        }
        
        .loading-text {
            color: #0ff;
            font-size: 1.2rem;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        /* Settings Panel */
        #settingsPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: all;
        }
        
        .settings-title {
            font-size: 3rem;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 40px;
            text-transform: uppercase;
        }
        
        .settings-container {
            width: 800px;
            max-width: 90%;
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        .settings-section {
            margin-bottom: 25px;
        }
        
        .section-title {
            color: #ff00ff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            border-bottom: 1px solid #00ffff;
            padding-bottom: 5px;
            text-transform: uppercase;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            transition: background 0.3s;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
        }
        
        .control-label {
            color: #0ff;
            font-size: 0.9rem;
        }
        
        .control-key {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #ff00ff;
            padding: 5px 15px;
            border-radius: 4px;
            min-width: 80px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .control-key:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .control-key.editing {
            animation: pulse 1s infinite;
            background: rgba(255, 0, 255, 0.3);
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            grid-column: 1 / -1;
            justify-content: center;
        }
        
        .settings-button {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            color: #000;
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.3s;
        }
        
        .settings-button:hover {
            transform: scale(1.05);
        }
        
        .settings-button.reset {
            background: linear-gradient(45deg, #ff3300, #ff9900);
        }
        
        /* Main HUD */
        .hud {
            padding: 20px;
        }
        
        .top-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .mission-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-left: 3px solid #ff00ff;
            max-width: 400px;
        }
        
        .mission-title {
            color: #ff00ff;
            font-size: 1.2rem;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .mission-objective {
            color: #0ff;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .stats-container {
            display: flex;
            gap: 30px;
        }
        
        .stat-box {
            text-align: center;
            min-width: 100px;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #0ff;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
        }
        
        /* Health and Energy Bars */
        .bars-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 300px;
        }
        
        .bar {
            margin-bottom: 15px;
        }
        
        .bar-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .bar-name {
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }
        
        .bar-value {
            color: #ff00ff;
            font-weight: bold;
        }
        
        .bar-track {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s;
            position: relative;
        }
        
        .health-bar .bar-fill {
            background: linear-gradient(90deg, #ff0000, #ff3300);
            box-shadow: 0 0 10px #ff3300;
        }
        
        .energy-bar .bar-fill {
            background: linear-gradient(90deg, #00ffff, #0088ff);
            box-shadow: 0 0 10px #00ffff;
        }
        
        /* Weapons */
        .weapon-hud {
            position: fixed;
            bottom: 30px;
            right: 30px;
            text-align: right;
        }
        
        .weapon-name {
            color: #ff00ff;
            font-size: 1.5rem;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .ammo-count {
            color: #0ff;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .ammo-type {
            color: rgba(0, 255, 255, 0.5);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Crosshair */
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        .crosshair-inner {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .crosshair-line {
            position: absolute;
            background: #00ffff;
            box-shadow: 0 0 5px #00ffff;
        }
        
        .crosshair-line.top {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
        }
        
        .crosshair-line.bottom {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
        }
        
        .crosshair-line.left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 2px;
        }
        
        .crosshair-line.right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 2px;
        }
        
        /* Abilities HUD */
        .abilities-hud {
            position: fixed;
            bottom: 150px;
            right: 30px;
            display: flex;
            gap: 15px;
        }
        
        .ability-slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .ability-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .ability-key {
            position: absolute;
            bottom: 5px;
            font-size: 0.8rem;
            color: #ff00ff;
        }
        
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(255, 0, 255, 0.5);
            transition: height 0.1s;
        }
        
        /* Minimap */
        .minimap-container {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            overflow: hidden;
            padding: 10px;
        }
        
        .minimap-title {
            color: #ff00ff;
            text-align: center;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .minimap {
            width: 100%;
            height: calc(100% - 30px);
            background: rgba(0, 20, 40, 0.9);
            position: relative;
        }
        
        /* Controls Help */
        .controls-help {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 10px 20px;
            color: #0ff;
            font-size: 0.8rem;
            display: none;
        }
        
        .controls-help.show {
            display: block;
        }
        
        /* Messages */
        .message-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            text-align: center;
            width: 80%;
        }
        
        .message {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00ff;
            padding: 20px 40px;
            margin-bottom: 10px;
            color: #0ff;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
        }
        
        .message.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Pause Menu */
        #pauseMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: all;
        }
        
        .pause-title {
            font-size: 4rem;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 50px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        
        .pause-menu {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 300px;
        }
        
        .pause-button {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #0ff;
            padding: 20px;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .pause-button:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: #ff00ff;
            transform: scale(1.05);
        }
        
        /* Grid Overlay */
        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 1;
        }
        
        /* Animations */
        @keyframes glitch {
            0% { transform: translate(0); }
            2% { transform: translate(-2px, 2px); }
            4% { transform: translate(-2px, -2px); }
            6% { transform: translate(2px, 2px); }
            8% { transform: translate(2px, -2px); }
            10% { transform: translate(0); }
            100% { transform: translate(0); }
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.5; transform: scale(1); }
        }
        
        /* Key Display */
        .key-display {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ffff;
            padding: 2px 8px;
            margin: 0 3px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="cyberpunk-logo">CYBER RUNNER 2077</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">INITIALIZING NEURAL LINK...</div>
    </div>

    <!-- Settings Panel -->
    <div id="settingsPanel">
        <div class="settings-title">CONTROL CONFIGURATION</div>
        <div class="settings-container">
            <div class="settings-section">
                <div class="section-title">MOVEMENT</div>
                <div class="control-item">
                    <span class="control-label">Move Forward</span>
                    <div class="control-key" data-action="forward">W</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Move Backward</span>
                    <div class="control-key" data-action="backward">S</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Move Left</span>
                    <div class="control-key" data-action="left">A</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Move Right</span>
                    <div class="control-key" data-action="right">D</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Jump</span>
                    <div class="control-key" data-action="jump">Space</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Sprint</span>
                    <div class="control-key" data-action="sprint">Shift</div>
                </div>
            </div>
            
            <div class="settings-section">
                <div class="section-title">COMBAT</div>
                <div class="control-item">
                    <span class="control-label">Shoot</span>
                    <div class="control-key" data-action="shoot">Mouse Left</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Aim Down Sights</span>
                    <div class="control-key" data-action="aim">Mouse Right</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Reload</span>
                    <div class="control-key" data-action="reload">R</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Weapon 1</span>
                    <div class="control-key" data-action="weapon1">1</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Weapon 2</span>
                    <div class="control-key" data-action="weapon2">2</div>
                </div>
            </div>
            
            <div class="settings-section">
                <div class="section-title">ABILITIES</div>
                <div class="control-item">
                    <span class="control-label">Cyber Dash</span>
                    <div class="control-key" data-action="ability1">Q</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Neural Scan</span>
                    <div class="control-key" data-action="ability2">E</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Time Dilation</span>
                    <div class="control-key" data-action="ability3">F</div>
                </div>
            </div>
            
            <div class="settings-section">
                <div class="section-title">GAME CONTROLS</div>
                <div class="control-item">
                    <span class="control-label">Pause Game</span>
                    <div class="control-key" data-action="pause">Escape</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Show Controls</span>
                    <div class="control-key" data-action="help">H</div>
                </div>
                <div class="control-item">
                    <span class="control-label">Settings</span>
                    <div class="control-key" data-action="settings">F1</div>
                </div>
            </div>
            
            <div class="button-group">
                <button class="settings-button" id="saveSettings">SAVE SETTINGS</button>
                <button class="settings-button reset" id="resetSettings">RESET TO DEFAULT</button>
                <button class="settings-button" id="closeSettings">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameContainer"></canvas>

    <!-- UI Overlay -->
    <div id="uiOverlay">
        <!-- Grid Overlay -->
        <div class="grid-overlay"></div>
        
        <!-- HUD -->
        <div class="hud">
            <div class="top-bar">
                <div class="mission-info">
                    <div class="mission-title" id="missionTitle">INFILTRATE MEGACORP TOWER</div>
                    <div class="mission-objective" id="missionObjective">Upload virus to central server ‚Ä¢ Eliminate security</div>
                </div>
                <div class="stats-container">
                    <div class="stat-box">
                        <div class="stat-value" id="scoreValue">0</div>
                        <div class="stat-label">CREDITS</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="killCount">0</div>
                        <div class="stat-label">ELIMINATIONS</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="timeValue">00:00</div>
                        <div class="stat-label">MISSION TIME</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Health and Energy Bars -->
        <div class="bars-container">
            <div class="bar health-bar">
                <div class="bar-label">
                    <div class="bar-name">NEURAL INTEGRITY</div>
                    <div class="bar-value" id="healthValue">100%</div>
                </div>
                <div class="bar-track">
                    <div class="bar-fill" id="healthBar" style="width: 100%"></div>
                </div>
            </div>
            <div class="bar energy-bar">
                <div class="bar-label">
                    <div class="bar-name">CYBERNETIC ENERGY</div>
                    <div class="bar-value" id="energyValue">100%</div>
                </div>
                <div class="bar-track">
                    <div class="bar-fill" id="energyBar" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <!-- Weapon HUD -->
        <div class="weapon-hud">
            <div class="weapon-name" id="weaponName">PLASMA RIFLE</div>
            <div class="ammo-count" id="ammoCount">‚àû/‚àû</div>
            <div class="ammo-type" id="ammoType">ENERGY CELLS</div>
        </div>

        <!-- Abilities -->
        <div class="abilities-hud">
            <div class="ability-slot" id="ability1">
                <div class="ability-icon">‚ö°</div>
                <div class="ability-key" id="ability1Key">Q</div>
                <div class="ability-cooldown" id="ability1Cooldown"></div>
            </div>
            <div class="ability-slot" id="ability2">
                <div class="ability-icon">üëÅÔ∏è</div>
                <div class="ability-key" id="ability2Key">E</div>
                <div class="ability-cooldown" id="ability2Cooldown"></div>
            </div>
            <div class="ability-slot" id="ability3">
                <div class="ability-icon">üåÄ</div>
                <div class="ability-key" id="ability3Key">F</div>
                <div class="ability-cooldown" id="ability3Cooldown"></div>
            </div>
        </div>

        <!-- Minimap -->
        <div class="minimap-container">
            <div class="minimap-title">TACTICAL DISPLAY</div>
            <div class="minimap" id="minimap"></div>
        </div>

        <!-- Crosshair -->
        <div class="crosshair">
            <div class="crosshair-inner">
                <div class="crosshair-dot"></div>
                <div class="crosshair-line top"></div>
                <div class="crosshair-line bottom"></div>
                <div class="crosshair-line left"></div>
                <div class="crosshair-line right"></div>
            </div>
        </div>

        <!-- Controls Help -->
        <div class="controls-help" id="controlsHelp">
            Press <span class="key-display">H</span> to hide controls ‚Ä¢ Press <span class="key-display">F1</span> to configure
        </div>

        <!-- Messages -->
        <div class="message-container" id="messageContainer"></div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu">
        <div class="pause-title">PAUSED</div>
        <div class="pause-menu">
            <div class="pause-button" id="resumeButton">RESUME MISSION</div>
            <div class="pause-button" id="settingsButton">CONTROLS CONFIG</div>
            <div class="pause-button" id="restartButton">RESTART LEVEL</div>
            <div class="pause-button" id="quitButton">DISCONNECT</div>
        </div>
    </div>

    <script>
        // ================================
        // GAME CONFIGURATION
        // ================================
        const CONFIG = {
            // Graphics
            FOG_DENSITY: 0.002,
            FOG_COLOR: 0x000022,
            
            // Player
            PLAYER_SPEED: 5,
            PLAYER_JUMP_FORCE: 8,
            PLAYER_SPRINT_MULTIPLIER: 1.8,
            PLAYER_HEALTH: 100,
            PLAYER_ENERGY: 100,
            PLAYER_ENERGY_REGEN: 0.5,
            
            // Gameplay
            GRAVITY: -20,
            ENEMY_COUNT: 15,
            OBJECTIVE_DISTANCE: 200,
            TIME_LIMIT: 600,
            
            // Weapons
            WEAPONS: {
                plasma: {
                    name: 'PLASMA RIFLE',
                    damage: 25,
                    fireRate: 10,
                    energyCost: 5,
                    accuracy: 0.95,
                    ammoType: 'ENERGY CELLS'
                },
                railgun: {
                    name: 'RAILGUN',
                    damage: 75,
                    fireRate: 2,
                    energyCost: 20,
                    accuracy: 1.0,
                    ammoType: 'KINETIC ROUNDS'
                }
            },
            
            // Abilities
            ABILITIES: {
                dash: {
                    name: 'CYBER DASH',
                    cooldown: 3,
                    energyCost: 15,
                    duration: 0.3,
                    speedMultiplier: 5
                },
                scan: {
                    name: 'NEURAL SCAN',
                    cooldown: 8,
                    energyCost: 10,
                    duration: 5,
                    revealRadius: 50
                },
                timeWarp: {
                    name: 'TIME DILATION',
                    cooldown: 15,
                    energyCost: 30,
                    duration: 4,
                    slowFactor: 0.3
                }
            }
        };

        // ================================
        // CUSTOM CONTROLS SYSTEM
        // ================================
        const DEFAULT_CONTROLS = {
            forward: 'KeyW',
            backward: 'KeyS',
            left: 'KeyA',
            right: 'KeyD',
            jump: 'Space',
            sprint: 'ShiftLeft',
            shoot: 'Mouse0',
            aim: 'Mouse2',
            reload: 'KeyR',
            weapon1: 'Digit1',
            weapon2: 'Digit2',
            ability1: 'KeyQ',
            ability2: 'KeyE',
            ability3: 'KeyF',
            pause: 'Escape',
            help: 'KeyH',
            settings: 'F1'
        };

        let userControls = JSON.parse(localStorage.getItem('cyberrunner_controls')) || {...DEFAULT_CONTROLS};
        let editingControl = null;
        let keyBindings = {};

        function initializeControls() {
            // Convert control mapping to key bindings
            keyBindings = {};
            for (const [action, key] of Object.entries(userControls)) {
                keyBindings[key] = action;
            }
            
            // Update UI display
            updateControlDisplay();
        }

        function updateControlDisplay() {
            // Update control key displays
            for (const [action, key] of Object.entries(userControls)) {
                const element = document.querySelector(`.control-key[data-action="${action}"]`);
                if (element) {
                    element.textContent = formatKeyName(key);
                }
            }
            
            // Update ability key displays
            document.getElementById('ability1Key').textContent = formatKeyName(userControls.ability1);
            document.getElementById('ability2Key').textContent = formatKeyName(userControls.ability2);
            document.getElementById('ability3Key').textContent = formatKeyName(userControls.ability3);
        }

        function formatKeyName(keyCode) {
            const keyMap = {
                'KeyW': 'W',
                'KeyA': 'A',
                'KeyS': 'S',
                'KeyD': 'D',
                'KeyQ': 'Q',
                'KeyE': 'E',
                'KeyR': 'R',
                'KeyF': 'F',
                'KeyH': 'H',
                'Space': 'Space',
                'ShiftLeft': 'Shift',
                'ShiftRight': 'Shift',
                'Digit1': '1',
                'Digit2': '2',
                'Escape': 'Esc',
                'F1': 'F1',
                'Mouse0': 'Mouse L',
                'Mouse2': 'Mouse R'
            };
            
            return keyMap[keyCode] || keyCode.replace('Key', '').replace('Digit', '').replace('Arrow', '');
        }

        function saveControls() {
            localStorage.setItem('cyberrunner_controls', JSON.stringify(userControls));
            initializeControls();
            showMessage('CONTROLS SAVED', 'Custom controls have been saved');
        }

        function resetControls() {
            userControls = {...DEFAULT_CONTROLS};
            updateControlDisplay();
            showMessage('CONTROLS RESET', 'Default controls restored');
        }

        function setupControlListeners() {
            // Control key click listeners
            document.querySelectorAll('.control-key').forEach(element => {
                element.addEventListener('click', () => {
                    if (editingControl) {
                        editingControl.classList.remove('editing');
                    }
                    
                    editingControl = element;
                    editingControl.classList.add('editing');
                    editingControl.textContent = 'Press any key...';
                });
            });
            
            // Global key listener for control editing
            document.addEventListener('keydown', (e) => {
                if (editingControl) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = editingControl.dataset.action;
                    const keyCode = e.code;
                    
                    // Don't allow duplicate key bindings
                    for (const [existingAction, existingKey] of Object.entries(userControls)) {
                        if (existingKey === keyCode && existingAction !== action) {
                            showMessage('KEY ALREADY BOUND', `This key is already bound to ${existingAction}`);
                            return;
                        }
                    }
                    
                    userControls[action] = keyCode;
                    editingControl.classList.remove('editing');
                    editingControl.textContent = formatKeyName(keyCode);
                    editingControl = null;
                }
            });
            
            // Mouse button binding
            document.addEventListener('mousedown', (e) => {
                if (editingControl) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const action = editingControl.dataset.action;
                    const mouseCode = `Mouse${e.button}`;
                    
                    // Don't allow duplicate key bindings
                    for (const [existingAction, existingKey] of Object.entries(userControls)) {
                        if (existingKey === mouseCode && existingAction !== action) {
                            showMessage('BUTTON ALREADY BOUND', `This button is already bound to ${existingAction}`);
                            return;
                        }
                    }
                    
                    userControls[action] = mouseCode;
                    editingControl.classList.remove('editing');
                    editingControl.textContent = formatKeyName(mouseCode);
                    editingControl = null;
                }
            });
            
            // Settings buttons
            document.getElementById('saveSettings').addEventListener('click', saveControls);
            document.getElementById('resetSettings').addEventListener('click', resetControls);
            document.getElementById('closeSettings').addEventListener('click', () => {
                document.getElementById('settingsPanel').style.display = 'none';
                if (game.state === 'paused') {
                    document.getElementById('pauseMenu').style.display = 'flex';
                }
            });
        }

        // ================================
        // GAME STATE
        // ================================
        let game = {
            // Core
            scene: null,
            camera: null,
            renderer: null,
            clock: null,
            
            // World Seed (for procedural generation)
            worldSeed: Date.now(),
            
            // Player
            player: {
                mesh: null,
                position: new THREE.Vector3(0, 20, 0), // FIXED: Spawn higher
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: new THREE.Euler(0, 0, 0),
                health: CONFIG.PLAYER_HEALTH,
                energy: CONFIG.PLAYER_ENERGY,
                score: 0,
                kills: 0,
                weapon: 'plasma',
                abilities: {
                    dash: { active: false, cooldown: 0 },
                    scan: { active: false, cooldown: 0 },
                    timeWarp: { active: false, cooldown: 0 }
                }
            },
            
            // World
            world: {
                platforms: [],
                enemies: [],
                pickups: [],
                buildings: [],
                lights: [],
                particles: [],
                spawnPlatform: null,
                objectivePlatform: null
            },
            
            // Game State
            state: 'loading',
            timeElapsed: 0,
            objectiveComplete: false,
            gameOver: false,
            
            // Input
            keys: {},
            mouse: { x: 0, y: 0, buttons: {} },
            
            // UI
            ui: {
                controlsVisible: true,
                lastMessageTime: 0
            }
        };

        // ================================
        // PROCEDURAL GENERATION UTILITIES
        // ================================
        class ProceduralGenerator {
            constructor(seed) {
                this.seed = seed;
                this.random = this.seededRandom.bind(this);
            }
            
            seededRandom() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            
            randomInt(min, max) {
                return Math.floor(this.random() * (max - min + 1)) + min;
            }
            
            randomFloat(min, max) {
                return this.random() * (max - min) + min;
            }
            
            randomChoice(array) {
                return array[Math.floor(this.random() * array.length)];
            }
            
            // Perlin-like noise function (simplified)
            noise(x, y) {
                const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                return n - Math.floor(n);
            }
        }

        let generator = null;

        // ================================
        // INITIALIZATION
        // ================================
        async function init() {
            try {
                // Generate new seed for this session
                game.worldSeed = Date.now() + Math.random() * 1000;
                generator = new ProceduralGenerator(game.worldSeed);
                
                // Initialize controls
                initializeControls();
                setupControlListeners();
                
                // Initialize Three.js
                initThreeJS();
                
                // Create game world (completely random each time)
                await createWorld();
                
                // Set up player
                createPlayer();
                
                // Set up enemies
                createEnemies();
                
                // Set up pickups
                createPickups();
                
                // Set up lighting
                setupLighting();
                
                // Set up event listeners
                setupEventListeners();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        game.state = 'playing';
                        showMessage('INFILTRATION PROTOCOL ACTIVE', 'Get to the upload point');
                        
                        // Show controls help
                        document.getElementById('controlsHelp').classList.add('show');
                        setTimeout(() => {
                            document.getElementById('controlsHelp').classList.remove('show');
                        }, 5000);
                    }, 1000);
                }, 500);
                
                // Start game loop
                game.clock = new THREE.Clock();
                animate();
                
            } catch (error) {
                console.error('Failed to initialize game:', error);
                showMessage('SYSTEM ERROR', 'Failed to initialize neural interface');
            }
        }

        function initThreeJS() {
            // Scene
            game.scene = new THREE.Scene();
            game.scene.fog = new THREE.Fog(CONFIG.FOG_COLOR, 10, 1000);
            
            // Camera
            game.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            game.camera.position.set(0, 10, 20);
            
            // Renderer
            game.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameContainer'),
                antialias: true,
                alpha: true
            });
            game.renderer.setSize(window.innerWidth, window.innerHeight);
            game.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            game.renderer.shadowMap.enabled = true;
            game.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }

        async function createWorld() {
            // Clear any existing world
            game.world.platforms = [];
            game.world.enemies = [];
            game.world.pickups = [];
            game.world.buildings = [];
            game.world.lights = [];
            game.world.particles = [];
            
            // Skybox
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000033,
                side: THREE.BackSide
            });
            const skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            game.scene.add(skybox);
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x111122,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.position.y = -5;
            game.scene.add(ground);
            
            // Create completely random cyberpunk cityscape
            createCityscape();
            
            // Create random parkour course with spawn platform
            createParkourCourse();
            
            // Add decorative particles
            createParticles();
        }

        function createCityscape() {
            // Generate random number of buildings
            const buildingCount = generator.randomInt(15, 25);
            
            for (let i = 0; i < buildingCount; i++) {
                // Random building parameters
                const width = generator.randomFloat(10, 30);
                const depth = generator.randomFloat(10, 30);
                const height = generator.randomFloat(30, 200);
                
                // Choose random building color
                const buildingColors = [
                    new THREE.Color(0x222233),
                    new THREE.Color(0x333344),
                    new THREE.Color(0x223355),
                    new THREE.Color(0x334466)
                ];
                const color = generator.randomChoice(buildingColors);
                
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const building = new THREE.Mesh(geometry, material);
                
                // Position buildings in a ring around the play area
                const angle = (i / buildingCount) * Math.PI * 2;
                const radius = 150 + generator.randomFloat(0, 150);
                building.position.x = Math.cos(angle) * radius;
                building.position.z = Math.sin(angle) * radius;
                building.position.y = height / 2 - 5;
                
                building.castShadow = true;
                building.receiveShadow = true;
                
                game.scene.add(building);
                game.world.buildings.push(building);
                
                // Add windows to some buildings
                if (generator.random() > 0.3) {
                    addWindows(building, width, height, depth);
                }
                
                // Add lights to some buildings
                if (generator.random() > 0.7) {
                    addBuildingLights(building, width, height, depth);
                }
            }
        }

        function addWindows(building, width, height, depth) {
            const windowRows = Math.floor(height / 15);
            const windowCols = Math.floor((width + depth) * 2 / 10);
            
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    if (generator.random() > 0.7) {
                        const windowGeometry = new THREE.PlaneGeometry(2, 4);
                        const windowMaterial = new THREE.MeshBasicMaterial({
                            color: generator.random() > 0.5 ? 0x00aaff : 0xffaa00,
                            side: THREE.DoubleSide
                        });
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        
                        // Randomly place windows on different faces
                        const face = generator.randomInt(0, 3);
                        const windowY = (row / windowRows) * height - height/2 + 8;
                        
                        switch(face) {
                            case 0: // Front
                                window.position.set(generator.randomFloat(-width/2 + 2, width/2 - 2), 
                                                   windowY, 
                                                   depth/2 + 0.1);
                                break;
                            case 1: // Back
                                window.position.set(generator.randomFloat(-width/2 + 2, width/2 - 2), 
                                                   windowY, 
                                                   -depth/2 - 0.1);
                                window.rotation.y = Math.PI;
                                break;
                            case 2: // Left
                                window.position.set(-width/2 - 0.1, 
                                                   windowY, 
                                                   generator.randomFloat(-depth/2 + 2, depth/2 - 2));
                                window.rotation.y = Math.PI / 2;
                                break;
                            case 3: // Right
                                window.position.set(width/2 + 0.1, 
                                                   windowY, 
                                                   generator.randomFloat(-depth/2 + 2, depth/2 - 2));
                                window.rotation.y = -Math.PI / 2;
                                break;
                        }
                        
                        building.add(window);
                    }
                }
            }
        }

        function addBuildingLights(building, width, height, depth) {
            const lightCount = generator.randomInt(1, 3);
            
            for (let i = 0; i < lightCount; i++) {
                const lightColor = generator.random() > 0.5 ? 0xff00ff : 0x00ffff;
                const light = new THREE.PointLight(lightColor, 0.5, 50);
                
                light.position.set(
                    generator.randomFloat(-width/2, width/2),
                    generator.randomFloat(height/2, height - 10),
                    generator.randomFloat(-depth/2, depth/2)
                );
                
                building.add(light);
                game.world.lights.push(light);
            }
        }

        function createParkourCourse() {
            // Define platform types with their properties
            const platformTypes = [
                { type: 'spawn', size: [20, 2, 20], color: 0x00ff00 },
                { type: 'normal', size: [15, 2, 15], color: 0x00aaff },
                { type: 'small', size: [8, 2, 8], color: 0xff00aa },
                { type: 'long', size: [30, 2, 10], color: 0xaa00ff },
                { type: 'bridge', size: [40, 0.5, 6], color: 0x00ffaa }
            ];
            
            // Create path for platforms
            const platformCount = generator.randomInt(25, 35);
            const platformPositions = [];
            
            // Start position (spawn platform)
            const spawnPosition = new THREE.Vector3(0, 10, 0);
            
            // Create spawn platform (larger and green)
            const spawnPlatform = createPlatform(
                spawnPosition, 
                [20, 2, 20], 
                0x00ff00, 
                true
            );
            game.world.spawnPlatform = spawnPlatform;
            game.scene.add(spawnPlatform);
            game.world.platforms.push(spawnPlatform);
            platformPositions.push(spawnPosition.clone());
            
            // Set player spawn position ON TOP of platform (FIXED)
            game.player.position.copy(spawnPosition);
            game.player.position.y += 3; // Spawn on top of platform
            
            // Generate path for other platforms
            let lastPosition = spawnPosition.clone();
            
            for (let i = 0; i < platformCount; i++) {
                // Choose random platform type (but not spawn for others)
                const platformType = generator.randomChoice(platformTypes.filter(p => p.type !== 'spawn'));
                
                // Calculate next position
                const direction = new THREE.Vector3(
                    generator.randomFloat(-0.8, 0.8),
                    generator.randomFloat(-0.3, 0.5),
                    generator.randomFloat(-1.5, -0.5) // Generally move toward objective
                ).normalize();
                
                const distance = generator.randomFloat(10, 25);
                const nextPosition = lastPosition.clone().add(direction.multiplyScalar(distance));
                
                // Ensure minimum height
                nextPosition.y = Math.max(5, nextPosition.y);
                
                // Create platform
                const platform = createPlatform(
                    nextPosition,
                    platformType.size,
                    platformType.color,
                    false
                );
                
                game.scene.add(platform);
                game.world.platforms.push(platform);
                platformPositions.push(nextPosition.clone());
                
                // Add obstacles to some platforms
                if (generator.random() > 0.6 && i > 0) {
                    addObstacles(nextPosition, platformType.size);
                }
                
                lastPosition = nextPosition;
            }
            
            // Create objective platform (last platform)
            const objectivePosition = lastPosition.clone();
            objectivePosition.z -= generator.randomFloat(20, 40); // Move further for objective
            
            const objectivePlatform = createPlatform(
                objectivePosition,
                [25, 3, 25],
                0xff0000,
                true
            );
            game.world.objectivePlatform = objectivePlatform;
            game.scene.add(objectivePlatform);
            game.world.platforms.push(objectivePlatform);
            
            // Add objective tower on objective platform
            createObjectiveTower(objectivePosition);
            
            // Connect some platforms with bridges
            createBridges(platformPositions);
            
            // Add floating platforms between main ones
            createFloatingPlatforms(platformPositions);
        }

        function createPlatform(position, size, color, isSpecial) {
            const geometry = new THREE.BoxGeometry(...size);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.6
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.copy(position);
            platform.castShadow = true;
            platform.receiveShadow = true;
            
            // Add glow effect for special platforms
            if (isSpecial) {
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    linewidth: 2
                });
                const line = new THREE.LineSegments(edges, lineMaterial);
                platform.add(line);
                
                // Add pulsing light
                const light = new THREE.PointLight(color, 0.8, 30);
                light.position.set(0, 10, 0);
                platform.add(light);
                game.world.lights.push(light);
            }
            
            return platform;
        }

        function addObstacles(position, platformSize) {
            const obstacleType = generator.randomInt(0, 2);
            const count = generator.randomInt(2, 5);
            
            for (let i = 0; i < count; i++) {
                let obstacle;
                
                switch(obstacleType) {
                    case 0: // Laser pillars
                        const pillarGeometry = new THREE.CylinderGeometry(0.3, 0.3, 10, 8);
                        const pillarMaterial = new THREE.MeshBasicMaterial({
                            color: 0xff0000
                        });
                        obstacle = new THREE.Mesh(pillarGeometry, pillarMaterial);
                        
                        obstacle.position.copy(position);
                        obstacle.position.x += generator.randomFloat(-platformSize[0]/2 + 2, platformSize[0]/2 - 2);
                        obstacle.position.z += generator.randomFloat(-platformSize[2]/2 + 2, platformSize[2]/2 - 2);
                        obstacle.position.y += 5;
                        break;
                        
                    case 1: // Energy barriers
                        const barrierGeometry = new THREE.PlaneGeometry(6, 8);
                        const barrierMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.5,
                            side: THREE.DoubleSide
                        });
                        obstacle = new THREE.Mesh(barrierGeometry, barrierMaterial);
                        
                        obstacle.position.copy(position);
                        obstacle.position.x += generator.randomFloat(-platformSize[0]/2 + 3, platformSize[0]/2 - 3);
                        obstacle.position.z += generator.randomFloat(-platformSize[2]/2 + 3, platformSize[2]/2 - 3);
                        obstacle.position.y += 4;
                        obstacle.rotation.y = generator.randomFloat(0, Math.PI * 2);
                        break;
                        
                    case 2: // Spike traps
                        const spikeGeometry = new THREE.ConeGeometry(0.8, 2, 4);
                        const spikeMaterial = new THREE.MeshStandardMaterial({
                            color: 0xff5500
                        });
                        obstacle = new THREE.Mesh(spikeGeometry, spikeMaterial);
                        
                        obstacle.position.copy(position);
                        obstacle.position.x += generator.randomFloat(-platformSize[0]/2 + 1, platformSize[0]/2 - 1);
                        obstacle.position.z += generator.randomFloat(-platformSize[2]/2 + 1, platformSize[2]/2 - 1);
                        obstacle.position.y += 1;
                        break;
                }
                
                game.scene.add(obstacle);
                game.world.platforms.push(obstacle);
            }
        }

        function createObjectiveTower(position) {
            const towerHeight = generator.randomFloat(50, 100);
            const towerGeometry = new THREE.CylinderGeometry(5, 8, towerHeight, 8);
            const towerMaterial = new THREE.MeshStandardMaterial({
                color: 0xaa00ff,
                roughness: 0.2,
                metalness: 0.8
            });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            
            tower.position.copy(position);
            tower.position.y += towerHeight / 2;
            tower.castShadow = true;
            
            game.scene.add(tower);
            
            // Add glowing light to tower
            const towerLight = new THREE.PointLight(0xff00ff, 2, 100);
            towerLight.position.copy(position);
            towerLight.position.y += towerHeight;
            game.scene.add(towerLight);
            game.world.lights.push(towerLight);
            
            // Add rotating rings around tower
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.TorusGeometry(10 + i * 3, 0.5, 8, 24);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                
                ring.position.copy(position);
                ring.position.y += 15 + i * 25;
                ring.rotation.x = Math.PI / 2;
                
                ring.userData = {
                    rotationSpeed: generator.randomFloat(0.5, 1.5),
                    timeOffset: i * Math.PI / 3
                };
                
                game.scene.add(ring);
                game.world.platforms.push(ring);
            }
        }

        function createBridges(platformPositions) {
            // Connect some platforms with bridges
            for (let i = 0; i < platformPositions.length - 1; i++) {
                if (generator.random() > 0.7) {
                    const start = platformPositions[i];
                    const end = platformPositions[i + 1];
                    
                    // Calculate bridge parameters
                    const distance = start.distanceTo(end);
                    const direction = new THREE.Vector3().subVectors(end, start).normalize();
                    
                    // Create bridge
                    const bridgeGeometry = new THREE.BoxGeometry(distance, 0.5, 3);
                    const bridgeMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffff00,
                        roughness: 0.5,
                        metalness: 0.5
                    });
                    const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
                    
                    // Position bridge between platforms
                    bridge.position.copy(start).add(direction.multiplyScalar(distance / 2));
                    bridge.position.y += 5; // Raise bridge above platforms
                    
                    // Rotate bridge to face end platform
                    bridge.lookAt(end);
                    bridge.rotateX(Math.PI / 2);
                    
                    bridge.castShadow = true;
                    bridge.receiveShadow = true;
                    
                    game.scene.add(bridge);
                    game.world.platforms.push(bridge);
                }
            }
        }

        function createFloatingPlatforms(platformPositions) {
            const floatingCount = generator.randomInt(10, 20);
            
            for (let i = 0; i < floatingCount; i++) {
                // Choose a random position between existing platforms
                const startIdx = generator.randomInt(0, platformPositions.length - 2);
                const start = platformPositions[startIdx];
                const end = platformPositions[startIdx + 1];
                
                // Random position between platforms
                const t = generator.random();
                const position = new THREE.Vector3().lerpVectors(start, end, t);
                
                // Add vertical offset
                position.y += generator.randomFloat(5, 25);
                
                // Random size and color
                const size = generator.randomFloat(3, 8);
                const colors = [0xff00ff, 0x00ffff, 0xffff00, 0xff8800];
                const color = generator.randomChoice(colors);
                
                // Create floating platform
                const geometry = new THREE.BoxGeometry(size, 0.5, size);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.4,
                    metalness: 0.6
                });
                const platform = new THREE.Mesh(geometry, material);
                
                platform.position.copy(position);
                platform.castShadow = true;
                platform.receiveShadow = true;
                
                // Add floating animation data
                platform.userData = {
                    floatHeight: position.y,
                    floatSpeed: generator.randomFloat(0.5, 2),
                    floatOffset: generator.random() * Math.PI * 2
                };
                
                game.scene.add(platform);
                game.world.platforms.push(platform);
            }
        }

        function createParticles() {
            const particleCount = generator.randomInt(50, 150);
            
            for (let i = 0; i < particleCount; i++) {
                const size = generator.randomFloat(0.1, 0.5);
                const geometry = new THREE.SphereGeometry(size);
                const color = generator.random() > 0.5 ? 0x00ffff : 0xff00ff;
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: generator.randomFloat(0.3, 0.7)
                });
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.set(
                    generator.randomFloat(-200, 200),
                    generator.randomFloat(20, 100),
                    generator.randomFloat(-200, 200)
                );
                
                particle.userData = {
                    speed: generator.randomFloat(0.1, 0.5),
                    amplitude: generator.randomFloat(2, 10),
                    offset: generator.random() * Math.PI * 2,
                    rotationSpeed: generator.randomFloat(0.01, 0.05)
                };
                
                game.scene.add(particle);
                game.world.particles.push(particle);
            }
        }

        function createPlayer() {
            // Create player using simple geometry (FIXED: No CapsuleGeometry)
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                roughness: 0.3,
                metalness: 0.7
            });
            game.player.mesh = new THREE.Mesh(geometry, material);
            game.player.mesh.position.copy(game.player.position);
            game.player.mesh.castShadow = true;
            game.scene.add(game.player.mesh);
            
            // Create player weapon (FIXED: No emissive property)
            createWeapon();
        }

        function createWeapon() {
            const weaponGroup = new THREE.Group();
            
            // Weapon body
            const bodyGeometry = new THREE.BoxGeometry(2, 0.6, 0.6);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                roughness: 0.2,
                metalness: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            weaponGroup.add(body);
            
            // Weapon barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8);
            const barrelMaterial = new THREE.MeshStandardMaterial({
                color: 0x888899,
                roughness: 0.1,
                metalness: 0.9
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.z = -0.8;
            weaponGroup.add(barrel);
            
            // Energy core
            const coreGeometry = new THREE.SphereGeometry(0.2);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.z = 0.3;
            weaponGroup.add(core);
            
            weaponGroup.position.set(0.5, -0.3, -1);
            game.player.mesh.add(weaponGroup);
        }

        function createEnemies() {
            const enemyCount = generator.randomInt(10, 20);
            
            for (let i = 0; i < enemyCount; i++) {
                // Choose random platform for enemy (not spawn platform)
                const availablePlatforms = game.world.platforms.filter(p => p !== game.world.spawnPlatform);
                if (availablePlatforms.length === 0) continue;
                
                const platform = generator.randomChoice(availablePlatforms);
                const enemy = createDrone();
                
                // Position enemy on platform
                enemy.position.copy(platform.position);
                enemy.position.y += 3;
                enemy.position.x += generator.randomFloat(-5, 5);
                enemy.position.z += generator.randomFloat(-5, 5);
                
                game.scene.add(enemy);
                game.world.enemies.push({
                    mesh: enemy,
                    health: 100,
                    type: 'drone',
                    lastShot: 0,
                    target: null,
                    state: 'patrol',
                    patrolPoint: enemy.position.clone(),
                    patrolRadius: generator.randomFloat(5, 15)
                });
            }
        }

        function createDrone() {
            const group = new THREE.Group();
            
            // Drone body
            const bodyGeometry = new THREE.SphereGeometry(1, 8, 6);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xff3300,
                roughness: 0.5,
                metalness: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            
            // Drone wings
            const wingGeometry = new THREE.BoxGeometry(3, 0.1, 0.8);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444
            });
            
            for (let i = 0; i < 4; i++) {
                const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                wing.rotation.y = (i / 4) * Math.PI * 2;
                group.add(wing);
            }
            
            // Red eye (FIXED: No emissive property)
            const eyeGeometry = new THREE.SphereGeometry(0.3);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000
            });
            const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eye.position.z = 1;
            group.add(eye);
            
            return group;
        }

        function createPickups() {
            const pickupTypes = ['health', 'energy', 'ammo', 'score'];
            const pickupCount = generator.randomInt(15, 25);
            
            for (let i = 0; i < pickupCount; i++) {
                const type = generator.randomChoice(pickupTypes);
                const pickup = createPickup(type);
                
                // Position pickup on random platform
                const platform = generator.randomChoice(game.world.platforms);
                pickup.position.copy(platform.position);
                pickup.position.y += 2;
                pickup.position.x += generator.randomFloat(-platform.geometry.parameters.width/2 + 1, 
                                                           platform.geometry.parameters.width/2 - 1);
                pickup.position.z += generator.randomFloat(-platform.geometry.parameters.depth/2 + 1, 
                                                           platform.geometry.parameters.depth/2 - 1);
                
                game.scene.add(pickup);
                game.world.pickups.push({
                    mesh: pickup,
                    type: type,
                    value: type === 'score' ? 100 : 25,
                    collected: false,
                    floatHeight: pickup.position.y,
                    rotationSpeed: generator.randomFloat(0.02, 0.05)
                });
            }
        }

        function createPickup(type) {
            const group = new THREE.Group();
            let color, shape;
            
            switch(type) {
                case 'health':
                    color = 0xff0000;
                    shape = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    break;
                case 'energy':
                    color = 0x00ffff;
                    shape = new THREE.SphereGeometry(0.6);
                    break;
                case 'ammo':
                    color = 0xffff00;
                    shape = new THREE.CylinderGeometry(0.4, 0.4, 1, 6);
                    break;
                case 'score':
                    color = 0x00ff00;
                    shape = new THREE.OctahedronGeometry(0.7);
                    break;
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.2,
                metalness: 0.8
            });
            const crystal = new THREE.Mesh(shape, material);
            group.add(crystal);
            
            return group;
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x222233, 0.3);
            game.scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0x4466ff, 0.5);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            game.scene.add(directionalLight);
            
            // Add some random point lights for atmosphere
            const lightCount = generator.randomInt(5, 10);
            for (let i = 0; i < lightCount; i++) {
                const color = generator.random() > 0.5 ? 0xff00ff : 0x00ffff;
                const intensity = generator.randomFloat(0.3, 1);
                const distance = generator.randomFloat(20, 60);
                
                const light = new THREE.PointLight(color, intensity, distance);
                light.position.set(
                    generator.randomFloat(-150, 150),
                    generator.randomFloat(10, 50),
                    generator.randomFloat(-150, 150)
                );
                game.scene.add(light);
                game.world.lights.push(light);
            }
        }

        function setupEventListeners() {
            // Keyboard events using custom controls
            document.addEventListener('keydown', (e) => {
                const action = keyBindings[e.code];
                if (action) {
                    game.keys[action] = true;
                    
                    // Handle special actions
                    switch(action) {
                        case 'pause':
                            togglePause();
                            break;
                        case 'help':
                            toggleControlsHelp();
                            break;
                        case 'settings':
                            openSettings();
                            break;
                        case 'weapon1':
                            switchWeapon('plasma');
                            break;
                        case 'weapon2':
                            switchWeapon('railgun');
                            break;
                        case 'reload':
                            reloadWeapon();
                            break;
                        case 'ability1':
                            activateAbility('dash');
                            break;
                        case 'ability2':
                            activateAbility('scan');
                            break;
                        case 'ability3':
                            activateAbility('timeWarp');
                            break;
                    }
                }
                
                // Prevent default for game keys
                if (action && game.state === 'playing') {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                const action = keyBindings[e.code];
                if (action) {
                    game.keys[action] = false;
                }
            });
            
            // Mouse events
            document.addEventListener('mousedown', (e) => {
                const mouseCode = `Mouse${e.button}`;
                const action = keyBindings[mouseCode];
                
                if (action) {
                    game.mouse.buttons[action] = true;
                    
                    if (action === 'shoot' && game.state === 'playing') {
                        shoot();
                    }
                }
                
                if (game.state === 'playing') {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                const mouseCode = `Mouse${e.button}`;
                const action = keyBindings[mouseCode];
                
                if (action) {
                    game.mouse.buttons[action] = false;
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                game.mouse.x = e.clientX;
                game.mouse.y = e.clientY;
                
                if (document.pointerLockElement === document.getElementById('gameContainer')) {
                    updatePlayerRotation(e.movementX, e.movementY);
                }
            });
            
            // Pointer lock
            document.getElementById('gameContainer').addEventListener('click', () => {
                if (game.state === 'playing') {
                    document.getElementById('gameContainer').requestPointerLock();
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                game.camera.aspect = window.innerWidth / window.innerHeight;
                game.camera.updateProjectionMatrix();
                game.renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Pause menu buttons
            document.getElementById('resumeButton').addEventListener('click', () => {
                togglePause();
            });
            
            document.getElementById('settingsButton').addEventListener('click', () => {
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('settingsPanel').style.display = 'flex';
            });
            
            document.getElementById('restartButton').addEventListener('click', () => {
                // Generate new world on restart
                game.worldSeed = Date.now() + Math.random() * 1000;
                location.reload();
            });
            
            document.getElementById('quitButton').addEventListener('click', () => {
                if (confirm('Are you sure you want to quit?')) {
                    window.close();
                }
            });
        }

        // ================================
        // GAME LOGIC
        // ================================
        function updatePlayerRotation(deltaX, deltaY) {
            const sensitivity = 0.002;
            
            // Update player rotation
            game.player.rotation.y -= deltaX * sensitivity;
            game.player.rotation.x -= deltaY * sensitivity;
            
            // Clamp vertical rotation
            game.player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, game.player.rotation.x));
            
            // Apply rotation to mesh
            game.player.mesh.rotation.y = game.player.rotation.y;
        }

        function updatePlayer(deltaTime) {
            // Calculate movement direction using custom controls
            const moveDirection = new THREE.Vector3(0, 0, 0);
            
            if (game.keys.forward) moveDirection.z -= 1;
            if (game.keys.backward) moveDirection.z += 1;
            if (game.keys.left) moveDirection.x -= 1;
            if (game.keys.right) moveDirection.x += 1;
            
            // Normalize movement
            if (moveDirection.length() > 0) {
                moveDirection.normalize();
                
                // Apply rotation to movement direction
                const yaw = game.player.rotation.y;
                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);
                
                const rotatedX = moveDirection.x * cosYaw - moveDirection.z * sinYaw;
                const rotatedZ = moveDirection.x * sinYaw + moveDirection.z * cosYaw;
                
                moveDirection.x = rotatedX;
                moveDirection.z = rotatedZ;
                
                // Calculate speed
                let speed = CONFIG.PLAYER_SPEED;
                if (game.keys.sprint) {
                    speed *= CONFIG.PLAYER_SPRINT_MULTIPLIER;
                }
                
                if (game.player.abilities.dash.active) {
                    speed *= CONFIG.ABILITIES.dash.speedMultiplier;
                }
                
                // Apply movement
                game.player.velocity.x = moveDirection.x * speed;
                game.player.velocity.z = moveDirection.z * speed;
            } else {
                // Slow down when not moving
                game.player.velocity.x *= 0.9;
                game.player.velocity.z *= 0.9;
            }
            
            // Jump using custom control
            if (game.keys.jump && Math.abs(game.player.velocity.y) < 0.1) {
                game.player.velocity.y = CONFIG.PLAYER_JUMP_FORCE;
            }
            
            // Apply gravity
            game.player.velocity.y += CONFIG.GRAVITY * deltaTime;
            
            // Apply velocity
            game.player.position.x += game.player.velocity.x * deltaTime;
            game.player.position.y += game.player.velocity.y * deltaTime;
            game.player.position.z += game.player.velocity.z * deltaTime;
            
            // Simple ground collision check
            let isOnGround = false;
            for (const platform of game.world.platforms) {
                const platformTop = platform.position.y + platform.geometry.parameters.height / 2;
                const distanceToPlatform = Math.abs(game.player.position.y - platformTop);
                
                if (distanceToPlatform < 0.5 && 
                    Math.abs(game.player.position.x - platform.position.x) < platform.geometry.parameters.width / 2 &&
                    Math.abs(game.player.position.z - platform.position.z) < platform.geometry.parameters.depth / 2) {
                    
                    isOnGround = true;
                    game.player.position.y = platformTop + 0.5;
                    game.player.velocity.y = 0;
                    break;
                }
            }
            
            // If not on any platform, check ground
            if (!isOnGround && game.player.position.y < 1) {
                game.player.position.y = 1;
                game.player.velocity.y = 0;
            }
            
            // Update player mesh position
            game.player.mesh.position.copy(game.player.position);
            
            // Update camera position (first-person)
            const cameraOffset = new THREE.Vector3(0, 1, 0);
            cameraOffset.applyEuler(game.player.rotation);
            game.camera.position.copy(game.player.position).add(cameraOffset);
            game.camera.rotation.copy(game.player.rotation);
            
            // Regenerate energy
            if (game.player.energy < CONFIG.PLAYER_ENERGY) {
                game.player.energy += CONFIG.PLAYER_ENERGY_REGEN * deltaTime;
                game.player.energy = Math.min(game.player.energy, CONFIG.PLAYER_ENERGY);
                updateEnergyBar();
            }
            
            // Update ability cooldowns
            updateAbilities(deltaTime);
        }

        function updateWorldObjects(deltaTime) {
            const now = Date.now();
            
            // Update floating platforms
            for (const platform of game.world.platforms) {
                if (platform.userData && platform.userData.floatHeight !== undefined) {
                    const time = now * 0.001;
                    platform.position.y = platform.userData.floatHeight + 
                                        Math.sin(time * platform.userData.floatSpeed + platform.userData.floatOffset) * 2;
                }
            }
            
            // Update particles
            for (const particle of game.world.particles) {
                if (particle.userData) {
                    const time = now * 0.001;
                    
                    // Floating animation
                    if (particle.userData.amplitude) {
                        particle.position.y += Math.sin(time * particle.userData.speed + particle.userData.offset) * 0.05;
                        particle.rotation.y += particle.userData.rotationSpeed;
                    }
                }
            }
            
            // Update pickups
            for (const pickup of game.world.pickups) {
                if (!pickup.collected && pickup.mesh) {
                    const time = now * 0.001;
                    pickup.mesh.rotation.y += pickup.rotationSpeed;
                    pickup.mesh.position.y = pickup.floatHeight + Math.sin(time * 2) * 0.5;
                }
            }
        }

        // (Remaining game logic functions remain the same as before - shortened for space)
        // These include: updateEnemies, shootEnemy, updateParticles, updatePickups, 
        // collectPickup, updateAbilities, activateAbility, shoot, checkHit, 
        // enemyKilled, takeDamage, checkObjective, switchWeapon, reloadWeapon

        // ================================
        // UI FUNCTIONS
        // ================================
        function updateHealthBar() {
            const percent = (game.player.health / CONFIG.PLAYER_HEALTH) * 100;
            document.getElementById('healthBar').style.width = percent + '%';
            document.getElementById('healthValue').textContent = Math.round(percent) + '%';
        }

        function updateEnergyBar() {
            const percent = (game.player.energy / CONFIG.PLAYER_ENERGY) * 100;
            document.getElementById('energyBar').style.width = percent + '%';
            document.getElementById('energyValue').textContent = Math.round(percent) + '%';
        }

        function updateScore() {
            document.getElementById('scoreValue').textContent = game.player.score;
        }

        function updateKillCount() {
            document.getElementById('killCount').textContent = game.player.kills;
        }

        function updateTime() {
            game.timeElapsed += 1;
            const minutes = Math.floor(game.timeElapsed / 60);
            const seconds = game.timeElapsed % 60;
            document.getElementById('timeValue').textContent = 
                minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
        }

        function updateWeaponHUD() {
            const weapon = CONFIG.WEAPONS[game.player.weapon];
            document.getElementById('weaponName').textContent = weapon.name;
            document.getElementById('ammoType').textContent = weapon.ammoType;
            document.getElementById('ammoCount').textContent = '‚àû/‚àû';
        }

        function updateAbilityCooldown(abilityName, cooldownPercent) {
            const element = document.getElementById(abilityName + 'Cooldown');
            if (element) {
                element.style.height = (cooldownPercent * 100) + '%';
            }
        }

        function showMessage(title, text) {
            const messageContainer = document.getElementById('messageContainer');
            const message = document.createElement('div');
            message.className = 'message show';
            message.innerHTML = `
                <div style="color:#ff00ff; margin-bottom:5px;">${title}</div>
                <div style="color:#00ffff; font-size:0.9rem;">${text}</div>
            `;
            
            messageContainer.appendChild(message);
            
            // Remove after delay
            setTimeout(() => {
                message.classList.remove('show');
                setTimeout(() => {
                    if (message.parentNode) {
                        message.parentNode.removeChild(message);
                    }
                }, 300);
            }, 3000);
        }

        function togglePause() {
            if (game.state === 'playing') {
                game.state = 'paused';
                document.getElementById('pauseMenu').style.display = 'flex';
                document.exitPointerLock();
            } else if (game.state === 'paused') {
                game.state = 'playing';
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('settingsPanel').style.display = 'none';
            }
        }

        function toggleControlsHelp() {
            game.ui.controlsVisible = !game.ui.controlsVisible;
            document.getElementById('controlsHelp').classList.toggle('show', game.ui.controlsVisible);
        }

        function openSettings() {
            if (game.state === 'playing') {
                game.state = 'paused';
                document.exitPointerLock();
            }
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('settingsPanel').style.display = 'flex';
        }

        function gameOver() {
            game.state = 'gameOver';
            showMessage('NEURAL INTEGRITY CRITICAL', 'Mission failed. Disconnecting...');
            
            setTimeout(() => {
                // Generate new world on game over
                game.worldSeed = Date.now() + Math.random() * 1000;
                location.reload();
            }, 3000);
        }

        // ================================
        // GAME LOOP
        // ================================
        function animate() {
            requestAnimationFrame(animate);
            
            if (game.state === 'loading') return;
            
            const deltaTime = game.clock.getDelta();
            
            if (game.state === 'playing') {
                // Update game logic
                updatePlayer(deltaTime);
                updateWorldObjects(deltaTime);
                
                // Update time every second
                if (Date.now() - game.ui.lastMessageTime > 1000) {
                    updateTime();
                    game.ui.lastMessageTime = Date.now();
                }
            }
            
            // Render
            game.renderer.render(game.scene, game.camera);
        }

        // ================================
        // LOADING PROGRESS
        // ================================
        function updateLoadingProgress(progress, text) {
            document.getElementById('loadingBar').style.width = progress + '%';
            document.getElementById('loadingText').textContent = text;
        }

        // Simulate loading
        const loadingSteps = [
            { progress: 10, text: 'INITIALIZING NEURAL LINK...' },
            { progress: 25, text: 'GENERATING PROCEDURAL WORLD...' },
            { progress: 40, text: 'CALIBRATING OPTICS...' },
            { progress: 60, text: 'SYNCHRONIZING WEAPONS SYSTEMS...' },
            { progress: 80, text: 'POPULATING ENVIRONMENT...' },
            { progress: 95, text: 'FINALIZING INFILTRATION PROTOCOL...' },
            { progress: 100, text: 'READY FOR DEPLOYMENT' }
        ];

        let currentStep = 0;
        const loadingInterval = setInterval(() => {
            if (currentStep < loadingSteps.length) {
                updateLoadingProgress(
                    loadingSteps[currentStep].progress,
                    loadingSteps[currentStep].text
                );
                currentStep++;
            } else {
                clearInterval(loadingInterval);
                init();
            }
        }, 500);

        // Initialize when page loads
        window.addEventListener('load', () => {
            // Loading already simulated
        });
    </script>
</body>
</html>
