<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Riders: Delivery Chaos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        /* UI Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            padding: 20px;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: #ff6b6b;
            text-shadow: 3px 3px 0 #ff4757;
            text-align: center;
        }

        h2 {
            font-size: 2em;
            margin-bottom: 30px;
            color: #70a1ff;
        }

        .menu-container {
            max-width: 600px;
            width: 90%;
            background: rgba(30, 30, 60, 0.8);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff6b6b;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }

        button {
            padding: 15px 30px;
            font-size: 1.2em;
            background: linear-gradient(45deg, #ff6b6b, #ff4757);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 180px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
            background: linear-gradient(45deg, #ff4757, #ff3838);
        }

        button.secondary {
            background: linear-gradient(45deg, #3742fa, #5352ed);
        }

        button.secondary:hover {
            background: linear-gradient(45deg, #5352ed, #3742fa);
        }

        .input-group {
            margin: 20px 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #70a1ff;
            font-size: 1.1em;
        }

        input, select {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #3742fa;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .room-code {
            font-size: 2.5em;
            letter-spacing: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            color: #2ed573;
        }

        .player-list {
            list-style: none;
            margin: 20px 0;
        }

        .player-list li {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            align-items: center;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            min-width: 250px;
            z-index: 10;
        }

        .hud-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }

        .hud-label {
            color: #70a1ff;
            font-weight: bold;
        }

        .hud-value {
            color: #2ed573;
            font-weight: bold;
            font-size: 1.1em;
        }

        #speedometer {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 150px;
            height: 150px;
        }

        .speed-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 3px;
            height: 60px;
            background: #ff4757;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(0deg);
            transition: transform 0.1s;
        }

        .speed-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            font-size: 0.8em;
            color: white;
        }

        .products-grid {
            display: grid;
            grid-template-columns: repeat(5, 30px);
            gap: 5px;
            margin-top: 10px;
        }

        .product-item {
            width: 30px;
            height: 30px;
            background: #2ed573;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .product-item.damaged {
            background: #ff4757;
            transform: scale(0.8);
        }

        /* Loading Screen */
        #loadingScreen {
            background: #1a1a2e;
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 30px 0;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff4757);
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }

        .loading-text {
            margin-top: 20px;
            color: #70a1ff;
        }

        /* Controls Info */
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #3742fa;
            color: white;
            max-width: 300px;
        }

        .controls-info h3 {
            color: #70a1ff;
            margin-bottom: 10px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .control-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Loading Screen -->
        <div id="loadingScreen" class="screen">
            <h1>Cart Riders</h1>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
            <div class="loading-text" id="loadingText">Loading assets...</div>
        </div>

        <!-- Start Menu -->
        <div id="startMenu" class="screen hidden">
            <div class="menu-container">
                <h1>Delivery Chaos</h1>
                
                <div class="button-group">
                    <button id="playSolo">Solo Delivery</button>
                    <button id="multiplayer" class="secondary">Multiplayer Race</button>
                    <button id="settings">Settings</button>
                </div>

                <div class="input-group">
                    <label for="botCount">Bot Count (0-4):</label>
                    <input type="range" id="botCount" min="0" max="4" value="2">
                    <span id="botCountDisplay">2</span>
                </div>

                <div class="controls-info">
                    <h3>Controls</h3>
                    <div class="control-item">
                        <span>Move:</span>
                        <span class="control-key">WASD / Arrows</span>
                    </div>
                    <div class="control-item">
                        <span>Boost:</span>
                        <span class="control-key">SPACE / A Button</span>
                    </div>
                    <div class="control-item">
                        <span>Pause:</span>
                        <span class="control-key">ESC / Start</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Multiplayer Lobby -->
        <div id="multiplayerLobby" class="screen hidden">
            <div class="menu-container">
                <h2>Multiplayer Lobby</h2>
                
                <div class="button-group">
                    <button id="createRoom">Create Room</button>
                    <button id="joinRoom" class="secondary">Join Room</button>
                    <button id="backToMenu">Back</button>
                </div>

                <div id="roomCodeSection" class="hidden">
                    <div class="room-code" id="roomCode">----</div>
                    <p>Share this code with other players!</p>
                    <div id="playerList">
                        <h3>Players (1/8):</h3>
                        <ul class="player-list" id="playerListItems">
                            <li>
                                <div class="player-color" style="background: #ff4757;"></div>
                                <span>Host (You)</span>
                            </li>
                        </ul>
                    </div>
                    <button id="startGame">Start Game</button>
                </div>

                <div id="joinSection" class="hidden">
                    <div class="input-group">
                        <label for="roomCodeInput">Enter Room Code:</label>
                        <input type="text" id="roomCodeInput" maxlength="4" placeholder="ABCD">
                    </div>
                    <button id="connectToRoom">Connect</button>
                </div>
            </div>
        </div>

        <!-- Game HUD -->
        <div id="hud" class="hidden">
            <div class="hud-item">
                <span class="hud-label">Speed:</span>
                <span class="hud-value" id="speedValue">0 km/h</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Products:</span>
                <span class="hud-value" id="productCount">15/15</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Profit:</span>
                <span class="hud-value" id="profitValue">$0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Distance:</span>
                <span class="hud-value" id="distanceValue">1000m</span>
            </div>
            <div class="products-grid" id="productsGrid"></div>
        </div>

        <!-- Speedometer -->
        <div id="speedometer" class="hidden">
            <div class="speed-labels">
                <span style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%);">0</span>
                <span style="position: absolute; top: 50%; right: 10px; transform: translateY(-50%);">50</span>
                <span style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);">100</span>
                <span style="position: absolute; top: 50%; left: 10px; transform: translateY(-50%);">-50</span>
            </div>
            <div class="speed-needle" id="speedNeedle"></div>
        </div>

        <!-- Pause Menu -->
        <div id="pauseMenu" class="screen hidden">
            <div class="menu-container">
                <h2>Game Paused</h2>
                <div class="button-group">
                    <button id="resumeGame">Resume</button>
                    <button id="restartGame">Restart</button>
                    <button id="quitToMenu">Quit to Menu</button>
                </div>
            </div>
        </div>

        <!-- End Screen -->
        <div id="endScreen" class="screen hidden">
            <div class="menu-container">
                <h1 id="endTitle">Delivery Complete!</h1>
                <div style="font-size: 1.5em; margin: 20px 0;">
                    <div>Final Profit: <span id="finalProfit" style="color: #2ed573;">$0</span></div>
                    <div>Products Delivered: <span id="deliveredCount" style="color: #2ed573;">0/15</span></div>
                    <div>Distance Traveled: <span id="totalDistance" style="color: #70a1ff;">0m</span></div>
                </div>
                <div class="button-group">
                    <button id="playAgain">Play Again</button>
                    <button id="endToMenu">Main Menu</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Main Game Class
        class CartRidersGame {
            constructor() {
                // Three.js setup
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                // Game objects
                this.carts = [];
                this.players = [];
                this.bots = [];
                this.obstacles = [];
                this.roadSegments = [];
                
                // Game state
                this.gameState = 'LOADING'; // LOADING, MENU, LOBBY, PLAYING, PAUSED, ENDED
                this.isMultiplayer = false;
                this.botCount = 2;
                
                // Physics
                this.gravity = 9.8;
                this.physicsObjects = [];
                
                // UI elements
                this.uiElements = {};
                this.bindUIElements();
                
                // Input
                this.keys = {};
                this.gamepads = {};
                this.input = {
                    steering: 0,
                    throttle: 0,
                    brake: 0,
                    boost: false
                };
                
                // Asset loading
                this.assets = {
                    models: {},
                    sounds: {},
                    textures: {}
                };
                
                // WebRTC
                this.peer = null;
                this.connections = {};
                this.roomCode = '';
                
                // Game variables
                this.playerCount = 0;
                this.maxProducts = 15;
                this.roadLength = 1000;
                this.currentSegment = 0;
                
                // Start initialization
                this.init();
            }

            bindUIElements() {
                // Screens
                this.uiElements.loadingScreen = document.getElementById('loadingScreen');
                this.uiElements.startMenu = document.getElementById('startMenu');
                this.uiElements.multiplayerLobby = document.getElementById('multiplayerLobby');
                this.uiElements.hud = document.getElementById('hud');
                this.uiElements.pauseMenu = document.getElementById('pauseMenu');
                this.uiElements.endScreen = document.getElementById('endScreen');
                
                // Buttons
                this.uiElements.playSolo = document.getElementById('playSolo');
                this.uiElements.multiplayer = document.getElementById('multiplayer');
                this.uiElements.createRoom = document.getElementById('createRoom');
                this.uiElements.joinRoom = document.getElementById('joinRoom');
                this.uiElements.backToMenu = document.getElementById('backToMenu');
                this.uiElements.startGame = document.getElementById('startGame');
                this.uiElements.connectToRoom = document.getElementById('connectToRoom');
                this.uiElements.resumeGame = document.getElementById('resumeGame');
                this.uiElements.restartGame = document.getElementById('restartGame');
                this.uiElements.quitToMenu = document.getElementById('quitToMenu');
                this.uiElements.playAgain = document.getElementById('playAgain');
                this.uiElements.endToMenu = document.getElementById('endToMenu');
                
                // Inputs
                this.uiElements.botCount = document.getElementById('botCount');
                this.uiElements.botCountDisplay = document.getElementById('botCountDisplay');
                this.uiElements.roomCode = document.getElementById('roomCode');
                this.uiElements.roomCodeInput = document.getElementById('roomCodeInput');
                this.uiElements.roomCodeSection = document.getElementById('roomCodeSection');
                this.uiElements.joinSection = document.getElementById('joinSection');
                this.uiElements.playerListItems = document.getElementById('playerListItems');
                
                // HUD
                this.uiElements.speedValue = document.getElementById('speedValue');
                this.uiElements.productCount = document.getElementById('productCount');
                this.uiElements.profitValue = document.getElementById('profitValue');
                this.uiElements.distanceValue = document.getElementById('distanceValue');
                this.uiElements.productsGrid = document.getElementById('productsGrid');
                this.uiElements.speedNeedle = document.getElementById('speedNeedle');
                
                // End screen
                this.uiElements.endTitle = document.getElementById('endTitle');
                this.uiElements.finalProfit = document.getElementById('finalProfit');
                this.uiElements.deliveredCount = document.getElementById('deliveredCount');
                this.uiElements.totalDistance = document.getElementById('totalDistance');
            }

            async init() {
                // Initialize Three.js
                this.initThreeJS();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Load assets
                await this.loadAssets();
                
                // Generate initial road
                this.generateRoad();
                
                // Start game loop
                this.gameLoop();
                
                // Show start menu
                this.showScreen('startMenu');
            }

            initThreeJS() {
                const canvas = document.getElementById('gameCanvas');
                
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x1a1a2e, 10, 100);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupEventListeners() {
                // Keyboard input
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    // Handle pause
                    if (e.key === 'Escape') {
                        this.togglePause();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Gamepad input
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad.id);
                    this.gamepads[e.gamepad.index] = e.gamepad;
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Gamepad disconnected:', e.gamepad.id);
                    delete this.gamepads[e.gamepad.index];
                });
                
                // UI Button events
                this.uiElements.playSolo.addEventListener('click', () => this.startSoloGame());
                this.uiElements.multiplayer.addEventListener('click', () => this.showScreen('multiplayerLobby'));
                this.uiElements.createRoom.addEventListener('click', () => this.createMultiplayerRoom());
                this.uiElements.joinRoom.addEventListener('click', () => this.showJoinSection());
                this.uiElements.backToMenu.addEventListener('click', () => this.showScreen('startMenu'));
                this.uiElements.startGame.addEventListener('click', () => this.startMultiplayerGame());
                this.uiElements.connectToRoom.addEventListener('click', () => this.joinMultiplayerRoom());
                this.uiElements.resumeGame.addEventListener('click', () => this.togglePause());
                this.uiElements.restartGame.addEventListener('click', () => this.restartGame());
                this.uiElements.quitToMenu.addEventListener('click', () => this.quitToMenu());
                this.uiElements.playAgain.addEventListener('click', () => this.restartGame());
                this.uiElements.endToMenu.addEventListener('click', () => this.quitToMenu());
                
                // Bot count slider
                this.uiElements.botCount.addEventListener('input', (e) => {
                    this.botCount = parseInt(e.target.value);
                    this.uiElements.botCountDisplay.textContent = this.botCount;
                });
            }

            async loadAssets() {
                // In a real implementation, you would load actual .glb files
                // For this demo, we'll create placeholder geometries
                
                const loaders = [
                    this.createPlaceholderModel('cart'),
                    this.createPlaceholderModel('player'),
                    this.createPlaceholderModel('crate'),
                    this.createPlaceholderModel('lamp'),
                    this.createPlaceholderModel('house')
                ];
                
                await Promise.all(loaders);
                
                // Create placeholder sounds
                this.createPlaceholderSounds();
                
                // Update loading progress
                this.updateLoadingProgress(100);
                setTimeout(() => this.showScreen('startMenu'), 500);
            }

            createPlaceholderModel(type) {
                return new Promise((resolve) => {
                    let geometry, material, mesh;
                    
                    switch(type) {
                        case 'cart':
                            geometry = new THREE.BoxGeometry(2, 1, 3);
                            material = new THREE.MeshStandardMaterial({ 
                                color: 0xff4757,
                                metalness: 0.3,
                                roughness: 0.4
                            });
                            mesh = new THREE.Mesh(geometry, material);
                            mesh.castShadow = true;
                            this.assets.models.cart = { scene: mesh };
                            break;
                            
                        case 'player':
                            geometry = new THREE.BoxGeometry(0.8, 1.5, 0.8);
                            material = new THREE.MeshStandardMaterial({ 
                                color: 0x70a1ff,
                                metalness: 0.2,
                                roughness: 0.6
                            });
                            mesh = new THREE.Mesh(geometry, material);
                            mesh.castShadow = true;
                            this.assets.models.player = { scene: mesh };
                            break;
                            
                        case 'crate':
                            geometry = new THREE.BoxGeometry(1, 1, 1);
                            material = new THREE.MeshStandardMaterial({ 
                                color: 0x2ed573,
                                metalness: 0.1,
                                roughness: 0.8
                            });
                            mesh = new THREE.Mesh(geometry, material);
                            mesh.castShadow = true;
                            this.assets.models.crate = { scene: mesh };
                            break;
                            
                        case 'lamp':
                            geometry = new THREE.CylinderGeometry(0.1, 0.2, 3);
                            const topGeometry = new THREE.SphereGeometry(0.3);
                            const lamp = new THREE.Group();
                            
                            const pole = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ 
                                color: 0xcccccc,
                                metalness: 0.8
                            }));
                            
                            const top = new THREE.Mesh(topGeometry, new THREE.MeshStandardMaterial({ 
                                color: 0xffdd59,
                                emissive: 0xffdd59,
                                emissiveIntensity: 0.5
                            }));
                            top.position.y = 1.8;
                            
                            lamp.add(pole);
                            lamp.add(top);
                            this.assets.models.lamp = { scene: lamp };
                            break;
                            
                        case 'house':
                            geometry = new THREE.BoxGeometry(5, 3, 5);
                            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4);
                            
                            const house = new THREE.Group();
                            
                            const base = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ 
                                color: 0x3742fa,
                                metalness: 0.1,
                                roughness: 0.7
                            }));
                            
                            const roof = new THREE.Mesh(roofGeometry, new THREE.MeshStandardMaterial({ 
                                color: 0xff6b6b,
                                metalness: 0.2,
                                roughness: 0.8
                            }));
                            roof.position.y = 2.5;
                            roof.rotation.y = Math.PI / 4;
                            
                            house.add(base);
                            house.add(roof);
                            this.assets.models.house = { scene: house };
                            break;
                    }
                    
                    setTimeout(resolve, 100); // Simulate loading delay
                });
            }

            createPlaceholderSounds() {
                // Create placeholder audio contexts
                this.assets.sounds = {
                    crash: { play: () => this.playSoundEffect(200, 0.3, 0.2) },
                    slap: { play: () => this.playSoundEffect(150, 0.2, 0.1) },
                    product_destroyed: { play: () => this.playSoundEffect(100, 0.4, 0.3) }
                };
            }

            playSoundEffect(frequency, duration, volume) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }

            updateLoadingProgress(percent) {
                const progressBar = document.getElementById('loadingProgress');
                const loadingText = document.getElementById('loadingText');
                
                progressBar.style.width = percent + '%';
                
                if (percent < 33) {
                    loadingText.textContent = 'Loading 3D models...';
                } else if (percent < 66) {
                    loadingText.textContent = 'Loading textures...';
                } else if (percent < 100) {
                    loadingText.textContent = 'Initializing game world...';
                } else {
                    loadingText.textContent = 'Ready to play!';
                }
            }

            showScreen(screenName) {
                // Hide all screens
                Object.values(this.uiElements).forEach(element => {
                    if (element.classList?.contains('screen')) {
                        element.classList.add('hidden');
                    }
                });
                
                // Show requested screen
                if (this.uiElements[screenName]) {
                    this.uiElements[screenName].classList.remove('hidden');
                }
                
                // Update game state
                switch(screenName) {
                    case 'startMenu':
                        this.gameState = 'MENU';
                        break;
                    case 'multiplayerLobby':
                        this.gameState = 'LOBBY';
                        break;
                    case 'playing':
                        this.gameState = 'PLAYING';
                        this.uiElements.hud.classList.remove('hidden');
                        this.uiElements.speedometer.classList.remove('hidden');
                        break;
                    case 'pauseMenu':
                        this.gameState = 'PAUSED';
                        break;
                    case 'endScreen':
                        this.gameState = 'ENDED';
                        break;
                }
            }

            generateRoad() {
                // Clear existing road
                this.roadSegments.forEach(segment => this.scene.remove(segment));
                this.roadSegments = [];
                
                // Create road segments
                const roadWidth = 8;
                const segmentLength = 50;
                const segmentCount = 20; // Semi-endless - we'll recycle segments
                
                for (let i = 0; i < segmentCount; i++) {
                    const geometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0x333333,
                        side: THREE.DoubleSide
                    });
                    
                    const road = new THREE.Mesh(geometry, material);
                    road.rotation.x = -Math.PI / 2;
                    road.position.z = -i * segmentLength;
                    road.receiveShadow = true;
                    
                    this.scene.add(road);
                    this.roadSegments.push(road);
                    
                    // Add road markings
                    this.addRoadMarkings(road.position.z, roadWidth, segmentLength);
                    
                    // Randomly add obstacles
                    if (i > 2 && Math.random() > 0.5) {
                        this.addObstacles(road.position.z, roadWidth, segmentLength);
                    }
                }
            }

            addRoadMarkings(zPos, roadWidth, segmentLength) {
                // Center line
                const lineGeometry = new THREE.PlaneGeometry(0.2, segmentLength);
                const lineMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                
                const centerLine = new THREE.Mesh(lineGeometry, lineMaterial);
                centerLine.rotation.x = -Math.PI / 2;
                centerLine.position.set(0, 0.01, zPos);
                this.scene.add(centerLine);
                
                // Side lines
                const sideLine = new THREE.Mesh(lineGeometry.clone(), lineMaterial);
                sideLine.rotation.x = -Math.PI / 2;
                sideLine.position.set(-roadWidth/2, 0.01, zPos);
                this.scene.add(sideLine);
                
                const sideLine2 = sideLine.clone();
                sideLine2.position.set(roadWidth/2, 0.01, zPos);
                this.scene.add(sideLine2);
            }

            addObstacles(zPos, roadWidth, segmentLength) {
                const obstacleTypes = ['crate', 'lamp', 'house'];
                const obstacleCount = Math.floor(Math.random() * 3) + 1;
                
                for (let i = 0; i < obstacleCount; i++) {
                    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    const obstacle = this.assets.models[type].scene.clone();
                    
                    // Position obstacle on sides of road
                    const side = Math.random() > 0.5 ? 1 : -1;
                    const xPos = (roadWidth/2 + 2) * side;
                    const zOffset = (Math.random() - 0.5) * segmentLength * 0.8;
                    
                    obstacle.position.set(xPos, type === 'crate' ? 0.5 : 0, zPos + zOffset);
                    obstacle.scale.setScalar(1);
                    
                    if (type === 'house') {
                        obstacle.scale.setScalar(0.5);
                        obstacle.position.y = 1.5;
                    }
                    
                    // Add physics properties
                    obstacle.userData = {
                        type: type,
                        damage: type === 'crate' ? 20 : type === 'lamp' ? 10 : 30
                    };
                    
                    this.scene.add(obstacle);
                    this.obstacles.push(obstacle);
                }
            }

            startSoloGame() {
                this.isMultiplayer = false;
                this.playerCount = 1;
                
                // Create player
                this.createPlayer(0, false);
                
                // Create bots
                for (let i = 0; i < this.botCount; i++) {
                    this.createBot(i);
                }
                
                // Start game
                this.startGame();
            }

            createMultiplayerRoom() {
                // Generate room code
                this.roomCode = Math.random().toString(36).substring(2, 6).toUpperCase();
                this.uiElements.roomCode.textContent = this.roomCode;
                
                // Show room code section
                this.uiElements.roomCodeSection.classList.remove('hidden');
                
                // Initialize WebRTC
                this.initWebRTC(true);
            }

            showJoinSection() {
                this.uiElements.joinSection.classList.remove('hidden');
            }

            joinMultiplayerRoom() {
                const code = this.uiElements.roomCodeInput.value.toUpperCase();
                if (code.length === 4) {
                    this.roomCode = code;
                    this.uiElements.roomCode.textContent = code;
                    this.uiElements.roomCodeSection.classList.remove('hidden');
                    this.uiElements.joinSection.classList.add('hidden');
                    
                    // Initialize WebRTC as client
                    this.initWebRTC(false);
                }
            }

            initWebRTC(isHost) {
                // Placeholder for WebRTC implementation
                // In a real implementation, you would use PeerJS or simple-peer
                console.log(isHost ? 'Creating room' : 'Joining room', this.roomCode);
                
                // For demo purposes, we'll simulate multiplayer with bots
                if (isHost) {
                    // Host creates player
                    this.createPlayer(0, true);
                    
                    // Update player list
                    this.updatePlayerList();
                }
            }

            updatePlayerList() {
                this.uiElements.playerListItems.innerHTML = '';
                
                // Add host
                const hostItem = document.createElement('li');
                hostItem.innerHTML = `
                    <div class="player-color" style="background: #ff4757;"></div>
                    <span>Host (You)</span>
                `;
                this.uiElements.playerListItems.appendChild(hostItem);
            }

            startMultiplayerGame() {
                this.isMultiplayer = true;
                this.startGame();
            }

            startGame() {
                // Reset game state
                this.currentSegment = 0;
                
                // Show game HUD
                this.showScreen('playing');
                
                // Initialize products display
                this.updateProductsDisplay();
                
                // Focus canvas for keyboard input
                document.getElementById('gameCanvas').focus();
            }

            createPlayer(id, isMultiplayer) {
                const cart = this.assets.models.cart.scene.clone();
                const player = this.assets.models.player.scene.clone();
                
                // Position player in cart
                player.position.y = 1;
                cart.add(player);
                
                // Set initial position
                cart.position.set(id * 3, 0.5, 0);
                cart.rotation.y = Math.PI;
                
                // Add to scene
                this.scene.add(cart);
                
                // Store player data
                const playerData = {
                    id: id,
                    cart: cart,
                    player: player,
                    speed: 0,
                    maxSpeed: 30,
                    acceleration: 0.5,
                    steering: 0.05,
                    health: 100,
                    products: this.maxProducts,
                    profit: 0,
                    distance: 0,
                    isBot: false,
                    isMultiplayer: isMultiplayer
                };
                
                this.carts.push(cart);
                this.players.push(playerData);
                
                return playerData;
            }

            createBot(id) {
                const playerData = this.createPlayer(id + 1, false);
                playerData.isBot = true;
                playerData.cart.material.color.setHex(0xff6b6b);
                this.bots.push(playerData);
            }

            processInput() {
                // Reset input
                this.input.steering = 0;
                this.input.throttle = 0;
                this.input.brake = 0;
                this.input.boost = false;
                
                // Keyboard input
                if (this.keys['w'] || this.keys['arrowup']) this.input.throttle = 1;
                if (this.keys['s'] || this.keys['arrowdown']) this.input.brake = 1;
                if (this.keys['a'] || this.keys['arrowleft']) this.input.steering = 1;
                if (this.keys['d'] || this.keys['arrowright']) this.input.steering = -1;
                if (this.keys[' ']) this.input.boost = true;
                
                // Gamepad input
                for (const index in this.gamepads) {
                    const gamepad = this.gamepads[index];
                    
                    // Left stick for steering
                    if (Math.abs(gamepad.axes[0]) > 0.1) {
                        this.input.steering = -gamepad.axes[0];
                    }
                    
                    // Right trigger for throttle
                    if (gamepad.buttons[7]) {
                        this.input.throttle = gamepad.buttons[7].value;
                    }
                    
                    // Left trigger for brake
                    if (gamepad.buttons[6]) {
                        this.input.brake = gamepad.buttons[6].value;
                    }
                    
                    // A button for boost
                    if (gamepad.buttons[0]?.pressed) {
                        this.input.boost = true;
                    }
                }
            }

            updatePlayer(player, deltaTime) {
                if (!player) return;
                
                // Player input
                if (!player.isBot) {
                    // Apply input to player
                    const acceleration = this.input.acceleration || 0.5;
                    const steering = this.input.steering || 0;
                    const throttle = this.input.throttle || 0;
                    const brake = this.input.brake || 0;
                    const boost = this.input.boost || false;
                    
                    // Calculate speed
                    if (throttle > 0 && player.speed < player.maxSpeed) {
                        player.speed += acceleration * throttle * deltaTime;
                        if (boost) player.speed *= 1.5;
                    }
                    
                    if (brake > 0 && player.speed > -player.maxSpeed * 0.5) {
                        player.speed -= acceleration * 1.5 * brake * deltaTime;
                    }
                    
                    // Apply friction
                    if (throttle === 0 && brake === 0) {
                        player.speed *= 0.98;
                    }
                    
                    // Apply steering
                    if (Math.abs(player.speed) > 1) {
                        player.cart.rotation.y += steering * player.steering * (player.speed / player.maxSpeed) * deltaTime * 60;
                    }
                    
                    // Move cart
                    const direction = new THREE.Vector3(0, 0, 1);
                    direction.applyQuaternion(player.cart.quaternion);
                    player.cart.position.add(direction.multiplyScalar(player.speed * deltaTime));
                    
                    // Update distance
                    player.distance += Math.abs(player.speed) * deltaTime;
                    
                    // Keep cart on ground
                    player.cart.position.y = 0.5;
                    
                    // Update camera to follow player
                    if (this.players[0] === player) {
                        this.updateCamera(player);
                    }
                    
                    // Update HUD
                    this.updateHUD(player);
                } else {
                    // Bot AI
                    this.updateBotAI(player, deltaTime);
                }
                
                // Check collisions
                this.checkCollisions(player);
                
                // Update road segments (semi-endless)
                this.updateRoadSegments(player);
            }

            updateBotAI(bot, deltaTime) {
                // Simple bot AI: chase nearest player
                let targetPlayer = this.players.find(p => !p.isBot);
                
                if (targetPlayer) {
                    // Calculate direction to target
                    const direction = new THREE.Vector3()
                        .subVectors(targetPlayer.cart.position, bot.cart.position)
                        .normalize();
                    
                    // Calculate angle difference
                    const botForward = new THREE.Vector3(0, 0, 1).applyQuaternion(bot.cart.quaternion);
                    const angle = botForward.angleTo(direction);
                    
                    // Steer towards target
                    const cross = new THREE.Vector3().crossVectors(botForward, direction);
                    const steerDirection = cross.y > 0 ? 1 : -1;
                    
                    // Apply steering with some randomness for "funny behavior"
                    const randomFactor = 0.3 + Math.random() * 0.4;
                    bot.cart.rotation.y += steerDirection * bot.steering * randomFactor * deltaTime * 60;
                    
                    // Accelerate
                    if (bot.speed < bot.maxSpeed * 0.8) {
                        bot.speed += bot.acceleration * deltaTime;
                    }
                    
                    // Random boost
                    if (Math.random() > 0.9) {
                        bot.speed *= 1.3;
                    }
                    
                    // Random mistakes
                    if (Math.random() > 0.98) {
                        bot.cart.rotation.y += (Math.random() - 0.5) * 2;
                    }
                }
                
                // Move bot
                const direction = new THREE.Vector3(0, 0, 1);
                direction.applyQuaternion(bot.cart.quaternion);
                bot.cart.position.add(direction.multiplyScalar(bot.speed * deltaTime));
                bot.cart.position.y = 0.5;
                
                // Update distance
                bot.distance += Math.abs(bot.speed) * deltaTime;
            }

            updateCamera(player) {
                if (!player) return;
                
                // Third-person camera behind cart
                const cameraOffset = new THREE.Vector3(0, 3, 8);
                cameraOffset.applyQuaternion(player.cart.quaternion);
                
                const targetPosition = player.cart.position.clone().add(cameraOffset);
                const lookAtPosition = player.cart.position.clone();
                lookAtPosition.y += 1;
                
                // Smooth camera movement
                this.camera.position.lerp(targetPosition, 0.1);
                this.camera.lookAt(lookAtPosition);
                
                // Camera shake on collisions (simplified)
                if (player.health < 100) {
                    this.camera.position.x += (Math.random() - 0.5) * 0.1;
                    this.camera.position.y += (Math.random() - 0.5) * 0.1;
                }
            }

            updateHUD(player) {
                // Speed
                const speedKmh = Math.abs(player.speed * 3.6);
                this.uiElements.speedValue.textContent = `${speedKmh.toFixed(0)} km/h`;
                
                // Update speedometer needle
                const maxSpeed = 100;
                const angle = (speedKmh / maxSpeed) * Math.PI - Math.PI / 2;
                this.uiElements.speedNeedle.style.transform = `translateX(-50%) rotate(${angle}rad)`;
                
                // Products
                this.uiElements.productCount.textContent = `${player.products}/${this.maxProducts}`;
                
                // Profit
                this.uiElements.profitValue.textContent = `$${player.profit}`;
                
                // Distance to goal
                const remainingDistance = Math.max(0, this.roadLength - player.distance);
                this.uiElements.distanceValue.textContent = `${remainingDistance.toFixed(0)}m`;
                
                // Check win condition
                if (remainingDistance <= 0) {
                    this.endGame(player, true);
                }
            }

            updateProductsDisplay() {
                this.uiElements.productsGrid.innerHTML = '';
                
                for (let i = 0; i < this.maxProducts; i++) {
                    const product = document.createElement('div');
                    product.className = 'product-item';
                    product.textContent = '';
                    product.dataset.index = i;
                    this.uiElements.productsGrid.appendChild(product);
                }
            }

            checkCollisions(player) {
                if (!player) return;
                
                // Check obstacle collisions
                for (const obstacle of this.obstacles) {
                    if (!obstacle.userData) continue;
                    
                    const distance = player.cart.position.distanceTo(obstacle.position);
                    const collisionDistance = 2;
                    
                    if (distance < collisionDistance) {
                        // Collision detected
                        this.handleCollision(player, obstacle);
                    }
                }
                
                // Check bot collisions
                for (const bot of this.bots) {
                    if (bot === player) continue;
                    
                    const distance = player.cart.position.distanceTo(bot.cart.position);
                    const collisionDistance = 1.5;
                    
                    if (distance < collisionDistance) {
                        // Bot hit player
                        this.handleBotCollision(player, bot);
                    }
                }
                
                // Check road boundaries
                const roadHalfWidth = 4;
                if (Math.abs(player.cart.position.x) > roadHalfWidth) {
                    // Off road - damage products
                    player.products = Math.max(0, player.products - 1);
                    player.health -= 5;
                    
                    if (player.products === 0) {
                        this.endGame(player, false);
                    }
                    
                    // Play sound
                    this.assets.sounds.product_destroyed.play();
                    
                    // Update products display
                    this.updateProductDamageDisplay(player);
                }
            }

            handleCollision(player, obstacle) {
                // Reduce health and products
                const damage = obstacle.userData.damage || 10;
                player.health -= damage;
                player.products = Math.max(0, player.products - 1);
                player.profit = Math.max(0, player.profit - 10);
                
                // Play collision sound
                if (obstacle.userData.type === 'crate') {
                    this.assets.sounds.crash.play();
                } else if (obstacle.userData.type === 'lamp') {
                    this.assets.sounds.slap.play();
                }
                
                // Bounce effect
                const bounceDirection = new THREE.Vector3()
                    .subVectors(player.cart.position, obstacle.position)
                    .normalize();
                
                player.cart.position.add(bounceDirection.multiplyScalar(2));
                player.speed *= -0.5;
                
                // Update products display
                this.updateProductDamageDisplay(player);
                
                // Check game over
                if (player.health <= 0 || player.products === 0) {
                    this.endGame(player, false);
                }
            }

            handleBotCollision(player, bot) {
                // Reduce products when hit by bot
                player.products = Math.max(0, player.products - 1);
                player.profit = Math.max(0, player.profit - 5);
                
                // Play sound
                this.assets.sounds.slap.play();
                
                // Push player
                const pushDirection = new THREE.Vector3()
                    .subVectors(player.cart.position, bot.cart.position)
                    .normalize();
                
                player.cart.position.add(pushDirection.multiplyScalar(1.5));
                
                // Update products display
                this.updateProductDamageDisplay(player);
                
                if (player.products === 0) {
                    this.endGame(player, false);
                }
            }

            updateProductDamageDisplay(player) {
                const products = this.uiElements.productsGrid.querySelectorAll('.product-item');
                products.forEach((product, index) => {
                    if (index >= player.products) {
                        product.classList.add('damaged');
                    } else {
                        product.classList.remove('damaged');
                    }
                });
            }

            updateRoadSegments(player) {
                if (!player) return;
                
                // Check if player has moved past a segment
                const segmentLength = 50;
                const segmentIndex = Math.floor(-player.cart.position.z / segmentLength);
                
                if (segmentIndex > this.currentSegment) {
                    this.currentSegment = segmentIndex;
                    
                    // Move oldest segment to the front
                    const oldestSegment = this.roadSegments.shift();
                    oldestSegment.position.z = -(segmentIndex + this.roadSegments.length) * segmentLength;
                    this.roadSegments.push(oldestSegment);
                    
                    // Clear old obstacles
                    const obstaclesToRemove = this.obstacles.filter(
                        obs => obs.position.z > player.cart.position.z + 100
                    );
                    
                    obstaclesToRemove.forEach(obs => {
                        this.scene.remove(obs);
                        const index = this.obstacles.indexOf(obs);
                        if (index > -1) this.obstacles.splice(index, 1);
                    });
                    
                    // Add new obstacles to the new segment
                    this.addObstacles(oldestSegment.position.z, 8, segmentLength);
                }
            }

            togglePause() {
                if (this.gameState === 'PLAYING') {
                    this.gameState = 'PAUSED';
                    this.showScreen('pauseMenu');
                } else if (this.gameState === 'PAUSED') {
                    this.gameState = 'PLAYING';
                    this.showScreen('playing');
                }
            }

            endGame(player, won) {
                this.gameState = 'ENDED';
                
                // Update end screen
                this.uiElements.endTitle.textContent = won ? 'Delivery Complete!' : 'Delivery Failed!';
                this.uiElements.endTitle.style.color = won ? '#2ed573' : '#ff4757';
                
                this.uiElements.finalProfit.textContent = `$${player.profit}`;
                this.uiElements.deliveredCount.textContent = `${player.products}/${this.maxProducts}`;
                this.uiElements.totalDistance.textContent = `${player.distance.toFixed(0)}m`;
                
                this.showScreen('endScreen');
            }

            restartGame() {
                // Clear all game objects
                this.players.forEach(player => {
                    this.scene.remove(player.cart);
                });
                
                this.bots.forEach(bot => {
                    this.scene.remove(bot.cart);
                });
                
                this.obstacles.forEach(obstacle => {
                    this.scene.remove(obstacle);
                });
                
                // Reset arrays
                this.players = [];
                this.bots = [];
                this.obstacles = [];
                this.carts = [];
                
                // Restart based on previous mode
                if (this.isMultiplayer) {
                    this.showScreen('multiplayerLobby');
                } else {
                    this.startSoloGame();
                }
            }

            quitToMenu() {
                // Clear game objects
                this.players.forEach(player => {
                    this.scene.remove(player.cart);
                });
                
                this.bots.forEach(bot => {
                    this.scene.remove(bot.cart);
                });
                
                this.obstacles.forEach(obstacle => {
                    this.scene.remove(obstacle);
                });
                
                // Reset arrays
                this.players = [];
                this.bots = [];
                this.obstacles = [];
                this.carts = [];
                
                // Show main menu
                this.showScreen('startMenu');
            }

            gameLoop() {
                const deltaTime = 1/60; // Fixed time step for simplicity
                
                // Process input
                this.processInput();
                
                // Update game state if playing
                if (this.gameState === 'PLAYING') {
                    // Update all players
                    this.players.forEach(player => {
                        this.updatePlayer(player, deltaTime);
                    });
                    
                    // Update all bots
                    this.bots.forEach(bot => {
                        this.updatePlayer(bot, deltaTime);
                    });
                }
                
                // Render
                this.renderer.render(this.scene, this.camera);
                
                // Continue loop
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            window.game = new CartRidersGame();
        });
    </script>
</body>
</html>
