<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cell Block Zero - Professional Prison Escape</title>
    
    <!-- Load Three.js with essential modules -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
            user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        /* UI Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #0a0a2a 0%, #000 100%);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }

        #lobbyScreen {
            display: flex;
        }

        #gameScreen {
            display: none;
        }

        #solitaryScreen {
            display: none;
        }

        /* Lobby UI */
        .ui-box {
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(10, 10, 30, 0.95));
            border: 2px solid #4a90e2;
            border-radius: 10px;
            padding: 40px;
            max-width: 800px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 50px rgba(74, 144, 226, 0.5);
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #ff4444;
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            letter-spacing: 3px;
            font-weight: 900;
            text-transform: uppercase;
        }

        h2 {
            color: #4a90e2;
            margin: 20px 0;
            font-size: 2em;
            text-shadow: 0 0 10px #4a90e2;
        }

        .subtitle {
            color: #aaa;
            font-size: 1.2em;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        button {
            background: linear-gradient(to bottom, #4a90e2, #2a70c2);
            color: white;
            border: none;
            padding: 18px 36px;
            margin: 15px;
            font-size: 1.3em;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.4);
        }

        button:hover {
            background: linear-gradient(to bottom, #5aa0f2, #3a80d2);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(74, 144, 226, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input {
            background: rgba(20, 20, 40, 0.8);
            color: white;
            border: 2px solid #4a90e2;
            padding: 15px;
            margin: 15px;
            border-radius: 8px;
            font-size: 1.2em;
            width: 300px;
            text-align: center;
        }

        input:focus {
            outline: none;
            border-color: #ff4444;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
        }

        /* Connection Status */
        #connectionStatus {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.1em;
            backdrop-filter: blur(5px);
        }

        .status-connected { border-color: #00ff00; color: #00ff00; }
        .status-connecting { border-color: #ffcc00; color: #ffcc00; }
        .status-disconnected { border-color: #ff4444; color: #ff4444; }

        /* Game UI */
        #gameUI {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 30px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            gap: 20px;
        }

        .player-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            padding: 20px;
            min-width: 280px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .player1-panel { border-color: #ff4444; }
        .player2-panel { border-color: #4a90e2; }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .player-name {
            font-size: 1.4em;
            font-weight: bold;
        }

        .player-id {
            color: #aaa;
            font-size: 0.9em;
        }

        .stat-bar {
            margin: 10px 0;
        }

        .stat-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .bar-container {
            height: 20px;
            background: rgba(50, 50, 50, 0.8);
            border-radius: 10px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s;
        }

        .health-bar { background: linear-gradient(to right, #ff4444, #ff8800); }
        .stamina-bar { background: linear-gradient(to right, #00aa00, #00ff00); }

        /* Inventory */
        #inventoryPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffcc00;
            padding: 20px;
            border-radius: 10px;
            display: none;
            min-width: 250px;
            backdrop-filter: blur(10px);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .inventory-slot {
            width: 60px;
            height: 60px;
            background: rgba(30, 30, 50, 0.8);
            border: 2px solid #666;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s;
        }

        .inventory-slot.filled {
            border-color: #ffcc00;
            background: rgba(50, 40, 20, 0.8);
        }

        /* Objective Display */
        #objectiveDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff4444;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            display: none;
            backdrop-filter: blur(20px);
        }

        /* Chat System */
        #chatPanel {
            position: absolute;
            bottom: 150px;
            left: 30px;
            width: 400px;
            max-height: 300px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #4a90e2;
            border-radius: 10px;
            padding: 15px;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        #chatMessages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(20, 20, 40, 0.5);
            border-radius: 8px;
            max-height: 200px;
        }

        .chat-message {
            margin: 5px 0;
            padding: 8px;
            border-radius: 5px;
            word-break: break-word;
        }

        .chat-message.you {
            background: rgba(74, 144, 226, 0.3);
            border-left: 3px solid #4a90e2;
        }

        .chat-message.partner {
            background: rgba(255, 68, 68, 0.3);
            border-left: 3px solid #ff4444;
        }

        /* Escape Menu */
        #escapeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff4444;
            padding: 40px;
            border-radius: 15px;
            display: none;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            min-width: 800px;
            backdrop-filter: blur(20px);
        }

        .escape-card {
            background: rgba(20, 20, 40, 0.8);
            border: 2px solid #4a90e2;
            padding: 25px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .escape-card:hover {
            transform: translateY(-5px);
            border-color: #ffcc00;
            box-shadow: 0 10px 25px rgba(255, 204, 0, 0.3);
        }

        .escape-card.available {
            border-color: #00ff00;
            background: rgba(20, 40, 20, 0.8);
        }

        .escape-card.unavailable {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .escape-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        /* Solitary Screen */
        #solitaryAnimation {
            width: 100%;
            height: 300px;
            background: #111;
            border: 3px solid #444;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
            border-radius: 10px;
        }

        /* Controls Help */
        #controlsHelp {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #666;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        /* Loading Screen */
        .loader {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(74, 144, 226, 0.3);
            border-radius: 50%;
            border-top-color: #4a90e2;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }

        .crosshair-dot {
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 7px;
            left: 7px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .crosshair-line {
            position: absolute;
            background: #fff;
        }

        .crosshair-horizontal {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }

        .crosshair-vertical {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }

        /* Notification */
        .notification {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid;
            padding: 20px 40px;
            border-radius: 10px;
            display: none;
            z-index: 1001;
            text-align: center;
            min-width: 300px;
            backdrop-filter: blur(10px);
        }

        .notification.success { border-color: #00ff00; color: #00ff00; }
        .notification.warning { border-color: #ffcc00; color: #ffcc00; }
        .notification.error { border-color: #ff4444; color: #ff4444; }
        .notification.info { border-color: #4a90e2; color: #4a90e2; }

        /* Responsive */
        @media (max-width: 1024px) {
            .ui-box { padding: 20px; }
            h1 { font-size: 2.5em; }
            #escapeMenu { 
                grid-template-columns: 1fr; 
                min-width: 90%;
                padding: 20px;
            }
            #gameUI { flex-direction: column; }
            .player-panel { min-width: auto; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Crosshair -->
        <div id="crosshair">
            <div class="crosshair-dot"></div>
            <div class="crosshair-line crosshair-horizontal"></div>
            <div class="crosshair-line crosshair-vertical"></div>
        </div>

        <!-- Lobby Screen -->
        <div id="lobbyScreen" class="screen">
            <div class="ui-box">
                <h1>CELL BLOCK ZERO</h1>
                <h2>Maximum Security Prison Escape</h2>
                <p class="subtitle">Work with a partner to plan and execute the ultimate prison escape. Use stealth, strategy, and cooperation to outsmart the guards.</p>
                
                <div id="connectionStatus" class="status-disconnected">Status: Offline</div>
                
                <div style="margin: 40px 0;">
                    <button onclick="hostGame()" id="hostBtn">CREATE ROOM</button>
                    <button onclick="showJoinSection()" id="joinBtn">JOIN ROOM</button>
                    <button onclick="showTutorial()" id="tutorialBtn">TUTORIAL</button>
                </div>
                
                <!-- Join Section -->
                <div id="joinSection" style="display: none; margin: 30px 0;">
                    <input type="text" id="roomCodeInput" placeholder="Enter 6-digit room code" maxlength="6">
                    <button onclick="joinGame()">CONNECT</button>
                    <button onclick="hideJoinSection()">CANCEL</button>
                </div>
                
                <!-- Room Info (Host) -->
                <div id="roomInfo" style="display: none; margin: 30px 0;">
                    <h3>Room Created</h3>
                    <p style="font-size: 1.5em; letter-spacing: 10px; margin: 20px 0;" id="roomCodeDisplay">000000</p>
                    <p>Share this code with your partner</p>
                    <div style="margin: 20px 0;">
                        <button onclick="copyRoomCode()">Copy Code</button>
                        <button onclick="startGame()" id="startBtn" disabled>START GAME</button>
                        <button onclick="cancelHosting()">CANCEL</button>
                    </div>
                    <p id="playerCount">Waiting for players...</p>
                </div>
                
                <!-- Tutorial -->
                <div id="tutorialSection" style="display: none; margin: 30px 0; text-align: left;">
                    <h3>How to Play:</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                        <div>
                            <h4>Movement</h4>
                            <p>WASD - Move</p>
                            <p>Space - Jump</p>
                            <p>Shift - Sprint</p>
                            <p>Ctrl - Crouch</p>
                            <p>Mouse - Look around</p>
                        </div>
                        <div>
                            <h4>Actions</h4>
                            <p>E - Interact/Pickup</p>
                            <p>F - Use item/Fight</p>
                            <p>Tab - Inventory</p>
                            <p>C - Chat</p>
                            <p>M - Escape menu</p>
                        </div>
                    </div>
                    <button onclick="hideTutorial()">BACK</button>
                </div>
                
                <!-- Loading Screen -->
                <div id="loadingSection" style="display: none; margin: 40px 0;">
                    <div class="loader"></div>
                    <h3 id="loadingText">Loading Prison Environment...</h3>
                    <p>Please wait while we prepare your escape</p>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="screen">
            <canvas id="gameCanvas"></canvas>
            
            <div id="connectionStatus" class="status-connected">Connected</div>
            
            <!-- Game UI -->
            <div id="gameUI">
                <div class="player-panel player1-panel">
                    <div class="player-header">
                        <div class="player-name">PLAYER 1</div>
                        <div class="player-id" id="player1Id">Host</div>
                    </div>
                    
                    <div class="stat-bar">
                        <div class="stat-label">
                            <span>HEALTH</span>
                            <span id="player1Health">100%</span>
                        </div>
                        <div class="bar-container">
                            <div id="player1HealthBar" class="bar-fill health-bar" style="width: 100%"></div>
                        </div>
                    </div>
                    
                    <div class="stat-bar">
                        <div class="stat-label">
                            <span>STAMINA</span>
                            <span id="player1Stamina">100%</span>
                        </div>
                        <div class="bar-container">
                            <div id="player1StaminaBar" class="bar-fill stamina-bar" style="width: 100%"></div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                            <span>CONTABAND:</span>
                            <span id="player1Contraband">0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                            <span>REPUTATION:</span>
                            <span id="player1Reputation">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="player-panel player2-panel">
                    <div class="player-header">
                        <div class="player-name">PLAYER 2</div>
                        <div class="player-id" id="player2Id">Disconnected</div>
                    </div>
                    
                    <div class="stat-bar">
                        <div class="stat-label">
                            <span>HEALTH</span>
                            <span id="player2Health">100%</span>
                        </div>
                        <div class="bar-container">
                            <div id="player2HealthBar" class="bar-fill health-bar" style="width: 100%"></div>
                        </div>
                    </div>
                    
                    <div class="stat-bar">
                        <div class="stat-label">
                            <span>STAMINA</span>
                            <span id="player2Stamina">100%</span>
                        </div>
                        <div class="bar-container">
                            <div id="player2StaminaBar" class="bar-fill stamina-bar" style="width: 100%"></div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                            <span>CONTABAND:</span>
                            <span id="player2Contraband">0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                            <span>REPUTATION:</span>
                            <span id="player2Reputation">0</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Inventory -->
            <div id="inventoryPanel">
                <h3>INVENTORY</h3>
                <div class="inventory-grid" id="inventoryGrid"></div>
                <div style="margin-top: 20px; font-size: 0.9em; color: #aaa;">
                    <div>Space: 8/16</div>
                    <div>Weight: 12/50 kg</div>
                </div>
            </div>
            
            <!-- Escape Menu -->
            <div id="escapeMenu">
                <h2 style="grid-column: span 2; margin-bottom: 30px;">ESCAPE PLANS</h2>
                
                <div class="escape-card" onclick="selectEscapePlan('tunnel')" id="planTunnel">
                    <div class="escape-icon">üï≥Ô∏è</div>
                    <h3>TUNNEL ESCAPE</h3>
                    <p>Dig a tunnel under the prison walls</p>
                    <div style="margin-top: 15px; font-size: 0.9em;">
                        <div>‚úì Requires: Shovel</div>
                        <div>‚úì Best at: Night</div>
                        <div>‚úì Risk: High</div>
                    </div>
                </div>
                
                <div class="escape-card" onclick="selectEscapePlan('disguise')" id="planDisguise">
                    <div class="escape-icon">üëÆ</div>
                    <h3>GUARD DISGUISE</h3>
                    <p>Pose as a guard and walk out</p>
                    <div style="margin-top: 15px; font-size: 0.9em;">
                        <div>‚úì Requires: Uniform + ID</div>
                        <div>‚úì Best at: Day</div>
                        <div>‚úì Risk: Medium</div>
                    </div>
                </div>
                
                <div class="escape-card" onclick="selectEscapePlan('riot')" id="planRiot">
                    <div class="escape-icon">üî•</div>
                    <h3>RIOT CHAOS</h3>
                    <p>Start a riot and escape in confusion</p>
                    <div style="margin-top: 15px; font-size: 0.9em;">
                        <div>‚úì Requires: High Reputation</div>
                        <div>‚úì Best at: Any time</div>
                        <div>‚úì Risk: Very High</div>
                    </div>
                </div>
                
                <div class="escape-card" onclick="selectEscapePlan('parole')" id="planParole">
                    <div class="escape-icon">üìù</div>
                    <h3>LEGAL PAROLE</h3>
                    <p>Get released "legally"</p>
                    <div style="margin-top: 15px; font-size: 0.9em;">
                        <div>‚úì Requires: Clean Record</div>
                        <div>‚úì Best at: Office hours</div>
                        <div>‚úì Risk: Low</div>
                    </div>
                </div>
                
                <button onclick="hideEscapeMenu()" style="grid-column: span 2; margin-top: 20px;">BACK TO GAME</button>
            </div>
            
            <!-- Chat -->
            <div id="chatPanel">
                <div id="chatMessages"></div>
                <input type="text" id="chatInput" placeholder="Type message... (Enter to send, ESC to close)" autocomplete="off">
            </div>
            
            <!-- Objective Display -->
            <div id="objectiveDisplay">
                <h2>MISSION OBJECTIVE</h2>
                <p id="objectiveText">ESCAPE THE PRISON WITH YOUR PARTNER</p>
                <p id="objectiveDetails" style="margin: 20px 0; color: #aaa;">
                    Work together to collect items, avoid guards, and execute your escape plan.
                    Communication and coordination are key to success.
                </p>
                <button onclick="hideObjective()">BEGIN ESCAPE</button>
            </div>
            
            <!-- Controls Help -->
            <div id="controlsHelp">
                <div><strong>WASD</strong> - Move</div>
                <div><strong>E</strong> - Interact</div>
                <div><strong>TAB</strong> - Inventory</div>
                <div><strong>C</strong> - Chat</div>
                <div><strong>ESC</strong> - Menu</div>
            </div>
            
            <!-- Notification -->
            <div id="notification" class="notification"></div>
        </div>

        <!-- Solitary Screen -->
        <div id="solitaryScreen" class="screen">
            <div class="ui-box">
                <h1 style="color: #ffcc00;">üîí SOLITARY CONFINEMENT üîí</h1>
                <div id="solitaryAnimation"></div>
                <h2 id="solitaryReason">ESCAPE ATTEMPT FAILED</h2>
                <p id="solitaryMessage" style="font-size: 1.2em; margin: 20px 0; color: #aaa;">
                    The guards caught you in the act. Better luck next time!
                </p>
                <div style="margin: 40px 0;">
                    <button onclick="retryGame()">TRY AGAIN</button>
                    <button onclick="returnToLobby()">MAIN MENU</button>
                </div>
                <p style="color: #4a90e2; font-style: italic; margin-top: 20px;" id="escapeTip">
                    Tip: Try a different escape method or collect more items first.
                </p>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // GAME CONFIGURATION
        // ============================================================================
        const CONFIG = {
            // Prison Layout
            PRISON_SIZE: 200,
            WALL_HEIGHT: 10,
            WALL_THICKNESS: 2,
            
            // Building Sections
            BUILDINGS: {
                cellBlock: { width: 40, depth: 60, height: 8 },
                cafeteria: { width: 30, depth: 40, height: 6 },
                yard: { width: 80, depth: 60 },
                admin: { width: 25, depth: 25, height: 4 },
                workshop: { width: 35, depth: 30, height: 5 },
                infirmary: { width: 20, depth: 25, height: 4 }
            },
            
            // Items
            ITEMS: [
                { id: 'shovel', name: 'Shovel', icon: 'ü™ö', color: '#8B4513', weight: 5 },
                { id: 'uniform', name: 'Guard Uniform', icon: 'üëÆ', color: '#0000ff', weight: 2 },
                { id: 'idCard', name: 'ID Card', icon: 'ü™™', color: '#ffff00', weight: 0.1 },
                { id: 'crowbar', name: 'Crowbar', icon: 'üîß', color: '#808080', weight: 3 },
                { id: 'rope', name: 'Rope', icon: 'ü™¢', color: '#8B4513', weight: 2 },
                { id: 'key', name: 'Key', icon: 'üîë', color: '#ffd700', weight: 0.1 },
                { id: 'wire', name: 'Wire', icon: 'üîó', color: '#aaaaaa', weight: 0.5 },
                { id: 'food', name: 'Food', icon: 'üçé', color: '#ff4444', weight: 1 }
            ],
            
            // Escape Requirements
            ESCAPE_REQUIREMENTS: {
                tunnel: ['shovel', 'crowbar'],
                disguise: ['uniform', 'idCard'],
                riot: { reputation: 50 },
                parole: { contraband: 0, reputation: 30 }
            },
            
            // Game Balance
            PLAYER: {
                maxHealth: 100,
                maxStamina: 100,
                walkSpeed: 0.1,
                runSpeed: 0.2,
                jumpHeight: 5,
                inventorySize: 16,
                maxWeight: 50
            },
            
            // AI
            GUARDS: {
                count: 8,
                patrolSpeed: 0.05,
                chaseSpeed: 0.15,
                visionRange: 20,
                visionAngle: 60
            },
            
            // Time
            DAY_NIGHT_CYCLE: 600, // seconds
            NIGHT_START: 0.75,
            NIGHT_END: 0.25
        };

        // ============================================================================
        // GAME STATE
        // ============================================================================
        let gameState = {
            // Network
            isHost: false,
            playerId: null,
            roomCode: null,
            peer: null,
            dataChannel: null,
            connectionEstablished: false,
            connectedPlayers: new Map(),
            
            // Game World
            scene: null,
            camera: null,
            renderer: null,
            clock: new THREE.Clock(),
            
            // Player
            player: {
                mesh: null,
                health: CONFIG.PLAYER.maxHealth,
                stamina: CONFIG.PLAYER.maxStamina,
                contraband: 0,
                reputation: 0,
                inventory: [],
                position: { x: 0, y: 2, z: 0 },
                rotation: { x: 0, y: 0 }
            },
            
            // Other Players
            otherPlayers: new Map(),
            
            // World Objects
            buildings: [],
            walls: [],
            items: [],
            guards: [],
            lights: [],
            
            // Game Status
            gameStarted: false,
            escapeInProgress: false,
            timeOfDay: 0.5,
            isNight: false,
            gamePaused: false
        };

        // ============================================================================
        // SEEDED RANDOM GENERATOR
        // ============================================================================
        class SeededRandom {
            constructor(seed) {
                this.seed = seed || Date.now();
                this.current = this.seed;
            }
            
            next() {
                this.current = (this.current * 9301 + 49297) % 233280;
                return this.current / 233280;
            }
            
            random(min = 0, max = 1) {
                return min + this.next() * (max - min);
            }
            
            int(min, max) {
                return Math.floor(this.random(min, max));
            }
            
            choice(array) {
                return array[this.int(0, array.length)];
            }
        }

        let rng = new SeededRandom(Date.now());

        // ============================================================================
        // NETWORKING SYSTEM (FIXED VERSION)
        // ============================================================================
        class NetworkManager {
            constructor() {
                this.iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' }
                ];
            }

            async hostGame() {
                try {
                    gameState.isHost = true;
                    gameState.playerId = 'host_' + this.generateId();
                    gameState.roomCode = this.generateRoomCode();
                    
                    showNotification('Creating room...', 'info');
                    updateConnectionStatus('creating', 'Creating room...');
                    
                    // Create peer connection
                    gameState.peer = new RTCPeerConnection({
                        iceServers: this.iceServers,
                        iceCandidatePoolSize: 10
                    });
                    
                    // Create data channel
                    gameState.dataChannel = gameState.peer.createDataChannel('game', {
                        ordered: true,
                        maxRetransmits: 10
                    });
                    
                    this.setupDataChannel(gameState.dataChannel);
                    
                    // Handle ICE candidates
                    gameState.peer.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.storeCandidate(event.candidate, 'host');
                        }
                    };
                    
                    // Handle connection state
                    gameState.peer.onconnectionstatechange = () => {
                        console.log('Host connection state:', gameState.peer.connectionState);
                        if (gameState.peer.connectionState === 'connected') {
                            updateConnectionStatus('connected', 'Player connected!');
                            document.getElementById('startBtn').disabled = false;
                            document.getElementById('playerCount').textContent = 'Player connected! Ready to start.';
                        }
                    };
                    
                    // Create offer
                    const offer = await gameState.peer.createOffer();
                    await gameState.peer.setLocalDescription(offer);
                    
                    // Store room info
                    const roomData = {
                        sdp: gameState.peer.localDescription,
                        roomCode: gameState.roomCode,
                        playerId: gameState.playerId,
                        timestamp: Date.now(),
                        seed: Date.now()
                    };
                    
                    localStorage.setItem('hostOffer', JSON.stringify(roomData));
                    localStorage.setItem('hostCandidates', JSON.stringify([]));
                    
                    // Show room info
                    document.getElementById('roomInfo').style.display = 'block';
                    document.getElementById('roomCodeDisplay').textContent = gameState.roomCode;
                    updateConnectionStatus('waiting', `Room: ${gameState.roomCode}`);
                    
                    showNotification(`Room created: ${gameState.roomCode}`, 'success');
                    
                    // Start checking for connections
                    this.checkForJoiner();
                    
                } catch (error) {
                    console.error('Error hosting game:', error);
                    showNotification('Failed to create room', 'error');
                    updateConnectionStatus('disconnected', 'Failed to create room');
                }
            }

            async joinGame(roomCode) {
                try {
                    gameState.isHost = false;
                    gameState.playerId = 'joiner_' + this.generateId();
                    gameState.roomCode = roomCode.toUpperCase();
                    
                    showNotification('Connecting to room...', 'info');
                    updateConnectionStatus('connecting', 'Connecting...');
                    
                    // Get host offer
                    const hostData = localStorage.getItem('hostOffer');
                    if (!hostData) {
                        throw new Error('Room not found');
                    }
                    
                    const room = JSON.parse(hostData);
                    if (room.roomCode !== gameState.roomCode) {
                        throw new Error('Invalid room code');
                    }
                    
                    // Check if room is expired (5 minutes)
                    if (Date.now() - room.timestamp > 300000) {
                        throw new Error('Room expired');
                    }
                    
                    // Set RNG seed from host
                    rng = new SeededRandom(room.seed);
                    
                    // Create peer connection
                    gameState.peer = new RTCPeerConnection({
                        iceServers: this.iceServers,
                        iceCandidatePoolSize: 10
                    });
                    
                    // Setup data channel listener
                    gameState.peer.ondatachannel = (event) => {
                        gameState.dataChannel = event.channel;
                        this.setupDataChannel(gameState.dataChannel);
                    };
                    
                    // Handle ICE candidates
                    gameState.peer.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.storeCandidate(event.candidate, 'joiner');
                        }
                    };
                    
                    // Set remote description
                    await gameState.peer.setRemoteDescription(new RTCSessionDescription(room.sdp));
                    
                    // Add host ICE candidates
                    const hostCandidates = JSON.parse(localStorage.getItem('hostCandidates') || '[]');
                    for (const candidate of hostCandidates) {
                        await gameState.peer.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                    
                    // Create answer
                    const answer = await gameState.peer.createAnswer();
                    await gameState.peer.setLocalDescription(answer);
                    
                    // Store answer for host
                    const answerData = {
                        sdp: gameState.peer.localDescription,
                        roomCode: gameState.roomCode,
                        playerId: gameState.playerId,
                        timestamp: Date.now()
                    };
                    
                    localStorage.setItem('joinerAnswer', JSON.stringify(answerData));
                    localStorage.setItem('joinerCandidates', JSON.stringify([]));
                    
                    showNotification('Connected! Waiting for host to start...', 'success');
                    
                } catch (error) {
                    console.error('Error joining game:', error);
                    showNotification(error.message || 'Failed to connect', 'error');
                    updateConnectionStatus('disconnected', 'Connection failed');
                }
            }

            setupDataChannel(channel) {
                channel.onopen = () => {
                    console.log('Data channel opened');
                    gameState.connectionEstablished = true;
                    updateConnectionStatus('connected', 'Connected to partner');
                    
                    // Send player info
                    this.send('playerInfo', {
                        id: gameState.playerId,
                        name: gameState.isHost ? 'Player 1 (Host)' : 'Player 2 (Joiner)',
                        position: gameState.player.position
                    });
                    
                    if (gameState.isHost) {
                        showNotification('Player connected!', 'success');
                    } else {
                        showNotification('Connected to host!', 'success');
                    }
                };
                
                channel.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (error) {
                        console.error('Error parsing message:', error);
                    }
                };
                
                channel.onclose = () => {
                    console.log('Data channel closed');
                    gameState.connectionEstablished = false;
                    updateConnectionStatus('disconnected', 'Disconnected');
                    
                    if (gameState.gameStarted) {
                        showNotification('Partner disconnected', 'error');
                    }
                };
                
                channel.onerror = (error) => {
                    console.error('Data channel error:', error);
                };
            }

            send(type, data) {
                if (gameState.dataChannel && gameState.dataChannel.readyState === 'open') {
                    const message = {
                        type,
                        sender: gameState.playerId,
                        data,
                        timestamp: Date.now()
                    };
                    gameState.dataChannel.send(JSON.stringify(message));
                }
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'playerInfo':
                        this.handlePlayerInfo(message);
                        break;
                    case 'playerUpdate':
                        this.handlePlayerUpdate(message);
                        break;
                    case 'gameStart':
                        this.handleGameStart(message);
                        break;
                    case 'itemCollected':
                        this.handleItemCollected(message);
                        break;
                    case 'chat':
                        this.handleChat(message);
                        break;
                    case 'escapeStart':
                        this.handleEscapeStart(message);
                        break;
                    case 'gameOver':
                        this.handleGameOver(message);
                        break;
                }
            }

            handlePlayerInfo(message) {
                const { id, name, position } = message.data;
                
                if (id === gameState.playerId) return;
                
                // Create player mesh
                const playerMesh = this.createOtherPlayerMesh(id, name, position);
                
                // Add/update other player
                gameState.connectedPlayers.set(id, {
                    id,
                    name,
                    position,
                    mesh: playerMesh
                });
                
                updateOtherPlayerUI(id, name);
                showNotification(`${name} connected`, 'info');
            }

            createOtherPlayerMesh(playerId, playerName, position = { x: 10, y: 2, z: 0 }) {
                if (!gameState.scene) {
                    console.warn('Cannot create player mesh: Scene not initialized');
                    return null;
                }
                
                try {
                    // Create a simple player mesh (cube)
                    const geometry = new THREE.BoxGeometry(0.5, 1.8, 0.5);
                    const color = playerId.startsWith('host') ? 0xff4444 : 0x4a90e2;
                    const material = new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(position.x || 10, position.y || 2, position.z || 0);
                    mesh.castShadow = true;
                    
                    gameState.scene.add(mesh);
                    return mesh;
                    
                } catch (error) {
                    console.error('Error creating player mesh:', error);
                    return null;
                }
            }

            handlePlayerUpdate(message) {
                const { id, position, rotation, health, stamina } = message.data;
                
                if (id === gameState.playerId) return;
                
                const player = gameState.connectedPlayers.get(id);
                if (player && player.mesh) {
                    player.mesh.position.set(position.x, position.y, position.z);
                    player.mesh.rotation.set(rotation.x, rotation.y, 0);
                    player.position = position;
                    
                    // Update UI for other player
                    if (id.startsWith('joiner')) {
                        document.getElementById('player2Health').textContent = `${health}%`;
                        document.getElementById('player2HealthBar').style.width = `${health}%`;
                        document.getElementById('player2Stamina').textContent = `${stamina}%`;
                        document.getElementById('player2StaminaBar').style.width = `${stamina}%`;
                    }
                }
            }

            handleGameStart(message) {
                if (gameState.gameStarted) return;
                
                const { seed, startPositions } = message.data;
                rng = new SeededRandom(seed);
                
                // Set player position
                if (startPositions[gameState.playerId]) {
                    gameState.player.position = startPositions[gameState.playerId];
                }
                
                // Start game
                startGame();
            }

            handleItemCollected(message) {
                const { itemId, position } = message.data;
                showNotification(`Partner collected ${itemId}`, 'info');
                
                // Remove item from scene
                removeItemAtPosition(position);
            }

            handleChat(message) {
                const { sender, text } = message.data;
                const senderName = sender.startsWith('host') ? 'Player 1' : 'Player 2';
                displayChatMessage(senderName, text, false);
            }

            handleEscapeStart(message) {
                const { plan, starter } = message.data;
                showNotification(`${starter} started ${plan} escape!`, 'warning');
                
                if (!gameState.escapeInProgress) {
                    gameState.escapeInProgress = true;
                    showNotification('Join the escape attempt!', 'info');
                }
            }

            handleGameOver(message) {
                const { success, reason } = message.data;
                
                if (success) {
                    showNotification('Partner escaped!', 'success');
                } else {
                    showNotification(`Partner caught: ${reason}`, 'error');
                }
            }

            async checkForJoiner() {
                if (!gameState.isHost || gameState.connectionEstablished) return;
                
                try {
                    // Check for joiner answer
                    const joinerAnswer = localStorage.getItem('joinerAnswer');
                    if (joinerAnswer) {
                        const answer = JSON.parse(joinerAnswer);
                        if (answer.roomCode === gameState.roomCode) {
                            await gameState.peer.setRemoteDescription(new RTCSessionDescription(answer.sdp));
                            
                            // Add joiner ICE candidates
                            const joinerCandidates = JSON.parse(localStorage.getItem('joinerCandidates') || '[]');
                            for (const candidate of joinerCandidates) {
                                await gameState.peer.addIceCandidate(new RTCIceCandidate(candidate));
                            }
                            
                            localStorage.removeItem('joinerAnswer');
                            localStorage.removeItem('joinerCandidates');
                        }
                    }
                } catch (error) {
                    console.error('Error checking for joiner:', error);
                }
                
                // Continue checking
                if (!gameState.connectionEstablished) {
                    setTimeout(() => this.checkForJoiner(), 1000);
                }
            }

            storeCandidate(candidate, type) {
                const key = type === 'host' ? 'hostCandidates' : 'joinerCandidates';
                const candidates = JSON.parse(localStorage.getItem(key) || '[]');
                candidates.push(candidate);
                localStorage.setItem(key, JSON.stringify(candidates));
            }

            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            }
        }

        const network = new NetworkManager();

        // ============================================================================
        // 3D WORLD BUILDER
        // ============================================================================
        class PrisonBuilder {
            constructor() {
                this.materials = {
                    concrete: new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        roughness: 0.8,
                        metalness: 0.2
                    }),
                    brick: new THREE.MeshStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.7,
                        metalness: 0.1
                    }),
                    metal: new THREE.MeshStandardMaterial({
                        color: 0x666666,
                        roughness: 0.3,
                        metalness: 0.8
                    }),
                    glass: new THREE.MeshStandardMaterial({
                        color: 0x88ccff,
                        roughness: 0.1,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.3
                    }),
                    ground: new THREE.MeshStandardMaterial({
                        color: 0x228822,
                        roughness: 0.9,
                        metalness: 0
                    })
                };
            }

            buildPrison() {
                this.buildGround();
                this.buildOuterWalls();
                this.buildCellBlock();
                this.buildCafeteria();
                this.buildYard();
                this.buildAdminBuilding();
                this.buildWorkshop();
                this.buildInfirmary();
                this.spawnItems();
                this.spawnGuards();
                this.setupLighting();
            }

            buildGround() {
                const groundGeometry = new THREE.PlaneGeometry(CONFIG.PRISON_SIZE * 2, CONFIG.PRISON_SIZE * 2);
                const ground = new THREE.Mesh(groundGeometry, this.materials.ground);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.5;
                ground.receiveShadow = true;
                gameState.scene.add(ground);
            }

            buildOuterWalls() {
                const wallGeometry = new THREE.BoxGeometry(
                    CONFIG.PRISON_SIZE,
                    CONFIG.WALL_HEIGHT,
                    CONFIG.WALL_THICKNESS
                );
                
                // North wall
                const northWall = new THREE.Mesh(wallGeometry, this.materials.concrete);
                northWall.position.set(0, CONFIG.WALL_HEIGHT/2, -CONFIG.PRISON_SIZE/2);
                northWall.castShadow = true;
                gameState.scene.add(northWall);
                gameState.walls.push(northWall);
                
                // South wall
                const southWall = new THREE.Mesh(wallGeometry, this.materials.concrete);
                southWall.position.set(0, CONFIG.WALL_HEIGHT/2, CONFIG.PRISON_SIZE/2);
                southWall.castShadow = true;
                gameState.scene.add(southWall);
                gameState.walls.push(southWall);
                
                // East wall
                const eastWall = new THREE.Mesh(wallGeometry, this.materials.concrete);
                eastWall.rotation.y = Math.PI / 2;
                eastWall.position.set(CONFIG.PRISON_SIZE/2, CONFIG.WALL_HEIGHT/2, 0);
                eastWall.castShadow = true;
                gameState.scene.add(eastWall);
                gameState.walls.push(eastWall);
                
                // West wall
                const westWall = new THREE.Mesh(wallGeometry, this.materials.concrete);
                westWall.rotation.y = Math.PI / 2;
                westWall.position.set(-CONFIG.PRISON_SIZE/2, CONFIG.WALL_HEIGHT/2, 0);
                westWall.castShadow = true;
                gameState.scene.add(westWall);
                gameState.walls.push(westWall);
                
                // Add barbed wire on top
                this.addBarbedWire();
            }

            addBarbedWire() {
                const wireGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1);
                const wireMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
                
                // Add barbed wire along walls
                for (let i = -CONFIG.PRISON_SIZE/2 + 5; i < CONFIG.PRISON_SIZE/2 - 5; i += 10) {
                    // North wall
                    const wire1 = new THREE.Mesh(wireGeometry, wireMaterial);
                    wire1.position.set(i, CONFIG.WALL_HEIGHT + 2, -CONFIG.PRISON_SIZE/2);
                    gameState.scene.add(wire1);
                    
                    // South wall
                    const wire2 = new THREE.Mesh(wireGeometry, wireMaterial);
                    wire2.position.set(i, CONFIG.WALL_HEIGHT + 2, CONFIG.PRISON_SIZE/2);
                    gameState.scene.add(wire2);
                    
                    // East wall
                    const wire3 = new THREE.Mesh(wireGeometry, wireMaterial);
                    wire3.position.set(CONFIG.PRISON_SIZE/2, CONFIG.WALL_HEIGHT + 2, i);
                    gameState.scene.add(wire3);
                    
                    // West wall
                    const wire4 = new THREE.Mesh(wireGeometry, wireMaterial);
                    wire4.position.set(-CONFIG.PRISON_SIZE/2, CONFIG.WALL_HEIGHT + 2, i);
                    gameState.scene.add(wire4);
                }
            }

            buildCellBlock() {
                const { width, depth, height } = CONFIG.BUILDINGS.cellBlock;
                
                // Main building
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const building = new THREE.Mesh(buildingGeometry, this.materials.brick);
                building.position.set(-40, height/2, -20);
                building.castShadow = true;
                gameState.scene.add(building);
                gameState.buildings.push(building);
                
                // Add cells inside
                this.addCells();
            }

            addCells() {
                const cellMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                
                for (let i = 0; i < 12; i++) {
                    const row = Math.floor(i / 6);
                    const col = i % 6;
                    
                    const cellGeometry = new THREE.BoxGeometry(5, 3, 4);
                    const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                    cell.position.set(-45 + col * 8, 1.5, -25 + row * 12);
                    cell.castShadow = true;
                    gameState.scene.add(cell);
                    
                    // Add cell door
                    const doorGeometry = new THREE.BoxGeometry(2, 2.5, 0.2);
                    const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(-45 + col * 8 + 2.5, 1.25, -25 + row * 12 + 2);
                    door.userData = { type: 'door', locked: true };
                    gameState.scene.add(door);
                }
            }

            buildCafeteria() {
                const { width, depth, height } = CONFIG.BUILDINGS.cafeteria;
                
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const cafeteria = new THREE.Mesh(geometry, this.materials.concrete);
                cafeteria.position.set(30, height/2, -30);
                cafeteria.castShadow = true;
                gameState.scene.add(cafeteria);
                gameState.buildings.push(cafeteria);
                
                // Add tables and benches
                this.addTables();
            }

            addTables() {
                const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                
                for (let i = 0; i < 6; i++) {
                    const tableGeometry = new THREE.BoxGeometry(6, 1, 2);
                    const table = new THREE.Mesh(tableGeometry, tableMaterial);
                    table.position.set(25 + (i % 3) * 10, 1, -25 + Math.floor(i/3) * 10);
                    gameState.scene.add(table);
                }
            }

            buildYard() {
                // Yard area (already part of ground)
                // Add exercise equipment
                this.addExerciseEquipment();
            }

            addExerciseEquipment() {
                const metalMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                
                // Pull-up bars
                for (let i = 0; i < 3; i++) {
                    const barGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2);
                    const bar = new THREE.Mesh(barGeometry, metalMaterial);
                    bar.position.set(10 + i * 5, 2.5, 20);
                    bar.rotation.z = Math.PI / 2;
                    gameState.scene.add(bar);
                }
            }

            buildAdminBuilding() {
                const { width, depth, height } = CONFIG.BUILDINGS.admin;
                
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const admin = new THREE.Mesh(geometry, this.materials.concrete);
                admin.position.set(40, height/2, 40);
                admin.castShadow = true;
                gameState.scene.add(admin);
                gameState.buildings.push(admin);
            }

            buildWorkshop() {
                const { width, depth, height } = CONFIG.BUILDINGS.workshop;
                
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const workshop = new THREE.Mesh(geometry, this.materials.metal);
                workshop.position.set(0, height/2, 40);
                workshop.castShadow = true;
                gameState.scene.add(workshop);
                gameState.buildings.push(workshop);
            }

            buildInfirmary() {
                const { width, depth, height } = CONFIG.BUILDINGS.infirmary;
                
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const infirmary = new THREE.Mesh(geometry, this.materials.concrete);
                infirmary.position.set(-40, height/2, 40);
                infirmary.castShadow = true;
                gameState.scene.add(infirmary);
                gameState.buildings.push(infirmary);
            }

            spawnItems() {
                const positions = [
                    { x: -35, y: 1, z: -15 },
                    { x: 25, y: 1, z: -25 },
                    { x: 10, y: 1, z: 25 },
                    { x: 35, y: 1, z: 35 },
                    { x: -5, y: 1, z: 35 },
                    { x: -35, y: 1, z: 35 },
                    { x: 0, y: 1, z: -40 },
                    { x: -20, y: 1, z: 0 }
                ];
                
                CONFIG.ITEMS.forEach((item, index) => {
                    if (index < positions.length) {
                        const pos = positions[index];
                        this.createItem(item, pos);
                    }
                });
            }

            createItem(item, position) {
                let geometry;
                
                switch(item.id) {
                    case 'shovel':
                        geometry = new THREE.BoxGeometry(0.3, 2, 0.1);
                        break;
                    case 'uniform':
                        geometry = new THREE.BoxGeometry(1, 1.5, 0.3);
                        break;
                    case 'crowbar':
                        geometry = new THREE.BoxGeometry(0.2, 1.5, 0.2);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(0.5, 0.1, 0.8);
                }
                
                const material = new THREE.MeshStandardMaterial({ color: item.color });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(position.x, position.y, position.z);
                mesh.rotation.y = rng.random(0, Math.PI * 2);
                mesh.castShadow = true;
                
                mesh.userData = {
                    type: 'item',
                    itemId: item.id,
                    itemName: item.name,
                    collected: false
                };
                
                gameState.scene.add(mesh);
                gameState.items.push({
                    mesh,
                    data: item,
                    position
                });
            }

            spawnGuards() {
                const patrolRoutes = [
                    [
                        { x: -80, z: -80 },
                        { x: 80, z: -80 },
                        { x: 80, z: 80 },
                        { x: -80, z: 80 }
                    ],
                    [
                        { x: -60, z: -40 },
                        { x: -20, z: -40 },
                        { x: -20, z: 0 },
                        { x: -60, z: 0 }
                    ],
                    [
                        { x: -30, z: 10 },
                        { x: 30, z: 10 },
                        { x: 30, z: 50 },
                        { x: -30, z: 50 }
                    ]
                ];
                
                for (let i = 0; i < CONFIG.GUARDS.count; i++) {
                    const guard = this.createGuard(i, patrolRoutes[i % patrolRoutes.length]);
                    gameState.guards.push(guard);
                }
            }

            createGuard(id, patrolRoute) {
                // Guard body
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                // Guard head
                const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdd99 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.2;
                
                // Create group
                const guardGroup = new THREE.Group();
                guardGroup.add(body);
                guardGroup.add(head);
                
                // Random starting position along patrol route
                const startIndex = Math.floor(rng.random(0, patrolRoute.length));
                const startPos = patrolRoute[startIndex];
                
                guardGroup.position.set(startPos.x, 1, startPos.z);
                guardGroup.castShadow = true;
                
                gameState.scene.add(guardGroup);
                
                return {
                    id,
                    group: guardGroup,
                    patrolRoute,
                    currentWaypoint: startIndex,
                    state: 'patrolling',
                    alertLevel: 0,
                    detectionRange: CONFIG.GUARDS.visionRange,
                    speed: CONFIG.GUARDS.patrolSpeed
                };
            }

            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                gameState.scene.add(ambientLight);
                
                // Main directional light (sun/moon)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                gameState.scene.add(directionalLight);
                gameState.lights.push(directionalLight);
                
                // Add security lights
                this.addSecurityLights();
            }

            addSecurityLights() {
                const lightPositions = [
                    { x: -90, y: 8, z: -90 },
                    { x: 90, y: 8, z: -90 },
                    { x: 90, y: 8, z: 90 },
                    { x: -90, y: 8, z: 90 },
                    { x: -40, y: 6, z: -20 },
                    { x: 30, y: 6, z: -30 }
                ];
                
                lightPositions.forEach(pos => {
                    const light = new THREE.PointLight(0xffcc00, 1, 50);
                    light.position.set(pos.x, pos.y, pos.z);
                    light.castShadow = true;
                    gameState.scene.add(light);
                    gameState.lights.push(light);
                });
            }
        }

        // ============================================================================
        // PLAYER CONTROLLER
        // ============================================================================
        class PlayerController {
            constructor() {
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.moveSpeed = CONFIG.PLAYER.walkSpeed;
                this.runSpeed = CONFIG.PLAYER.runSpeed;
                this.jumpForce = 5;
                this.isGrounded = false;
                this.canJump = false;
                this.staminaDrain = 0.5;
                this.staminaRecover = 0.2;
                
                this.setupControls();
            }

            setupControls() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    // Handle special keys
                    switch(e.key.toLowerCase()) {
                        case 'tab':
                            toggleInventory();
                            e.preventDefault();
                            break;
                        case 'c':
                            toggleChat();
                            e.preventDefault();
                            break;
                        case 'm':
                            toggleEscapeMenu();
                            e.preventDefault();
                            break;
                        case 'escape':
                            if (document.getElementById('chatPanel').style.display === 'block') {
                                toggleChat();
                            } else if (document.getElementById('escapeMenu').style.display === 'block') {
                                toggleEscapeMenu();
                            } else if (document.getElementById('inventoryPanel').style.display === 'block') {
                                toggleInventory();
                            } else {
                                pauseGame();
                            }
                            e.preventDefault();
                            break;
                        case 'enter':
                            if (document.getElementById('chatPanel').style.display === 'block') {
                                sendChatMessage();
                                e.preventDefault();
                            }
                            break;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Mouse
                window.addEventListener('mousemove', (e) => {
                    if (!gameState.gameStarted || gameState.gamePaused) return;
                    
                    const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
                    const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
                    
                    this.mouse.x += movementX * 0.002;
                    this.mouse.y += movementY * 0.002;
                    
                    // Limit vertical look
                    this.mouse.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.mouse.y));
                });
                
                window.addEventListener('mousedown', () => {
                    this.mouse.down = true;
                    if (gameState.gameStarted && !gameState.gamePaused) {
                        document.body.requestPointerLock();
                    }
                });
                
                window.addEventListener('mouseup', () => {
                    this.mouse.down = false;
                });
            }

            update(deltaTime) {
                if (!gameState.gameStarted || gameState.gamePaused || !gameState.camera) return;
                
                // Update camera rotation
                gameState.camera.rotation.x = -this.mouse.y;
                gameState.camera.rotation.y = -this.mouse.x;
                
                // Calculate movement direction
                this.direction.set(0, 0, 0);
                
                if (this.keys['w'] || this.keys['arrowup']) this.direction.z -= 1;
                if (this.keys['s'] || this.keys['arrowdown']) this.direction.z += 1;
                if (this.keys['a'] || this.keys['arrowleft']) this.direction.x -= 1;
                if (this.keys['d'] || this.keys['arrowright']) this.direction.x += 1;
                
                // Normalize direction
                if (this.direction.length() > 0) {
                    this.direction.normalize();
                    
                    // Apply rotation to direction
                    const angle = gameState.camera.rotation.y;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    const tempX = this.direction.x * cos - this.direction.z * sin;
                    const tempZ = this.direction.x * sin + this.direction.z * cos;
                    
                    this.direction.x = tempX;
                    this.direction.z = tempZ;
                }
                
                // Check if running
                const isRunning = this.keys['shift'] && gameState.player.stamina > 0;
                const speed = isRunning ? this.runSpeed : this.moveSpeed;
                
                // Apply movement
                this.velocity.x = this.direction.x * speed;
                this.velocity.z = this.direction.z * speed;
                
                // Handle jumping
                if ((this.keys[' '] || this.keys['space']) && this.canJump) {
                    this.velocity.y = this.jumpForce;
                    this.canJump = false;
                }
                
                // Apply gravity
                this.velocity.y -= 9.8 * deltaTime;
                
                // Update position
                gameState.player.position.x += this.velocity.x;
                gameState.player.position.y += this.velocity.y * deltaTime;
                gameState.player.position.z += this.velocity.z;
                
                // Ground collision
                if (gameState.player.position.y < 2) {
                    gameState.player.position.y = 2;
                    this.velocity.y = 0;
                    this.canJump = true;
                    this.isGrounded = true;
                } else {
                    this.isGrounded = false;
                }
                
                // Boundary check
                const halfSize = CONFIG.PRISON_SIZE / 2 - 5;
                gameState.player.position.x = Math.max(-halfSize, Math.min(halfSize, gameState.player.position.x));
                gameState.player.position.z = Math.max(-halfSize, Math.min(halfSize, gameState.player.position.z));
                
                // Update camera position
                gameState.camera.position.copy(gameState.player.position);
                gameState.camera.position.y += 1.6; // Eye level
                
                // Update player mesh position
                if (gameState.player.mesh) {
                    gameState.player.mesh.position.copy(gameState.player.position);
                }
                
                // Update stamina
                if (isRunning && this.direction.length() > 0) {
                    gameState.player.stamina = Math.max(0, gameState.player.stamina - this.staminaDrain);
                } else {
                    gameState.player.stamina = Math.min(CONFIG.PLAYER.maxStamina, 
                        gameState.player.stamina + this.staminaRecover);
                }
                
                // Update UI
                this.updatePlayerUI();
                
                // Send position update to other players
                if (network && gameState.connectionEstablished) {
                    network.send('playerUpdate', {
                        id: gameState.playerId,
                        position: gameState.player.position,
                        rotation: {
                            x: gameState.camera.rotation.x,
                            y: gameState.camera.rotation.y
                        },
                        health: gameState.player.health,
                        stamina: gameState.player.stamina
                    });
                }
                
                // Check for interactions
                if (this.keys['e']) {
                    this.checkInteractions();
                }
                
                // Check for item usage
                if (this.keys['f']) {
                    this.useItem();
                }
            }

            updatePlayerUI() {
                // Update health
                const healthPercent = (gameState.player.health / CONFIG.PLAYER.maxHealth) * 100;
                document.getElementById('player1Health').textContent = `${Math.round(healthPercent)}%`;
                document.getElementById('player1HealthBar').style.width = `${healthPercent}%`;
                
                // Update stamina
                const staminaPercent = (gameState.player.stamina / CONFIG.PLAYER.maxStamina) * 100;
                document.getElementById('player1Stamina').textContent = `${Math.round(staminaPercent)}%`;
                document.getElementById('player1StaminaBar').style.width = `${staminaPercent}%`;
                
                // Update other stats
                document.getElementById('player1Contraband').textContent = gameState.player.contraband;
                document.getElementById('player1Reputation').textContent = gameState.player.reputation;
            }

            checkInteractions() {
                // Check for nearby items
                let nearestItem = null;
                let nearestDistance = Infinity;
                
                gameState.items.forEach(item => {
                    if (item.mesh.userData.collected) return;
                    
                    const distance = gameState.player.position.distanceTo(item.mesh.position);
                    if (distance < 3 && distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestItem = item;
                    }
                });
                
                if (nearestItem && nearestDistance < 2) {
                    this.pickupItem(nearestItem);
                }
            }

            pickupItem(item) {
                if (gameState.player.inventory.length >= CONFIG.PLAYER.inventorySize) {
                    showNotification('Inventory full!', 'warning');
                    return;
                }
                
                // Calculate total weight
                const currentWeight = gameState.player.inventory.reduce((total, invItem) => 
                    total + invItem.weight, 0);
                
                if (currentWeight + item.data.weight > CONFIG.PLAYER.maxWeight) {
                    showNotification('Too heavy!', 'warning');
                    return;
                }
                
                // Add to inventory
                gameState.player.inventory.push(item.data);
                gameState.player.contraband++;
                
                // Mark as collected
                item.mesh.userData.collected = true;
                gameState.scene.remove(item.mesh);
                
                // Update inventory UI
                updateInventoryUI();
                
                // Notify other players
                if (network && gameState.connectionEstablished) {
                    network.send('itemCollected', {
                        itemId: item.data.id,
                        position: item.position
                    });
                }
                
                showNotification(`Picked up: ${item.data.name}`, 'success');
                
                // Check escape requirements
                checkEscapeRequirements();
            }

            useItem() {
                if (gameState.player.inventory.length === 0) return;
                
                // For now, just use the first item
                const item = gameState.player.inventory[0];
                
                switch(item.id) {
                    case 'shovel':
                        showNotification('Digging...', 'info');
                        break;
                    case 'crowbar':
                        showNotification('Prying...', 'info');
                        break;
                    case 'food':
                        gameState.player.health = Math.min(CONFIG.PLAYER.maxHealth, gameState.player.health + 20);
                        gameState.player.inventory.shift(); // Remove food
                        updateInventoryUI();
                        showNotification('Ate food: +20 health', 'success');
                        break;
                    default:
                        showNotification(`Used: ${item.name}`, 'info');
                }
            }
        }

        // ============================================================================
        // AI GUARD CONTROLLER
        // ============================================================================
        class GuardAI {
            update(deltaTime) {
                gameState.guards.forEach(guard => {
                    switch(guard.state) {
                        case 'patrolling':
                            this.patrol(guard, deltaTime);
                            break;
                        case 'chasing':
                            this.chase(guard, deltaTime);
                            break;
                        case 'searching':
                            this.search(guard, deltaTime);
                            break;
                    }
                    
                    // Check for player detection
                    this.checkDetection(guard);
                });
            }

            patrol(guard, deltaTime) {
                const route = guard.patrolRoute;
                const currentTarget = route[guard.currentWaypoint];
                const guardPos = guard.group.position;
                
                // Calculate direction to target
                const dx = currentTarget.x - guardPos.x;
                const dz = currentTarget.z - guardPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Move toward target
                if (distance > 1) {
                    guardPos.x += (dx / distance) * guard.speed;
                    guardPos.z += (dz / distance) * guard.speed;
                    
                    // Rotate toward movement direction
                    guard.group.lookAt(
                        guardPos.x + dx,
                        guardPos.y,
                        guardPos.z + dz
                    );
                } else {
                    // Reached waypoint, move to next
                    guard.currentWaypoint = (guard.currentWaypoint + 1) % route.length;
                }
            }

            chase(guard, deltaTime) {
                if (!gameState.player.position) return;
                
                const guardPos = guard.group.position;
                const playerPos = gameState.player.position;
                
                const dx = playerPos.x - guardPos.x;
                const dz = playerPos.z - guardPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Move toward player
                guardPos.x += (dx / distance) * guard.speed * 1.5;
                guardPos.z += (dz / distance) * guard.speed * 1.5;
                
                // Rotate toward player
                guard.group.lookAt(playerPos.x, guardPos.y, playerPos.z);
                
                // Catch player
                if (distance < 2) {
                    this.catchPlayer(guard);
                }
            }

            search(guard, deltaTime) {
                // For now, just return to patrol
                guard.state = 'patrolling';
                guard.alertLevel = Math.max(0, guard.alertLevel - 10);
            }

            checkDetection(guard) {
                if (!gameState.player.position) return;
                
                const guardPos = guard.group.position;
                const playerPos = gameState.player.position;
                
                // Calculate distance
                const dx = playerPos.x - guardPos.x;
                const dz = playerPos.z - guardPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Check if player is in range
                if (distance < guard.detectionRange) {
                    // Simple detection
                    guard.alertLevel += 5;
                    
                    if (guard.alertLevel > 30) {
                        guard.state = 'chasing';
                        showNotification('Guard spotted you!', 'warning');
                    }
                }
                
                // Decrease alert level over time
                if (guard.state !== 'chasing') {
                    guard.alertLevel = Math.max(0, guard.alertLevel - 1);
                }
            }

            catchPlayer(guard) {
                showNotification('Caught by guard!', 'error');
                gameOver('Caught by guard');
            }

            updateGuardAppearance(guard) {
                // Change guard color based on alert level
                const body = guard.group.children[0];
                if (body && body.material) {
                    const alertPercent = guard.alertLevel / 100;
                    const color = new THREE.Color(0x0000ff).lerp(new THREE.Color(0xff0000), alertPercent);
                    body.material.color = color;
                }
            }
        }

        // ============================================================================
        // GAME INITIALIZATION
        // ============================================================================
        async function startGame() {
            try {
                // Show loading
                document.getElementById('loadingSection').style.display = 'block';
                document.getElementById('roomInfo').style.display = 'none';
                document.getElementById('loadingText').textContent = 'Building prison environment...';
                
                // Initialize Three.js
                await initializeThreeJS();
                
                // Build prison
                const builder = new PrisonBuilder();
                builder.buildPrison();
                
                // Create player
                createPlayer();
                
                // Initialize controllers
                const playerController = new PlayerController();
                const guardAI = new GuardAI();
                
                // Store references
                gameState.playerController = playerController;
                gameState.guardAI = guardAI;
                
                // Hide loading, show game
                setTimeout(() => {
                    document.getElementById('loadingSection').style.display = 'none';
                    document.getElementById('lobbyScreen').style.display = 'none';
                    document.getElementById('gameScreen').style.display = 'flex';
                    
                    // Show objective
                    document.getElementById('objectiveDisplay').style.display = 'block';
                    
                    // Start game loop
                    gameState.gameStarted = true;
                    animate();
                    
                    // If host, send game start to other players
                    if (gameState.isHost && network) {
                        const startPositions = {};
                        gameState.connectedPlayers.forEach((player, id) => {
                            startPositions[id] = { x: 10, y: 2, z: 0 };
                        });
                        startPositions[gameState.playerId] = { x: -10, y: 2, z: 0 };
                        
                        network.send('gameStart', {
                            seed: Date.now(),
                            startPositions
                        });
                    }
                    
                    showNotification('Game started! Good luck!', 'success');
                }, 2000);
                
            } catch (error) {
                console.error('Error starting game:', error);
                showNotification('Failed to start game', 'error');
                returnToLobby();
            }
        }

        function initializeThreeJS() {
            return new Promise((resolve, reject) => {
                try {
                    // Create scene
                    gameState.scene = new THREE.Scene();
                    gameState.scene.fog = new THREE.Fog(0x112233, 10, 200);
                    
                    // Create camera
                    gameState.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    
                    // Create renderer
                    const canvas = document.getElementById('gameCanvas');
                    if (!canvas) throw new Error('Canvas not found');
                    
                    gameState.renderer = new THREE.WebGLRenderer({
                        canvas,
                        antialias: true,
                        alpha: true
                    });
                    
                    gameState.renderer.setSize(window.innerWidth, window.innerHeight);
                    gameState.renderer.setPixelRatio(window.devicePixelRatio);
                    gameState.renderer.shadowMap.enabled = true;
                    gameState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    
                    // Set background
                    gameState.scene.background = new THREE.Color(0x112233);
                    
                    resolve();
                } catch (error) {
                    reject(error);
                }
            });
        }

        function createPlayer() {
            // Create player mesh
            const geometry = new THREE.BoxGeometry(0.5, 1.8, 0.5);
            const material = new THREE.MeshBasicMaterial({ 
                color: gameState.isHost ? 0xff4444 : 0x4a90e2,
                transparent: true,
                opacity: 0.5
            });
            
            gameState.player.mesh = new THREE.Mesh(geometry, material);
            gameState.player.mesh.position.copy(gameState.player.position);
            gameState.scene.add(gameState.player.mesh);
            
            // Position camera
            gameState.camera.position.set(
                gameState.player.position.x,
                gameState.player.position.y + 1.6,
                gameState.player.position.z
            );
        }

        // ============================================================================
        // GAME LOOP
        // ============================================================================
        function animate() {
            if (!gameState.gameStarted) return;
            
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min(gameState.clock.getDelta(), 0.1);
            
            // Update time of day
            updateTimeOfDay(deltaTime);
            
            // Update player
            if (gameState.playerController) {
                gameState.playerController.update(deltaTime);
            }
            
            // Update guards
            if (gameState.guardAI) {
                gameState.guardAI.update(deltaTime);
                
                // Update guard appearances
                gameState.guards.forEach(guard => {
                    gameState.guardAI.updateGuardAppearance(guard);
                });
            }
            
            // Update other players
            updateOtherPlayers();
            
            // Update lighting based on time
            updateLighting();
            
            // Render scene
            if (gameState.renderer && gameState.scene && gameState.camera) {
                gameState.renderer.render(gameState.scene, gameState.camera);
            }
        }

        function updateTimeOfDay(deltaTime) {
            gameState.timeOfDay += deltaTime / CONFIG.DAY_NIGHT_CYCLE;
            if (gameState.timeOfDay >= 1) gameState.timeOfDay = 0;
            
            gameState.isNight = gameState.timeOfDay < CONFIG.NIGHT_END || gameState.timeOfDay > CONFIG.NIGHT_START;
        }

        function updateLighting() {
            // Update sun/moon position
            const sun = gameState.lights.find(light => light.isDirectionalLight);
            if (sun) {
                const angle = gameState.timeOfDay * Math.PI * 2;
                sun.position.x = Math.cos(angle) * 100;
                sun.position.y = Math.sin(angle) * 100;
                sun.position.z = Math.sin(angle) * 50;
                
                // Adjust intensity based on time
                const intensity = Math.sin(gameState.timeOfDay * Math.PI) * 0.5 + 0.3;
                sun.intensity = intensity;
                
                // Adjust color based on time
                if (gameState.isNight) {
                    sun.color.setHex(0x88aaff);
                } else {
                    sun.color.setHex(0xffffff);
                }
            }
            
            // Update security lights
            gameState.lights.forEach(light => {
                if (light.isPointLight) {
                    light.intensity = gameState.isNight ? 2 : 0.5;
                }
            });
        }

        function updateOtherPlayers() {
            gameState.connectedPlayers.forEach((player, id) => {
                if (player.mesh && player.position) {
                    // Smooth movement
                    player.mesh.position.lerp(new THREE.Vector3(
                        player.position.x,
                        player.position.y,
                        player.position.z
                    ), 0.2);
                }
            });
        }

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        function updateOtherPlayerUI(playerId, playerName) {
            if (playerId.startsWith('joiner')) {
                document.getElementById('player2Id').textContent = playerName;
                document.getElementById('player2Health').textContent = '100%';
                document.getElementById('player2Stamina').textContent = '100%';
                document.getElementById('player2Contraband').textContent = '0';
                document.getElementById('player2Reputation').textContent = '0';
            }
        }

        function removeItemAtPosition(position) {
            for (let i = gameState.items.length - 1; i >= 0; i--) {
                const item = gameState.items[i];
                if (item && item.position && 
                    Math.abs(item.position.x - position.x) < 2 &&
                    Math.abs(item.position.z - position.z) < 2) {
                    
                    if (item.mesh && item.mesh.parent) {
                        item.mesh.parent.remove(item.mesh);
                    }
                    gameState.items.splice(i, 1);
                    break;
                }
            }
        }

        function displayChatMessage(sender, message, isLocal) {
            const messages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isLocal ? 'you' : 'partner'}`;
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
            messages.appendChild(messageDiv);
            messages.scrollTop = messages.scrollHeight;
        }

        function showJoinSection() {
            document.getElementById('joinSection').style.display = 'block';
            document.getElementById('hostBtn').disabled = true;
            document.getElementById('joinBtn').disabled = true;
            document.getElementById('roomCodeInput').focus();
        }

        function hideJoinSection() {
            document.getElementById('joinSection').style.display = 'none';
            document.getElementById('hostBtn').disabled = false;
            document.getElementById('joinBtn').disabled = false;
        }

        function showTutorial() {
            document.getElementById('tutorialSection').style.display = 'block';
        }

        function hideTutorial() {
            document.getElementById('tutorialSection').style.display = 'none';
        }

        function copyRoomCode() {
            const code = document.getElementById('roomCodeDisplay').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showNotification('Room code copied!', 'success');
            });
        }

        function cancelHosting() {
            if (gameState.peer) {
                gameState.peer.close();
            }
            localStorage.removeItem('hostOffer');
            localStorage.removeItem('hostCandidates');
            document.getElementById('roomInfo').style.display = 'none';
            document.getElementById('hostBtn').disabled = false;
            document.getElementById('joinBtn').disabled = false;
            updateConnectionStatus('disconnected', 'Ready');
        }

        function returnToLobby() {
            // Clean up game
            if (gameState.renderer) {
                gameState.renderer.dispose();
            }
            
            if (gameState.peer) {
                gameState.peer.close();
            }
            
            // Reset state
            gameState.gameStarted = false;
            gameState.connectedPlayers.clear();
            
            // Show lobby
            document.getElementById('solitaryScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'flex';
            
            updateConnectionStatus('disconnected', 'Ready to play');
        }

        function retryGame() {
            // Reset game state
            gameState.player.health = CONFIG.PLAYER.maxHealth;
            gameState.player.stamina = CONFIG.PLAYER.maxStamina;
            gameState.player.inventory = [];
            gameState.player.contraband = 0;
            gameState.escapeInProgress = false;
            
            // Clear scene
            while(gameState.scene.children.length > 0) {
                gameState.scene.remove(gameState.scene.children[0]);
            }
            
            // Rebuild prison with new seed
            rng = new SeededRandom(Date.now());
            const builder = new PrisonBuilder();
            builder.buildPrison();
            
            // Reset player position
            gameState.player.position = { x: -10, y: 2, z: 0 };
            if (gameState.player.mesh) {
                gameState.player.mesh.position.set(-10, 2, 0);
            }
            if (gameState.camera) {
                gameState.camera.position.set(-10, 3.6, 0);
            }
            
            // Return to game
            document.getElementById('solitaryScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            
            showNotification('New attempt! Good luck!', 'success');
        }

        function toggleInventory() {
            const panel = document.getElementById('inventoryPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
            
            if (panel.style.display === 'block') {
                updateInventoryUI();
            }
        }

        function updateInventoryUI() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            
            // Create slots
            for (let i = 0; i < CONFIG.PLAYER.inventorySize; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                
                if (i < gameState.player.inventory.length) {
                    const item = gameState.player.inventory[i];
                    slot.textContent = item.icon;
                    slot.classList.add('filled');
                    slot.title = item.name;
                }
                
                grid.appendChild(slot);
            }
        }

        function toggleChat() {
            const panel = document.getElementById('chatPanel');
            if (panel.style.display === 'block') {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'flex';
                document.getElementById('chatInput').focus();
            }
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (message && network && gameState.connectionEstablished) {
                // Display locally
                displayChatMessage('You', message, true);
                
                // Send to other players
                network.send('chat', {
                    sender: gameState.playerId,
                    text: message
                });
                
                input.value = '';
            }
        }

        function toggleEscapeMenu() {
            const menu = document.getElementById('escapeMenu');
            menu.style.display = menu.style.display === 'block' ? 'none' : 'grid';
            
            if (menu.style.display === 'grid') {
                checkEscapeRequirements();
            }
        }

        function checkEscapeRequirements() {
            const plans = ['tunnel', 'disguise', 'riot', 'parole'];
            
            plans.forEach(plan => {
                const card = document.getElementById(`plan${plan.charAt(0).toUpperCase() + plan.slice(1)}`);
                const requirements = CONFIG.ESCAPE_REQUIREMENTS[plan];
                
                let canEscape = false;
                
                if (Array.isArray(requirements)) {
                    // Item-based requirements
                    canEscape = requirements.every(req => 
                        gameState.player.inventory.some(item => item.id === req)
                    );
                } else {
                    // Stat-based requirements
                    canEscape = true;
                    if (requirements.reputation !== undefined) {
                        canEscape = canEscape && gameState.player.reputation >= requirements.reputation;
                    }
                    if (requirements.contraband !== undefined) {
                        canEscape = canEscape && gameState.player.contraband <= requirements.contraband;
                    }
                }
                
                if (canEscape) {
                    card.classList.add('available');
                    card.classList.remove('unavailable');
                } else {
                    card.classList.remove('available');
                    card.classList.add('unavailable');
                }
            });
        }

        function selectEscapePlan(plan) {
            const card = document.getElementById(`plan${plan.charAt(0).toUpperCase() + plan.slice(1)}`);
            if (card.classList.contains('unavailable')) {
                showNotification('Requirements not met!', 'warning');
                return;
            }
            
            toggleEscapeMenu();
            gameState.escapeInProgress = true;
            
            // Notify other players
            if (network && gameState.connectionEstablished) {
                network.send('escapeStart', {
                    plan,
                    starter: gameState.isHost ? 'Player 1' : 'Player 2'
                });
            }
            
            showNotification(`Starting ${plan} escape...`, 'info');
            
            // Start escape sequence
            setTimeout(() => {
                const success = attemptEscape(plan);
                
                if (success) {
                    escapeSuccess(plan);
                } else {
                    escapeFailure(plan);
                }
            }, 5000);
        }

        function attemptEscape(plan) {
            let successChance = 0.5;
            
            // Base chances by plan
            switch(plan) {
                case 'tunnel': successChance = 0.6; break;
                case 'disguise': successChance = 0.7; break;
                case 'riot': successChance = 0.5 + (gameState.player.reputation / 100); break;
                case 'parole': successChance = 0.8 - (gameState.player.contraband * 0.1); break;
            }
            
            // Partner bonus
            if (gameState.connectedPlayers.size > 0) {
                successChance += 0.2;
            }
            
            // Night bonus/malus
            if (plan === 'tunnel' && gameState.isNight) {
                successChance += 0.2;
            }
            if (plan === 'disguise' && !gameState.isNight) {
                successChance += 0.1;
            }
            
            return Math.random() < Math.min(0.95, successChance);
        }

        function escapeSuccess(plan) {
            const messages = {
                tunnel: ["Freedom through dirt and determination!", "You dug your way to liberty!"],
                disguise: ["The uniform was a perfect fit. Welcome to the outside world!", "You walked right out the front gate!"],
                riot: ["In the chaos, you found your freedom!", "The riot was the perfect distraction!"],
                parole: ["Paperwork can set you free!", "You're now a free citizen!"]
            };
            
            const message = messages[plan][Math.floor(Math.random() * messages[plan].length)];
            
            alert(`üéâ ESCAPE SUCCESSFUL! üéâ\n\n${message}\n\nCongratulations! You escaped via ${plan}.\n\nRefresh to play again.`);
            
            // Notify other players
            if (network && gameState.connectionEstablished) {
                network.send('gameOver', {
                    success: true,
                    plan
                });
            }
        }

        function escapeFailure(plan) {
            const reasons = {
                tunnel: "The tunnel collapsed!",
                disguise: "The ID was checked and didn't match!",
                riot: "The riot was quickly contained!",
                parole: "Your parole was denied!"
            };
            
            const reason = reasons[plan];
            gameOver(reason);
            
            // Notify other players
            if (network && gameState.connectionEstablished) {
                network.send('gameOver', {
                    success: false,
                    reason
                });
            }
        }

        function gameOver(reason) {
            gameState.gameStarted = false;
            
            // Show solitary screen
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('solitaryScreen').style.display = 'flex';
            
            document.getElementById('solitaryReason').textContent = reason;
            
            // Set funny message
            const messages = [
                "The guards are enjoying coffee while you're in here...",
                "At least the rats are good company!",
                "Solitary: where dreams go to nap.",
                "You had time to think about your life choices... still a bad idea!",
                "The warden sends his regards... and a bill for damages.",
                "Even the cockroaches are judging you right now."
            ];
            
            document.getElementById('solitaryMessage').textContent = 
                messages[Math.floor(Math.random() * messages.length)];
            
            // Show tip
            const tips = [
                "Tip: Try collecting more items before escaping.",
                "Tip: Work closely with your partner.",
                "Tip: Some escape methods work better at night.",
                "Tip: Avoid guards when they're alert."
            ];
            
            document.getElementById('escapeTip').textContent = 
                tips[Math.floor(Math.random() * tips.length)];
            
            // Animate solitary scene
            animateSolitaryScene();
        }

        function animateSolitaryScene() {
            const container = document.getElementById('solitaryAnimation');
            container.innerHTML = '';
            
            // Create cell bars
            for (let i = 0; i < 8; i++) {
                const bar = document.createElement('div');
                bar.style.cssText = `
                    position: absolute;
                    width: 5px;
                    height: 200px;
                    background: #888;
                    left: ${20 + i * 40}px;
                    top: 50px;
                    border-radius: 2px;
                `;
                container.appendChild(bar);
            }
            
            // Create prisoner (player)
            const prisoner = document.createElement('div');
            prisoner.style.cssText = `
                position: absolute;
                width: 30px;
                height: 50px;
                background: linear-gradient(to bottom, #ff4444, #880000);
                border-radius: 15px 15px 5px 5px;
                left: 200px;
                bottom: 20px;
            `;
            container.appendChild(prisoner);
            
            // Create guard
            const guard = document.createElement('div');
            guard.style.cssText = `
                position: absolute;
                width: 40px;
                height: 60px;
                background: linear-gradient(to bottom, #0000ff, #0088ff);
                border-radius: 20px 20px 5px 5px;
                left: 0px;
                bottom: 20px;
            `;
            container.appendChild(guard);
            
            // Animate guard patrol
            let direction = 1;
            const guardInterval = setInterval(() => {
                if (document.getElementById('solitaryScreen').style.display !== 'flex') {
                    clearInterval(guardInterval);
                    return;
                }
                
                const currentLeft = parseInt(guard.style.left) || 0;
                if (currentLeft > 300) direction = -1;
                if (currentLeft < 0) direction = 1;
                
                guard.style.left = (currentLeft + direction * 50) + 'px';
                
                // Make prisoner occasionally move
                if (Math.random() < 0.1) {
                    prisoner.style.left = (190 + Math.random() * 20) + 'px';
                }
            }, 1000);
        }

        function hideObjective() {
            document.getElementById('objectiveDisplay').style.display = 'none';
            document.body.requestPointerLock();
        }

        function pauseGame() {
            gameState.gamePaused = !gameState.gamePaused;
            if (gameState.gamePaused) {
                document.exitPointerLock();
                showNotification('Game Paused', 'info');
            } else {
                document.body.requestPointerLock();
            }
        }

        function updateConnectionStatus(status, message) {
            const element = document.getElementById('connectionStatus');
            if (element) {
                element.textContent = `Status: ${message}`;
                element.className = `status-${status}`;
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            if (!notification) return;
            
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // ============================================================================
        // WINDOW EVENT HANDLERS
        // ============================================================================
        window.addEventListener('resize', () => {
            if (gameState.camera && gameState.renderer) {
                gameState.camera.aspect = window.innerWidth / window.innerHeight;
                gameState.camera.updateProjectionMatrix();
                gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        window.addEventListener('beforeunload', () => {
            // Clean up
            if (gameState.peer) {
                gameState.peer.close();
            }
            if (gameState.renderer) {
                gameState.renderer.dispose();
            }
            
            // Clear localStorage
            localStorage.removeItem('hostOffer');
            localStorage.removeItem('hostCandidates');
            localStorage.removeItem('joinerAnswer');
            localStorage.removeItem('joinerCandidates');
        });

        // ============================================================================
        // PUBLIC FUNCTIONS (called from HTML)
        // ============================================================================
        function hostGame() {
            network.hostGame();
        }

        function joinGame() {
            const code = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (code.length === 6) {
                network.joinGame(code);
            } else {
                showNotification('Please enter a 6-digit code', 'error');
            }
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Cell Block Zero - Professional Edition Loaded');
            updateConnectionStatus('disconnected', 'Ready to play');
            
            // Check if on mobile
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                showNotification('Mobile controls coming soon!', 'info');
            }
        });

    </script>
</body>
</html>
