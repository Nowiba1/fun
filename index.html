<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cell Block Zero - Cooperative Prison Escape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background: #0a0a0a;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        /* UI Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            padding: 20px;
        }

        #lobbyScreen {
            display: flex;
        }

        #gameScreen {
            display: none;
        }

        #solitaryScreen {
            display: none;
            background: #000;
        }

        /* UI Elements */
        .ui-box {
            background: rgba(0, 20, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 20px;
            max-width: 600px;
            text-align: center;
        }

        h1 {
            color: #ff3300;
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ff0000;
        }

        h2 {
            color: #00ccff;
            margin: 15px 0;
        }

        p {
            margin: 10px 0;
            line-height: 1.5;
        }

        button {
            background: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 12px 24px;
            margin: 10px;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }

        button:hover {
            background: #006600;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        #connectionStatus {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff00;
            border-radius: 5px;
        }

        #gameUI {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }

        .player-info {
            background: rgba(0, 20, 0, 0.7);
            border: 2px solid #00ff00;
            padding: 10px;
            min-width: 200px;
        }

        #inventory {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffcc00;
            padding: 10px;
            border-radius: 5px;
        }

        .inventory-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .inventory-icon {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #ffcc00;
        }

        #objective {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #ff3300;
            padding: 20px;
            text-align: center;
            display: none;
        }

        #chat {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ccff;
            padding: 10px;
            display: none;
        }

        #chatInput {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            background: #111;
            color: #00ff00;
            border: 1px solid #00ccff;
        }

        #escapeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 0, 0.95);
            border: 3px solid #ff3300;
            padding: 30px;
            display: none;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .escape-option {
            padding: 15px;
            border: 2px solid #00ccff;
            cursor: pointer;
            text-align: center;
        }

        .escape-option:hover {
            background: rgba(0, 100, 100, 0.5);
        }

        /* Solitary Screen Animation */
        #solitaryAnimation {
            width: 100%;
            height: 300px;
            background: #000;
            border: 5px solid #333;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .inmate-cell {
            position: absolute;
            width: 50px;
            height: 50px;
            background: #666;
            border: 2px solid #999;
        }

        .guard-bot {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #00ccff;
            border-radius: 50%;
            transition: left 2s;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Lobby Screen -->
        <div id="lobbyScreen" class="screen">
            <div class="ui-box">
                <h1>CELL BLOCK ZERO</h1>
                <h2>Cooperative Prison Escape</h2>
                <p>You and a partner must work together to escape from a maximum-security prison.</p>
                <p>Use wit, timing, and cooperation to outsmart the guard bots!</p>
                
                <div id="connectionStatus">Status: Disconnected</div>
                
                <div style="margin: 30px 0;">
                    <button onclick="hostGame()">HOST GAME</button>
                    <button onclick="joinGame()">JOIN GAME</button>
                </div>
                
                <div id="joinSection" style="display: none; margin: 20px 0;">
                    <input type="text" id="roomCode" placeholder="Enter host code" style="padding: 10px; width: 200px; margin-right: 10px;">
                    <button onclick="connectToHost()">CONNECT</button>
                </div>
                
                <div id="roomInfo" style="display: none; margin: 20px 0;">
                    <h3>Room Code: <span id="displayCode">XXXX</span></h3>
                    <p>Waiting for player 2...</p>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3>Controls:</h3>
                    <p>WASD: Move | E: Interact | F: Fight | R: Run | Tab: Inventory</p>
                    <p>C: Chat | M: Escape Menu | Space: Jump</p>
                </div>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="screen">
            <canvas id="gameCanvas"></canvas>
            
            <div id="connectionStatus">Connected</div>
            
            <div id="gameUI">
                <div class="player-info">
                    <h3>Player 1 (You)</h3>
                    <p>Health: <span id="health1">100</span></p>
                    <p>Contraband: <span id="contraband1">0</span></p>
                    <p>Reputation: <span id="rep1">0</span></p>
                </div>
                
                <div class="player-info">
                    <h3>Player 2</h3>
                    <p>Health: <span id="health2">100</span></p>
                    <p>Contraband: <span id="contraband2">0</span></p>
                    <p>Reputation: <span id="rep2">0</span></p>
                </div>
            </div>
            
            <div id="inventory" style="display: none;">
                <h3>Inventory</h3>
                <div id="inventoryItems"></div>
            </div>
            
            <div id="objective">
                <h2>OBJECTIVE</h2>
                <p id="objectiveText">Escape the prison with your partner!</p>
                <button onclick="hideObjective()">Continue</button>
            </div>
            
            <div id="chat" style="display: none;">
                <div id="chatMessages"></div>
                <input type="text" id="chatInput" placeholder="Type message... (Press Enter to send)">
            </div>
            
            <div id="escapeMenu">
                <h2 style="grid-column: span 2;">ESCAPE METHODS</h2>
                <div class="escape-option" onclick="startEscape('tunnel')">
                    <h3>Tunnel Digging</h3>
                    <p>Requires: Shovel, Nighttime</p>
                </div>
                <div class="escape-option" onclick="startEscape('disguise')">
                    <h3>Guard Disguise</h3>
                    <p>Requires: Uniform, ID Card</p>
                </div>
                <div class="escape-option" onclick="startEscape('riot')">
                    <h3>Riot Chaos</h3>
                    <p>Requires: High Reputation</p>
                </div>
                <div class="escape-option" onclick="startEscape('parole')">
                    <h3>Legal Parole</h3>
                    <p>Requires: Clean Record</p>
                </div>
            </div>
        </div>

        <!-- Solitary Screen -->
        <div id="solitaryScreen" class="screen">
            <div class="ui-box">
                <h1>SOLITARY CONFINEMENT</h1>
                <div id="solitaryAnimation"></div>
                <p id="failReason">You got caught!</p>
                <p id="funnyMessage">The guards are enjoying donuts while you're in here...</p>
                <button onclick="retryGame()">TRY AGAIN</button>
                <p style="margin-top: 20px; color: #ff9900;">The prison layout has changed!</p>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // GAME CONFIGURATION
        // ============================================================================
        const CONFIG = {
            PRISON_SIZE: 100,
            CELL_COUNT: 20,
            GUARD_COUNT: 4,
            INMATE_BOT_COUNT: 10,
            DAY_CYCLE: 300, // seconds
            ITEM_TYPES: ['shovel', 'uniform', 'idcard', 'cigarettes', 'donut', 'key'],
            ESCAPE_REQUIREMENTS: {
                tunnel: ['shovel'],
                disguise: ['uniform', 'idcard'],
                riot: ['reputation_50'],
                parole: ['clean_record']
            }
        };

        // ============================================================================
        // GAME STATE
        // ============================================================================
        let gameState = {
            players: {},
            bots: [],
            items: [],
            prisonLayout: [],
            timeOfDay: 0, // 0-1 (0 = midnight, 0.5 = noon)
            isNight: false,
            gameStarted: false,
            escapeInProgress: false,
            playerId: null,
            peer: null,
            connection: null,
            isHost: false
        };

        // ============================================================================
        // THREE.JS SETUP
        // ============================================================================
        let scene, camera, renderer, controls;
        let playerMesh, otherPlayerMesh;
        let botMeshes = [];
        let itemMeshes = [];
        let prisonWalls = [];

        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);
            
            // Fog for atmosphere
            scene.fog = new THREE.Fog(0x111122, 10, 100);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 30);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            // Simple OrbitControls
            controls = {
                update: function() {
                    if (playerMesh) {
                        camera.position.x = playerMesh.position.x;
                        camera.position.z = playerMesh.position.z + 15;
                        camera.position.y = 10;
                        camera.lookAt(playerMesh.position.x, 0, playerMesh.position.z);
                    }
                }
            };
            
            // Add grid for reference
            const gridHelper = new THREE.GridHelper(100, 100, 0x00ff00, 0x003300);
            scene.add(gridHelper);
            
            // Add simple skybox
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x112233,
                side: THREE.BackSide 
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }

        // ============================================================================
        // PRISON GENERATION
        // ============================================================================
        function generatePrison() {
            // Clear previous prison
            prisonWalls.forEach(wall => scene.remove(wall));
            prisonWalls = [];
            
            // Generate random prison layout
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                roughness: 0.8
            });
            
            // Outer walls
            const outerWallHeight = 10;
            const positions = [
                { x: -CONFIG.PRISON_SIZE/2, z: 0, width: 2, depth: CONFIG.PRISON_SIZE },
                { x: CONFIG.PRISON_SIZE/2, z: 0, width: 2, depth: CONFIG.PRISON_SIZE },
                { x: 0, z: -CONFIG.PRISON_SIZE/2, width: CONFIG.PRISON_SIZE, depth: 2 },
                { x: 0, z: CONFIG.PRISON_SIZE/2, width: CONFIG.PRISON_SIZE, depth: 2 }
            ];
            
            positions.forEach(pos => {
                const wallGeometry = new THREE.BoxGeometry(pos.width, outerWallHeight, pos.depth);
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(pos.x, outerWallHeight/2, pos.z);
                wall.receiveShadow = true;
                wall.castShadow = true;
                scene.add(wall);
                prisonWalls.push(wall);
            });
            
            // Generate cell blocks
            const cellMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.7
            });
            
            for (let i = 0; i < CONFIG.CELL_COUNT; i++) {
                const cellWidth = 8;
                const cellDepth = 6;
                const cellX = (i % 5) * 15 - 30;
                const cellZ = Math.floor(i / 5) * 15 - 30;
                
                const cellGeometry = new THREE.BoxGeometry(cellWidth, 4, cellDepth);
                const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                cell.position.set(cellX, 2, cellZ);
                cell.receiveShadow = true;
                cell.castShadow = true;
                scene.add(cell);
                prisonWalls.push(cell);
                
                // Add door
                const doorGeometry = new THREE.BoxGeometry(2, 3, 1);
                const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(cellX + cellWidth/2 - 1, 1.5, cellZ);
                scene.add(door);
                prisonWalls.push(door);
            }
            
            // Add yard area
            const yardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228822,
                roughness: 1.0
            });
            const yardGeometry = new THREE.PlaneGeometry(60, 60);
            const yard = new THREE.Mesh(yardGeometry, yardMaterial);
            yard.rotation.x = -Math.PI / 2;
            yard.position.set(0, 0.1, 0);
            yard.receiveShadow = true;
            scene.add(yard);
            
            // Generate items
            generateItems();
            
            // Generate bots
            generateBots();
        }

        function generateItems() {
            // Clear previous items
            itemMeshes.forEach(item => scene.remove(item));
            itemMeshes = [];
            gameState.items = [];
            
            const itemMaterials = {
                shovel: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
                uniform: new THREE.MeshStandardMaterial({ color: 0x0000ff }),
                idcard: new THREE.MeshStandardMaterial({ color: 0xffff00 }),
                cigarettes: new THREE.MeshStandardMaterial({ color: 0xf5f5f5 }),
                donut: new THREE.MeshStandardMaterial({ color: 0xff69b4 }),
                key: new THREE.MeshStandardMaterial({ color: 0xffd700 })
            };
            
            CONFIG.ITEM_TYPES.forEach((type, index) => {
                const x = Math.random() * 80 - 40;
                const z = Math.random() * 80 - 40;
                
                let geometry;
                switch(type) {
                    case 'shovel':
                        geometry = new THREE.BoxGeometry(0.5, 3, 0.2);
                        break;
                    case 'uniform':
                        geometry = new THREE.BoxGeometry(1, 2, 0.5);
                        break;
                    case 'cigarettes':
                        geometry = new THREE.BoxGeometry(0.3, 0.5, 0.1);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(0.5, 0.1, 0.8);
                }
                
                const item = new THREE.Mesh(geometry, itemMaterials[type]);
                item.position.set(x, 2, z);
                item.userData = { type: type, collected: false };
                item.castShadow = true;
                scene.add(item);
                itemMeshes.push(item);
                
                gameState.items.push({
                    type: type,
                    position: { x: x, y: 2, z: z },
                    collected: false
                });
            });
        }

        function generateBots() {
            // Clear previous bots
            botMeshes.forEach(bot => scene.remove(bot));
            botMeshes = [];
            gameState.bots = [];
            
            const guardMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            const inmateMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            
            // Create guard bots
            for (let i = 0; i < CONFIG.GUARD_COUNT; i++) {
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                const bot = new THREE.Mesh(geometry, guardMaterial);
                const x = Math.random() * 60 - 30;
                const z = Math.random() * 60 - 30;
                
                bot.position.set(x, 1, z);
                bot.castShadow = true;
                scene.add(bot);
                botMeshes.push(bot);
                
                gameState.bots.push({
                    type: 'guard',
                    position: { x: x, y: 1, z: z },
                    patrolPath: generatePatrolPath(),
                    patrolIndex: 0,
                    alertLevel: 0,
                    personality: Math.random() > 0.5 ? 'strict' : 'lazy'
                });
            }
            
            // Create inmate bots
            for (let i = 0; i < CONFIG.INMATE_BOT_COUNT; i++) {
                const geometry = new THREE.BoxGeometry(1, 2, 1);
                const bot = new THREE.Mesh(geometry, inmateMaterial);
                const x = Math.random() * 60 - 30;
                const z = Math.random() * 60 - 30;
                
                bot.position.set(x, 1, z);
                bot.castShadow = true;
                scene.add(bot);
                botMeshes.push(bot);
                
                gameState.bots.push({
                    type: 'inmate',
                    position: { x: x, y: 1, z: z },
                    routine: generateInmateRoutine(),
                    routineIndex: 0,
                    personality: ['lazy', 'violent', 'helpful'][Math.floor(Math.random() * 3)]
                });
            }
        }

        function generatePatrolPath() {
            const path = [];
            for (let i = 0; i < 5; i++) {
                path.push({
                    x: Math.random() * 80 - 40,
                    z: Math.random() * 80 - 40
                });
            }
            return path;
        }

        function generateInmateRoutine() {
            const activities = ['wander', 'eat', 'sleep', 'exercise', 'socialize'];
            const routine = [];
            for (let i = 0; i < 3; i++) {
                routine.push(activities[Math.floor(Math.random() * activities.length)]);
            }
            return routine;
        }

        // ============================================================================
        // PLAYER MANAGEMENT
        // ============================================================================
        function createPlayer(playerId, isLocal = false) {
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: isLocal ? 0xff0000 : 0x00ff00 
            });
            
            const player = new THREE.Mesh(geometry, material);
            player.position.set(isLocal ? -10 : 10, 1, 0);
            player.castShadow = true;
            scene.add(player);
            
            if (isLocal) {
                playerMesh = player;
                gameState.playerId = playerId;
            } else {
                otherPlayerMesh = player;
            }
            
            gameState.players[playerId] = {
                mesh: isLocal ? playerMesh : otherPlayerMesh,
                position: player.position,
                rotation: player.rotation,
                health: 100,
                contraband: 0,
                reputation: 0,
                inventory: [],
                isLocal: isLocal
            };
            
            return player;
        }

        function updatePlayer(playerId, data) {
            if (gameState.players[playerId]) {
                const player = gameState.players[playerId];
                if (player.mesh && !player.isLocal) {
                    player.mesh.position.set(data.x, data.y, data.z);
                    player.mesh.rotation.y = data.ry;
                }
                
                // Update UI
                if (playerId !== gameState.playerId) {
                    document.getElementById('health2').textContent = data.health || player.health;
                    document.getElementById('contraband2').textContent = data.contraband || player.contraband;
                    document.getElementById('rep2').textContent = data.reputation || player.reputation;
                }
            }
        }

        // ============================================================================
        // NETWORKING (WebRTC)
        // ============================================================================
        function hostGame() {
            gameState.isHost = true;
            gameState.playerId = 'player1_' + Math.random().toString(36).substr(2, 9);
            
            document.getElementById('connectionStatus').textContent = 'Status: Creating room...';
            
            // Create peer connection
            gameState.peer = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            
            // Set up data channel
            const dataChannel = gameState.peer.createDataChannel('game');
            setupDataChannel(dataChannel);
            
            // Create offer
            gameState.peer.createOffer()
                .then(offer => gameState.peer.setLocalDescription(offer))
                .then(() => {
                    const roomCode = generateRoomCode();
                    document.getElementById('displayCode').textContent = roomCode;
                    document.getElementById('roomInfo').style.display = 'block';
                    
                    // In a real implementation, you'd send this offer to a signaling server
                    // For simplicity, we'll store it in localStorage
                    localStorage.setItem('hostOffer', JSON.stringify({
                        sdp: gameState.peer.localDescription,
                        roomCode: roomCode
                    }));
                    
                    document.getElementById('connectionStatus').textContent = 'Status: Waiting for player...';
                })
                .catch(console.error);
            
            // Listen for ICE candidates
            gameState.peer.onicecandidate = event => {
                if (event.candidate) {
                    // Send candidate to other player
                }
            };
        }

        function joinGame() {
            document.getElementById('joinSection').style.display = 'block';
        }

        function connectToHost() {
            const roomCode = document.getElementById('roomCode').value;
            if (!roomCode) return;
            
            gameState.playerId = 'player2_' + Math.random().toString(36).substr(2, 9);
            
            // Get host offer from localStorage (simulated signaling)
            const hostData = localStorage.getItem('hostOffer');
            if (!hostData) {
                alert('Room not found!');
                return;
            }
            
            const { sdp, roomCode: storedCode } = JSON.parse(hostData);
            if (roomCode !== storedCode) {
                alert('Invalid room code!');
                return;
            }
            
            // Create peer connection
            gameState.peer = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            
            // Set up data channel listener
            gameState.peer.ondatachannel = event => {
                setupDataChannel(event.channel);
            };
            
            // Set remote description
            gameState.peer.setRemoteDescription(new RTCSessionDescription(sdp))
                .then(() => gameState.peer.createAnswer())
                .then(answer => gameState.peer.setLocalDescription(answer))
                .then(() => {
                    // Send answer back to host (simulated)
                    localStorage.setItem('playerAnswer', JSON.stringify({
                        sdp: gameState.peer.localDescription,
                        roomCode: roomCode
                    }));
                    
                    document.getElementById('connectionStatus').textContent = 'Status: Connecting...';
                    
                    // Notify host
                    setTimeout(() => {
                        startGame();
                    }, 1000);
                })
                .catch(console.error);
        }

        function setupDataChannel(channel) {
            gameState.connection = channel;
            
            channel.onopen = () => {
                console.log('Data channel opened');
                document.getElementById('connectionStatus').textContent = 'Status: Connected';
                startGame();
            };
            
            channel.onmessage = event => {
                const data = JSON.parse(event.data);
                handleNetworkMessage(data);
            };
            
            channel.onclose = () => {
                console.log('Data channel closed');
                document.getElementById('connectionStatus').textContent = 'Status: Disconnected';
            };
        }

        function sendNetworkMessage(type, data) {
            if (gameState.connection && gameState.connection.readyState === 'open') {
                const message = {
                    type: type,
                    sender: gameState.playerId,
                    data: data,
                    timestamp: Date.now()
                };
                gameState.connection.send(JSON.stringify(message));
            }
        }

        function handleNetworkMessage(message) {
            switch (message.type) {
                case 'playerUpdate':
                    updatePlayer(message.sender, message.data);
                    break;
                case 'itemCollected':
                    collectItemRemote(message.data);
                    break;
                case 'botUpdate':
                    updateBot(message.data);
                    break;
                case 'escapeAttempt':
                    handleEscapeAttempt(message.data);
                    break;
                case 'chat':
                    displayChatMessage(message.sender, message.data);
                    break;
            }
        }

        function generateRoomCode() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        // ============================================================================
        // GAME LOGIC
        // ============================================================================
        function startGame() {
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            
            initThreeJS();
            generatePrison();
            createPlayer(gameState.playerId, true);
            
            if (gameState.isHost) {
                // Host creates other player
                const otherPlayerId = 'player2_' + Math.random().toString(36).substr(2, 9);
                createPlayer(otherPlayerId, false);
            }
            
            gameState.gameStarted = true;
            
            // Show objective
            document.getElementById('objective').style.display = 'block';
            document.getElementById('objectiveText').textContent = 
                gameState.isHost ? 
                "Wait for your partner to connect, then explore the prison together!" :
                "Connected! Work with your partner to find escape items.";
            
            // Start game loop
            animate();
        }

        function animate() {
            if (!gameState.gameStarted) return;
            
            requestAnimationFrame(animate);
            
            // Update time of day
            gameState.timeOfDay = (gameState.timeOfDay + 0.0001) % 1;
            gameState.isNight = gameState.timeOfDay < 0.25 || gameState.timeOfDay > 0.75;
            
            // Update local player
            if (playerMesh) {
                updateLocalPlayer();
                controls.update();
            }
            
            // Update bots
            updateBots();
            
            // Check for item collisions
            checkItemCollisions();
            
            // Check for guard detection
            checkGuardDetection();
            
            renderer.render(scene, camera);
        }

        // ============================================================================
        // INPUT HANDLING
        // ============================================================================
        const keys = {};
        const mouse = { x: 0, y: 0 };

        window.addEventListener('keydown', event => {
            keys[event.key.toLowerCase()] = true;
            
            // Handle special keys
            switch(event.key.toLowerCase()) {
                case 'e':
                    attemptInteraction();
                    break;
                case 'f':
                    attemptFight();
                    break;
                case 'c':
                    toggleChat();
                    break;
                case 'm':
                    toggleEscapeMenu();
                    break;
                case 'tab':
                    toggleInventory();
                    event.preventDefault();
                    break;
                case 'enter':
                    if (document.getElementById('chat').style.display === 'block') {
                        sendChatMessage();
                    }
                    break;
            }
        });

        window.addEventListener('keyup', event => {
            keys[event.key.toLowerCase()] = false;
        });

        window.addEventListener('mousemove', event => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        function updateLocalPlayer() {
            if (!playerMesh) return;
            
            const speed = 0.2;
            const rotationSpeed = 0.05;
            
            // Movement
            if (keys['w']) playerMesh.position.z -= speed;
            if (keys['s']) playerMesh.position.z += speed;
            if (keys['a']) playerMesh.position.x -= speed;
            if (keys['d']) playerMesh.position.x += speed;
            if (keys[' ']) { // Space for jump
                playerMesh.position.y = Math.sin(Date.now() * 0.01) * 0.5 + 1.5;
            }
            
            // Rotation based on mouse
            playerMesh.rotation.y = mouse.x * Math.PI;
            
            // Boundary check
            playerMesh.position.x = Math.max(-45, Math.min(45, playerMesh.position.x));
            playerMesh.position.z = Math.max(-45, Math.min(45, playerMesh.position.z));
            
            // Send update to other player
            sendNetworkMessage('playerUpdate', {
                x: playerMesh.position.x,
                y: playerMesh.position.y,
                z: playerMesh.position.z,
                ry: playerMesh.rotation.y,
                health: gameState.players[gameState.playerId].health,
                contraband: gameState.players[gameState.playerId].contraband,
                reputation: gameState.players[gameState.playerId].reputation
            });
            
            // Update UI
            document.getElementById('health1').textContent = gameState.players[gameState.playerId].health;
            document.getElementById('contraband1').textContent = gameState.players[gameState.playerId].contraband;
            document.getElementById('rep1').textContent = gameState.players[gameState.playerId].reputation;
        }

        // ============================================================================
        // GAME MECHANICS
        // ============================================================================
        function attemptInteraction() {
            // Check for nearby items
            itemMeshes.forEach((item, index) => {
                if (!item.userData.collected && playerMesh) {
                    const distance = playerMesh.position.distanceTo(item.position);
                    if (distance < 3) {
                        collectItem(item.userData.type, index);
                    }
                }
            });
            
            // Check for bots to interact with
            gameState.bots.forEach((bot, index) => {
                if (playerMesh && bot.position) {
                    const dx = playerMesh.position.x - bot.position.x;
                    const dz = playerMesh.position.z - bot.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 3) {
                        if (bot.type === 'guard') {
                            // Bribe guard with donut
                            const player = gameState.players[gameState.playerId];
                            if (player.inventory.includes('donut')) {
                                player.reputation += 10;
                                player.inventory = player.inventory.filter(i => i !== 'donut');
                                updateInventoryUI();
                                showMessage('Guard bribed with donut! Reputation +10');
                            }
                        } else if (bot.type === 'inmate') {
                            // Trade with inmate
                            tradeWithInmate(bot.personality);
                        }
                    }
                }
            });
        }

        function collectItem(type, index) {
            const player = gameState.players[gameState.playerId];
            player.inventory.push(type);
            player.contraband++;
            
            // Mark item as collected
            itemMeshes[index].visible = false;
            itemMeshes[index].userData.collected = true;
            gameState.items[index].collected = true;
            
            // Notify other player
            sendNetworkMessage('itemCollected', { index: index, type: type });
            
            // Update UI
            updateInventoryUI();
            showMessage(`Collected: ${type.toUpperCase()}`);
            
            // Check for escape possibilities
            checkEscapeReadiness();
        }

        function collectItemRemote(data) {
            const { index, type } = data;
            if (itemMeshes[index]) {
                itemMeshes[index].visible = false;
                itemMeshes[index].userData.collected = true;
            }
            showMessage(`Partner collected: ${type.toUpperCase()}`);
        }

        function attemptFight() {
            // Check for nearby guard to fight
            gameState.bots.forEach((bot, index) => {
                if (bot.type === 'guard' && playerMesh) {
                    const dx = playerMesh.position.x - bot.position.x;
                    const dz = playerMesh.position.z - bot.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 4) {
                        // Fight logic
                        const player = gameState.players[gameState.playerId];
                        const success = Math.random() > 0.5;
                        
                        if (success) {
                            showMessage('Guard knocked out! (Temporarily)');
                            bot.alertLevel = 100; // High alert
                            player.reputation += 5;
                        } else {
                            showMessage('Fight failed! Health -20');
                            player.health -= 20;
                            if (player.health <= 0) {
                                sendToSolitary('Lost a fight with a guard');
                            }
                        }
                        
                        sendNetworkMessage('botUpdate', { index: index, alertLevel: bot.alertLevel });
                    }
                }
            });
        }

        function tradeWithInmate(personality) {
            const player = gameState.players[gameState.playerId];
            const tradeMessages = {
                lazy: "Zzz... come back later...",
                violent: "What you lookin' at?!",
                helpful: "Need something? I might know where to find it..."
            };
            
            showMessage(`Inmate: "${tradeMessages[personality]}"`);
            
            if (personality === 'helpful' && player.contraband > 0) {
                // Helpful inmate gives tip
                const tips = [
                    "Check behind the cafeteria for loose bricks.",
                    "Night guards are lazier than day guards.",
                    "The warden's office always has spare uniforms."
                ];
                showMessage(`Tip: ${tips[Math.floor(Math.random() * tips.length)]}`);
                player.reputation += 5;
            }
        }

        // ============================================================================
        // BOT AI
        // ============================================================================
        function updateBots() {
            gameState.bots.forEach((bot, index) => {
                if (!botMeshes[index]) return;
                
                if (bot.type === 'guard') {
                    updateGuardBot(bot, index);
                } else if (bot.type === 'inmate') {
                    updateInmateBot(bot, index);
                }
                
                // Update mesh position
                botMeshes[index].position.set(bot.position.x, bot.position.y, bot.position.z);
            });
        }

        function updateGuardBot(bot, index) {
            // Patrol movement
            if (bot.patrolPath && bot.patrolPath.length > 0) {
                const target = bot.patrolPath[bot.patrolIndex];
                const dx = target.x - bot.position.x;
                const dz = target.z - bot.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < 2) {
                    bot.patrolIndex = (bot.patrolIndex + 1) % bot.patrolPath.length;
                } else {
                    const speed = 0.05;
                    bot.position.x += (dx / distance) * speed;
                    bot.position.z += (dz / distance) * speed;
                }
            }
            
            // Decrease alert level over time
            if (bot.alertLevel > 0) {
                bot.alertLevel -= 0.1;
            }
        }

        function updateInmateBot(bot, index) {
            // Simple random wandering
            if (Math.random() < 0.02) {
                bot.position.x += (Math.random() - 0.5) * 2;
                bot.position.z += (Math.random() - 0.5) * 2;
                
                // Keep in bounds
                bot.position.x = Math.max(-45, Math.min(45, bot.position.x));
                bot.position.z = Math.max(-45, Math.min(45, bot.position.z));
            }
        }

        function checkGuardDetection() {
            const player = gameState.players[gameState.playerId];
            if (!playerMesh) return;
            
            gameState.bots.forEach((bot, index) => {
                if (bot.type === 'guard') {
                    const dx = playerMesh.position.x - bot.position.x;
                    const dz = playerMesh.position.z - bot.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // Check line of sight
                    if (distance < 10) {
                        const alertChance = 0.01 * (1 - distance/10);
                        if (Math.random() < alertChance) {
                            bot.alertLevel += 20;
                            showMessage('Guard spotted you!');
                            
                            if (bot.alertLevel > 50) {
                                // Guard chases player
                                const chaseSpeed = 0.1;
                                const chaseX = (dx / distance) * chaseSpeed;
                                const chaseZ = (dz / distance) * chaseSpeed;
                                
                                // Move guard toward player
                                bot.position.x += chaseX;
                                bot.position.z += chaseZ;
                                
                                if (distance < 2) {
                                    sendToSolitary('Caught by guard');
                                }
                            }
                        }
                    }
                }
            });
        }

        function checkItemCollisions() {
            itemMeshes.forEach((item, index) => {
                if (!item.userData.collected && playerMesh) {
                    const distance = playerMesh.position.distanceTo(item.position);
                    if (distance < 1.5) {
                        collectItem(item.userData.type, index);
                    }
                }
            });
        }

        // ============================================================================
        // ESCAPE MECHANICS
        // ============================================================================
        function checkEscapeReadiness() {
            const player = gameState.players[gameState.playerId];
            
            // Check if player has items for any escape method
            for (const [method, requirements] of Object.entries(CONFIG.ESCAPE_REQUIREMENTS)) {
                let hasRequirements = true;
                
                requirements.forEach(req => {
                    if (req.includes('reputation')) {
                        const repNeeded = parseInt(req.split('_')[1]);
                        if (player.reputation < repNeeded) hasRequirements = false;
                    } else if (req === 'clean_record') {
                        if (player.contraband > 0) hasRequirements = false;
                    } else {
                        if (!player.inventory.includes(req)) hasRequirements = false;
                    }
                });
                
                if (hasRequirements) {
                    showMessage(`Ready for ${method} escape! Press M to choose escape method.`);
                    return;
                }
            }
        }

        function toggleEscapeMenu() {
            const menu = document.getElementById('escapeMenu');
            menu.style.display = menu.style.display === 'grid' ? 'none' : 'grid';
        }

        function startEscape(method) {
            document.getElementById('escapeMenu').style.display = 'none';
            
            const player = gameState.players[gameState.playerId];
            const requirements = CONFIG.ESCAPE_REQUIREMENTS[method];
            let canEscape = true;
            
            // Check requirements
            requirements.forEach(req => {
                if (req.includes('reputation')) {
                    const repNeeded = parseInt(req.split('_')[1]);
                    if (player.reputation < repNeeded) canEscape = false;
                } else if (req === 'clean_record') {
                    if (player.contraband > 0) canEscape = false;
                } else {
                    if (!player.inventory.includes(req)) canEscape = false;
                }
            });
            
            if (!canEscape) {
                showMessage(`Missing requirements for ${method} escape!`);
                return;
            }
            
            // Start escape minigame
            showMessage(`Starting ${method} escape... Coordinate with partner!`);
            gameState.escapeInProgress = true;
            
            sendNetworkMessage('escapeAttempt', {
                method: method,
                playerId: gameState.playerId
            });
            
            // Simple escape success calculation
            setTimeout(() => {
                const success = Math.random() > 0.4; // 60% success rate
                
                if (success) {
                    escapeSuccess(method);
                } else {
                    escapeFailure(method);
                }
            }, 3000);
        }

        function escapeSuccess(method) {
            showMessage(`ESCAPE SUCCESSFUL via ${method.toUpperCase()}!`);
            const funnyMessages = [
                "You're free! Don't forget to write!",
                "The guards are still looking for you... in the wrong direction!",
                "Freedom never tasted so sweet!",
                "You made it! Now what's for dinner?"
            ];
            
            alert(`ðŸŽ‰ CONGRATULATIONS! ðŸŽ‰\nYou escaped via ${method}!\n${funnyMessages[Math.floor(Math.random() * funnyMessages.length)]}\n\nRefresh to play again.`);
        }

        function escapeFailure(method) {
            const failureReasons = {
                tunnel: "The tunnel collapsed!",
                disguise: "The uniform didn't fit!",
                riot: "Nobody showed up to the riot!",
                parole: "Paperwork got rejected!"
            };
            
            sendToSolitary(`${failureReasons[method]} ${method} escape failed.`);
        }

        function handleEscapeAttempt(data) {
            const { method, playerId } = data;
            showMessage(`Partner attempting ${method} escape...`);
            
            if (gameState.escapeInProgress) {
                // Both players attempting escape together increases chance
                showMessage("Coordinated escape attempt in progress!");
            }
        }

        // ============================================================================
        // UI FUNCTIONS
        // ============================================================================
        function showMessage(text) {
            // Create temporary message display
            const messageDiv = document.createElement('div');
            messageDiv.style.position = 'absolute';
            messageDiv.style.top = '50%';
            messageDiv.style.left = '50%';
            messageDiv.style.transform = 'translate(-50%, -50%)';
            messageDiv.style.background = 'rgba(0,0,0,0.8)';
            messageDiv.style.color = '#fff';
            messageDiv.style.padding = '10px 20px';
            messageDiv.style.borderRadius = '5px';
            messageDiv.style.zIndex = '1000';
            messageDiv.textContent = text;
            
            document.getElementById('gameContainer').appendChild(messageDiv);
            
            setTimeout(() => {
                document.getElementById('gameContainer').removeChild(messageDiv);
            }, 2000);
        }

        function updateInventoryUI() {
            const player = gameState.players[gameState.playerId];
            const inventoryDiv = document.getElementById('inventoryItems');
            inventoryDiv.innerHTML = '';
            
            player.inventory.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventory-item';
                itemDiv.innerHTML = `
                    <div class="inventory-icon" style="background: ${getItemColor(item)}"></div>
                    <span>${item.toUpperCase()}</span>
                `;
                inventoryDiv.appendChild(itemDiv);
            });
        }

        function getItemColor(item) {
            const colors = {
                shovel: '#8B4513',
                uniform: '#0000ff',
                idcard: '#ffff00',
                cigarettes: '#f5f5f5',
                donut: '#ff69b4',
                key: '#ffd700'
            };
            return colors[item] || '#ffffff';
        }

        function toggleInventory() {
            const inventory = document.getElementById('inventory');
            inventory.style.display = inventory.style.display === 'none' ? 'block' : 'none';
        }

        function toggleChat() {
            const chat = document.getElementById('chat');
            if (chat.style.display === 'block') {
                chat.style.display = 'none';
            } else {
                chat.style.display = 'block';
                document.getElementById('chatInput').focus();
            }
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (message) {
                displayChatMessage('You', message);
                sendNetworkMessage('chat', message);
                input.value = '';
            }
        }

        function displayChatMessage(sender, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function hideObjective() {
            document.getElementById('objective').style.display = 'none';
        }

        // ============================================================================
        // FAILURE SYSTEM
        // ============================================================================
        function sendToSolitary(reason) {
            gameState.gameStarted = false;
            
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('solitaryScreen').style.display = 'flex';
            
            document.getElementById('failReason').textContent = reason;
            
            const funnyMessages = [
                "The guards are enjoying donuts while you're in here...",
                "At least the rats are good company!",
                "Solitary: where dreams go to nap.",
                "You had time to think about your life choices... still a bad idea!",
                "The warden sends his regards... and a bill for damages.",
                "Even the cockroaches are judging you right now."
            ];
            
            document.getElementById('funnyMessage').textContent = 
                funnyMessages[Math.floor(Math.random() * funnyMessages.length)];
            
            // Animate solitary scene
            animateSolitaryScene();
        }

        function animateSolitaryScene() {
            const animationDiv = document.getElementById('solitaryAnimation');
            animationDiv.innerHTML = '';
            
            // Create cell bars
            for (let i = 0; i < 10; i++) {
                const bar = document.createElement('div');
                bar.className = 'inmate-cell';
                bar.style.left = (i * 30) + 'px';
                bar.style.top = '50px';
                animationDiv.appendChild(bar);
            }
            
            // Create guard patrol
            const guard = document.createElement('div');
            guard.className = 'guard-bot';
            guard.style.bottom = '20px';
            animationDiv.appendChild(guard);
            
            // Animate guard
            let direction = 1;
            setInterval(() => {
                const currentLeft = parseInt(guard.style.left) || 0;
                if (currentLeft > 250) direction = -1;
                if (currentLeft < 0) direction = 1;
                guard.style.left = (currentLeft + direction * 50) + 'px';
            }, 2000);
        }

        function retryGame() {
            // Reset game state
            gameState.gameStarted = false;
            gameState.escapeInProgress = false;
            gameState.timeOfDay = 0;
            
            // Clear scene
            if (scene) {
                while(scene.children.length > 0) { 
                    scene.remove(scene.children[0]); 
                }
            }
            
            // Return to lobby
            document.getElementById('solitaryScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'flex';
            
            // Change room code if host
            if (gameState.isHost) {
                const newCode = generateRoomCode();
                document.getElementById('displayCode').textContent = newCode;
                
                // Update stored offer
                const oldData = localStorage.getItem('hostOffer');
                if (oldData) {
                    const data = JSON.parse(oldData);
                    data.roomCode = newCode;
                    localStorage.setItem('hostOffer', JSON.stringify(data));
                }
            }
        }

        // ============================================================================
        // WINDOW RESIZE HANDLER
        // ============================================================================
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Cell Block Zero loaded');
            document.getElementById('connectionStatus').textContent = 'Status: Ready';
        });

        // ============================================================================
        // ERROR HANDLING
        // ============================================================================
        window.addEventListener('error', function(event) {
            console.error('Game error:', event.error);
            showMessage('Game error occurred. Check console.');
        });
    </script>
</body>
</html>
