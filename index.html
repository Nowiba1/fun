<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Riders: Delivery Chaos</title>
    
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        /* UI Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            padding: 20px;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: #ff6b6b;
            text-shadow: 3px 3px 0 #ff4757;
            text-align: center;
        }

        h2 {
            font-size: 2em;
            margin-bottom: 30px;
            color: #70a1ff;
        }

        .menu-container {
            max-width: 600px;
            width: 90%;
            background: rgba(30, 30, 60, 0.8);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff6b6b;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }

        button {
            padding: 15px 30px;
            font-size: 1.2em;
            background: linear-gradient(45deg, #ff6b6b, #ff4757);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 180px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
            background: linear-gradient(45deg, #ff4757, #ff3838);
        }

        button.secondary {
            background: linear-gradient(45deg, #3742fa, #5352ed);
        }

        button.secondary:hover {
            background: linear-gradient(45deg, #5352ed, #3742fa);
        }

        .input-group {
            margin: 20px 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #70a1ff;
            font-size: 1.1em;
        }

        input, select {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #3742fa;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .room-code {
            font-size: 2.5em;
            letter-spacing: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            color: #2ed573;
        }

        .player-list {
            list-style: none;
            margin: 20px 0;
        }

        .player-list li {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            align-items: center;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            min-width: 250px;
            z-index: 10;
        }

        .hud-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }

        .hud-label {
            color: #70a1ff;
            font-weight: bold;
        }

        .hud-value {
            color: #2ed573;
            font-weight: bold;
            font-size: 1.1em;
        }

        #speedometer {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 150px;
            height: 150px;
        }

        .speed-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 3px;
            height: 60px;
            background: #ff4757;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(0deg);
            transition: transform 0.1s;
        }

        .speed-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            font-size: 0.8em;
            color: white;
        }

        .products-grid {
            display: grid;
            grid-template-columns: repeat(5, 30px);
            gap: 5px;
            margin-top: 10px;
        }

        .product-item {
            width: 30px;
            height: 30px;
            background: #2ed573;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .product-item.damaged {
            background: #ff4757;
            transform: scale(0.8);
        }

        /* Loading Screen */
        #loadingScreen {
            background: #1a1a2e;
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 30px 0;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff4757);
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }

        .loading-text {
            margin-top: 20px;
            color: #70a1ff;
        }

        /* Controls Info */
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #3742fa;
            color: white;
            max-width: 300px;
        }

        .controls-info h3 {
            color: #70a1ff;
            margin-bottom: 10px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .control-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Loading Screen -->
        <div id="loadingScreen" class="screen">
            <h1>Cart Riders</h1>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
            <div class="loading-text" id="loadingText">Loading assets...</div>
        </div>

        <!-- Start Menu -->
        <div id="startMenu" class="screen hidden">
            <div class="menu-container">
                <h1>Delivery Chaos</h1>
                
                <div class="button-group">
                    <button id="playSolo">Solo Delivery</button>
                    <button id="multiplayer" class="secondary">Multiplayer Race</button>
                    <button id="settings">Settings</button>
                </div>

                <div class="input-group">
                    <label for="botCount">Bot Count (0-4):</label>
                    <input type="range" id="botCount" min="0" max="4" value="2">
                    <span id="botCountDisplay">2</span>
                </div>

                <div class="controls-info">
                    <h3>Controls</h3>
                    <div class="control-item">
                        <span>Move:</span>
                        <span class="control-key">WASD / Arrows</span>
                    </div>
                    <div class="control-item">
                        <span>Boost:</span>
                        <span class="control-key">SPACE / A Button</span>
                    </div>
                    <div class="control-item">
                        <span>Pause:</span>
                        <span class="control-key">ESC / Start</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Multiplayer Lobby -->
        <div id="multiplayerLobby" class="screen hidden">
            <div class="menu-container">
                <h2>Multiplayer Lobby</h2>
                
                <div class="button-group">
                    <button id="createRoom">Create Room</button>
                    <button id="joinRoom" class="secondary">Join Room</button>
                    <button id="backToMenu">Back</button>
                </div>

                <div id="roomCodeSection" class="hidden">
                    <div class="room-code" id="roomCode">----</div>
                    <p>Share this code with other players!</p>
                    <div id="playerList">
                        <h3>Players (1/8):</h3>
                        <ul class="player-list" id="playerListItems">
                            <li>
                                <div class="player-color" style="background: #ff4757;"></div>
                                <span>Host (You)</span>
                            </li>
                        </ul>
                    </div>
                    <button id="startGame">Start Game</button>
                </div>

                <div id="joinSection" class="hidden">
                    <div class="input-group">
                        <label for="roomCodeInput">Enter Room Code:</label>
                        <input type="text" id="roomCodeInput" maxlength="4" placeholder="ABCD">
                    </div>
                    <button id="connectToRoom">Connect</button>
                </div>
            </div>
        </div>

        <!-- Game HUD -->
        <div id="hud" class="hidden">
            <div class="hud-item">
                <span class="hud-label">Speed:</span>
                <span class="hud-value" id="speedValue">0 km/h</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Products:</span>
                <span class="hud-value" id="productCount">15/15</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Profit:</span>
                <span class="hud-value" id="profitValue">$0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Distance:</span>
                <span class="hud-value" id="distanceValue">1000m</span>
            </div>
            <div class="products-grid" id="productsGrid"></div>
        </div>

        <!-- Speedometer -->
        <div id="speedometer" class="hidden">
            <div class="speed-labels">
                <span style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%);">0</span>
                <span style="position: absolute; top: 50%; right: 10px; transform: translateY(-50%);">50</span>
                <span style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);">100</span>
                <span style="position: absolute; top: 50%; left: 10px; transform: translateY(-50%);">-50</span>
            </div>
            <div class="speed-needle" id="speedNeedle"></div>
        </div>

        <!-- Pause Menu -->
        <div id="pauseMenu" class="screen hidden">
            <div class="menu-container">
                <h2>Game Paused</h2>
                <div class="button-group">
                    <button id="resumeGame">Resume</button>
                    <button id="restartGame">Restart</button>
                    <button id="quitToMenu">Quit to Menu</button>
                </div>
            </div>
        </div>

        <!-- End Screen -->
        <div id="endScreen" class="screen hidden">
            <div class="menu-container">
                <h1 id="endTitle">Delivery Complete!</h1>
                <div style="font-size: 1.5em; margin: 20px 0;">
                    <div>Final Profit: <span id="finalProfit" style="color: #2ed573;">$0</span></div>
                    <div>Products Delivered: <span id="deliveredCount" style="color: #2ed573;">0/15</span></div>
                    <div>Distance Traveled: <span id="totalDistance" style="color: #70a1ff;">0m</span></div>
                </div>
                <div class="button-group">
                    <button id="playAgain">Play Again</button>
                    <button id="endToMenu">Main Menu</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Wait for Three.js to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Check if THREE is available
            if (typeof THREE === 'undefined') {
                console.error('THREE.js not loaded!');
                document.getElementById('loadingText').textContent = 'Error: THREE.js failed to load';
                return;
            }

            // Check if GLTFLoader is available
            if (typeof THREE.GLTFLoader === 'undefined') {
                console.error('GLTFLoader not loaded!');
                document.getElementById('loadingText').textContent = 'Error: GLTFLoader failed to load';
                return;
            }

            // Start the game
            window.game = new CartRidersGame();
        });

        // Main Game Class
        class CartRidersGame {
            constructor() {
                // Three.js setup
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                // Game objects
                this.carts = [];
                this.players = [];
                this.bots = [];
                this.obstacles = [];
                this.roadSegments = [];
                
                // Game state
                this.gameState = 'LOADING'; // LOADING, MENU, LOBBY, PLAYING, PAUSED, ENDED
                this.isMultiplayer = false;
                this.botCount = 2;
                
                // Physics
                this.gravity = 9.8;
                this.physicsObjects = [];
                
                // UI elements
                this.uiElements = {};
                this.bindUIElements();
                
                // Input
                this.keys = {};
                this.gamepads = {};
                this.input = {
                    steering: 0,
                    throttle: 0,
                    brake: 0,
                    boost: false
                };
                
                // Asset loading
                this.assets = {
                    models: {},
                    sounds: {},
                    textures: {}
                };
                
                // WebRTC
                this.peer = null;
                this.connections = {};
                this.roomCode = '';
                
                // Game variables
                this.playerCount = 0;
                this.maxProducts = 15;
                this.roadLength = 1000;
                this.currentSegment = 0;
                this.lastTime = 0;
                
                // Start initialization
                this.init();
            }

            bindUIElements() {
                // Screens
                this.uiElements.loadingScreen = document.getElementById('loadingScreen');
                this.uiElements.startMenu = document.getElementById('startMenu');
                this.uiElements.multiplayerLobby = document.getElementById('multiplayerLobby');
                this.uiElements.hud = document.getElementById('hud');
                this.uiElements.pauseMenu = document.getElementById('pauseMenu');
                this.uiElements.endScreen = document.getElementById('endScreen');
                
                // Buttons
                this.uiElements.playSolo = document.getElementById('playSolo');
                this.uiElements.multiplayer = document.getElementById('multiplayer');
                this.uiElements.createRoom = document.getElementById('createRoom');
                this.uiElements.joinRoom = document.getElementById('joinRoom');
                this.uiElements.backToMenu = document.getElementById('backToMenu');
                this.uiElements.startGame = document.getElementById('startGame');
                this.uiElements.connectToRoom = document.getElementById('connectToRoom');
                this.uiElements.resumeGame = document.getElementById('resumeGame');
                this.uiElements.restartGame = document.getElementById('restartGame');
                this.uiElements.quitToMenu = document.getElementById('quitToMenu');
                this.uiElements.playAgain = document.getElementById('playAgain');
                this.uiElements.endToMenu = document.getElementById('endToMenu');
                
                // Inputs
                this.uiElements.botCount = document.getElementById('botCount');
                this.uiElements.botCountDisplay = document.getElementById('botCountDisplay');
                this.uiElements.roomCode = document.getElementById('roomCode');
                this.uiElements.roomCodeInput = document.getElementById('roomCodeInput');
                this.uiElements.roomCodeSection = document.getElementById('roomCodeSection');
                this.uiElements.joinSection = document.getElementById('joinSection');
                this.uiElements.playerListItems = document.getElementById('playerListItems');
                
                // HUD
                this.uiElements.speedValue = document.getElementById('speedValue');
                this.uiElements.productCount = document.getElementById('productCount');
                this.uiElements.profitValue = document.getElementById('profitValue');
                this.uiElements.distanceValue = document.getElementById('distanceValue');
                this.uiElements.productsGrid = document.getElementById('productsGrid');
                this.uiElements.speedNeedle = document.getElementById('speedNeedle');
                
                // End screen
                this.uiElements.endTitle = document.getElementById('endTitle');
                this.uiElements.finalProfit = document.getElementById('finalProfit');
                this.uiElements.deliveredCount = document.getElementById('deliveredCount');
                this.uiElements.totalDistance = document.getElementById('totalDistance');
            }

            async init() {
                // Initialize Three.js
                this.initThreeJS();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Load assets
                await this.loadAssets();
                
                // Generate initial road
                this.generateRoad();
                
                // Show start menu
                this.showScreen('startMenu');
                
                // Start game loop
                this.gameLoop();
            }

            initThreeJS() {
                console.log('Initializing Three.js...');
                
                const canvas = document.getElementById('gameCanvas');
                
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x1a1a2e, 10, 100);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
                
                // Add ground
                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2d3436,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.1;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                console.log('Three.js initialized successfully');
            }

            setupEventListeners() {
                // Keyboard input
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    // Handle pause
                    if (e.key === 'Escape') {
                        this.togglePause();
                    }
                    
                    // Prevent spacebar from scrolling
                    if (e.key === ' ') {
                        e.preventDefault();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Gamepad input
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad.id);
                    this.gamepads[e.gamepad.index] = e.gamepad;
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Gamepad disconnected:', e.gamepad.id);
                    delete this.gamepads[e.gamepad.index];
                });
                
                // UI Button events
                this.uiElements.playSolo.addEventListener('click', () => this.startSoloGame());
                this.uiElements.multiplayer.addEventListener('click', () => this.showScreen('multiplayerLobby'));
                this.uiElements.createRoom.addEventListener('click', () => this.createMultiplayerRoom());
                this.uiElements.joinRoom.addEventListener('click', () => this.showJoinSection());
                this.uiElements.backToMenu.addEventListener('click', () => this.showScreen('startMenu'));
                this.uiElements.startGame.addEventListener('click', () => this.startMultiplayerGame());
                this.uiElements.connectToRoom.addEventListener('click', () => this.joinMultiplayerRoom());
                this.uiElements.resumeGame.addEventListener('click', () => this.togglePause());
                this.uiElements.restartGame.addEventListener('click', () => this.restartGame());
                this.uiElements.quitToMenu.addEventListener('click', () => this.quitToMenu());
                this.uiElements.playAgain.addEventListener('click', () => this.restartGame());
                this.uiElements.endToMenu.addEventListener('click', () => this.quitToMenu());
                
                // Bot count slider
                this.uiElements.botCount.addEventListener('input', (e) => {
                    this.botCount = parseInt(e.target.value);
                    this.uiElements.botCountDisplay.textContent = this.botCount;
                });
            }

            async loadAssets() {
                console.log('Loading assets...');
                let progress = 0;
                
                // Create placeholder models (in real game, load from .glb files)
                const modelTypes = ['cart', 'player', 'crate', 'lamp', 'house'];
                
                for (let i = 0; i < modelTypes.length; i++) {
                    await this.createPlaceholderModel(modelTypes[i]);
                    progress = Math.floor((i + 1) / modelTypes.length * 100);
                    this.updateLoadingProgress(progress);
                }
                
                // Create placeholder sounds
                this.createPlaceholderSounds();
                
                // Complete loading
                this.updateLoadingProgress(100);
                console.log('Assets loaded successfully');
            }

            createPlaceholderModel(type) {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        let geometry, material, mesh;
                        
                        switch(type) {
                            case 'cart':
                                // Shopping cart
                                const cartGroup = new THREE.Group();
                                
                                // Cart body
                                const cartBody = new THREE.BoxGeometry(1.8, 0.8, 3);
                                const cartMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0xff4757,
                                    metalness: 0.6,
                                    roughness: 0.4
                                });
                                const body = new THREE.Mesh(cartBody, cartMaterial);
                                body.position.y = 0.4;
                                body.castShadow = true;
                                cartGroup.add(body);
                                
                                // Cart handle
                                const handleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5);
                                const handle = new THREE.Mesh(handleGeometry, cartMaterial);
                                handle.position.set(0, 1.2, -1);
                                handle.rotation.z = Math.PI / 2;
                                handle.castShadow = true;
                                cartGroup.add(handle);
                                
                                // Wheels
                                const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1);
                                const wheelMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0x333333,
                                    metalness: 0.8,
                                    roughness: 0.2
                                });
                                
                                const positions = [
                                    [0.8, 0.2, 1],
                                    [-0.8, 0.2, 1],
                                    [0.8, 0.2, -1],
                                    [-0.8, 0.2, -1]
                                ];
                                
                                positions.forEach(pos => {
                                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                                    wheel.position.set(pos[0], pos[1], pos[2]);
                                    wheel.rotation.z = Math.PI / 2;
                                    wheel.castShadow = true;
                                    cartGroup.add(wheel);
                                });
                                
                                this.assets.models.cart = { scene: cartGroup };
                                break;
                                
                            case 'player':
                                // Player character
                                const playerGroup = new THREE.Group();
                                
                                // Body
                                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1);
                                const playerMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0x70a1ff,
                                    metalness: 0.2,
                                    roughness: 0.6
                                });
                                const playerBody = new THREE.Mesh(bodyGeometry, playerMaterial);
                                playerBody.position.y = 0.5;
                                playerBody.castShadow = true;
                                playerGroup.add(playerBody);
                                
                                // Head
                                const headGeometry = new THREE.SphereGeometry(0.2);
                                const head = new THREE.Mesh(headGeometry, playerMaterial);
                                head.position.y = 1.2;
                                head.castShadow = true;
                                playerGroup.add(head);
                                
                                this.assets.models.player = { scene: playerGroup };
                                break;
                                
                            case 'crate':
                                // Crate
                                const crateGeometry = new THREE.BoxGeometry(1, 1, 1);
                                const crateMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0x2ed573,
                                    metalness: 0.1,
                                    roughness: 0.8
                                });
                                const crate = new THREE.Mesh(crateGeometry, crateMaterial);
                                crate.castShadow = true;
                                crate.receiveShadow = true;
                                this.assets.models.crate = { scene: crate };
                                break;
                                
                            case 'lamp':
                                // Street lamp
                                const lampGroup = new THREE.Group();
                                
                                // Pole
                                const poleGeometry = new THREE.CylinderGeometry(0.1, 0.15, 4);
                                const poleMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0xaaaaaa,
                                    metalness: 0.7,
                                    roughness: 0.3
                                });
                                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                                pole.castShadow = true;
                                lampGroup.add(pole);
                                
                                // Light
                                const lightGeometry = new THREE.SphereGeometry(0.3);
                                const lightMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0xffdd59,
                                    emissive: 0xffdd59,
                                    emissiveIntensity: 0.5
                                });
                                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                                light.position.y = 2.2;
                                light.castShadow = true;
                                lampGroup.add(light);
                                
                                // Add actual light source
                                const pointLight = new THREE.PointLight(0xffdd59, 1, 10);
                                pointLight.position.y = 2.2;
                                lampGroup.add(pointLight);
                                
                                this.assets.models.lamp = { scene: lampGroup };
                                break;
                                
                            case 'house':
                                // Building
                                const houseGroup = new THREE.Group();
                                
                                // Main building
                                const houseGeometry = new THREE.BoxGeometry(4, 3, 4);
                                const houseMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0x3742fa,
                                    metalness: 0.1,
                                    roughness: 0.7
                                });
                                const house = new THREE.Mesh(houseGeometry, houseMaterial);
                                house.position.y = 1.5;
                                house.castShadow = true;
                                house.receiveShadow = true;
                                houseGroup.add(house);
                                
                                // Roof
                                const roofGeometry = new THREE.ConeGeometry(3, 2, 4);
                                const roofMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0xff6b6b,
                                    metalness: 0.2,
                                    roughness: 0.8
                                });
                                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                                roof.position.y = 3.5;
                                roof.rotation.y = Math.PI / 4;
                                roof.castShadow = true;
                                houseGroup.add(roof);
                                
                                // Windows
                                const windowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
                                const windowMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0xffff00,
                                    emissive: 0xffff00,
                                    emissiveIntensity: 0.3
                                });
                                
                                const windowPositions = [
                                    [1.1, 1.5, 2.01],
                                    [-1.1, 1.5, 2.01],
                                    [1.1, 1.5, -2.01],
                                    [-1.1, 1.5, -2.01],
                                    [2.01, 1.5, 1.1],
                                    [2.01, 1.5, -1.1]
                                ];
                                
                                windowPositions.forEach(pos => {
                                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                                    window.position.set(pos[0], pos[1], pos[2]);
                                    if (Math.abs(pos[0]) > 2) {
                                        window.rotation.y = Math.PI / 2;
                                    }
                                    houseGroup.add(window);
                                });
                                
                                this.assets.models.house = { scene: houseGroup };
                                break;
                        }
                        
                        resolve();
                    }, 100);
                });
            }

            createPlaceholderSounds() {
                // Create placeholder audio using Web Audio API
                this.assets.sounds = {
                    crash: { play: () => this.playSoundEffect(200, 0.3, 0.2) },
                    slap: { play: () => this.playSoundEffect(150, 0.2, 0.1) },
                    product_destroyed: { play: () => this.playSoundEffect(100, 0.4, 0.3) }
                };
            }

            playSoundEffect(frequency, duration, volume) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sawtooth';
                    
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported or blocked');
                }
            }

            updateLoadingProgress(percent) {
                const progressBar = document.getElementById('loadingProgress');
                const loadingText = document.getElementById('loadingText');
                
                progressBar.style.width = percent + '%';
                
                if (percent < 20) {
                    loadingText.textContent = 'Initializing game engine...';
                } else if (percent < 40) {
                    loadingText.textContent = 'Loading 3D models...';
                } else if (percent < 60) {
                    loadingText.textContent = 'Setting up physics...';
                } else if (percent < 80) {
                    loadingText.textContent = 'Creating game world...';
                } else if (percent < 100) {
                    loadingText.textContent = 'Finalizing...';
                } else {
                    loadingText.textContent = 'Ready to play!';
                }
            }

            showScreen(screenName) {
                // Hide all screens
                Object.values(this.uiElements).forEach(element => {
                    if (element && element.classList && element.classList.contains('screen')) {
                        element.classList.add('hidden');
                    }
                });
                
                // Show requested screen
                if (this.uiElements[screenName]) {
                    this.uiElements[screenName].classList.remove('hidden');
                }
                
                // Update game state
                switch(screenName) {
                    case 'startMenu':
                        this.gameState = 'MENU';
                        break;
                    case 'multiplayerLobby':
                        this.gameState = 'LOBBY';
                        break;
                    case 'playing':
                        this.gameState = 'PLAYING';
                        this.uiElements.hud.classList.remove('hidden');
                        document.getElementById('speedometer').classList.remove('hidden');
                        break;
                    case 'pauseMenu':
                        this.gameState = 'PAUSED';
                        break;
                    case 'endScreen':
                        this.gameState = 'ENDED';
                        break;
                }
            }

            generateRoad() {
                console.log('Generating road...');
                
                // Clear existing road
                this.roadSegments.forEach(segment => {
                    if (segment && segment.parent) {
                        this.scene.remove(segment);
                    }
                });
                this.roadSegments = [];
                
                // Create road segments
                const roadWidth = 10;
                const segmentLength = 50;
                const segmentCount = 20; // Semi-endless - we'll recycle segments
                
                for (let i = 0; i < segmentCount; i++) {
                    const geometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0x333333,
                        side: THREE.DoubleSide,
                        roughness: 0.8
                    });
                    
                    const road = new THREE.Mesh(geometry, material);
                    road.rotation.x = -Math.PI / 2;
                    road.position.z = -i * segmentLength;
                    road.receiveShadow = true;
                    
                    this.scene.add(road);
                    this.roadSegments.push(road);
                    
                    // Add road markings
                    this.addRoadMarkings(road.position.z, roadWidth, segmentLength);
                    
                    // Randomly add obstacles (skip first few segments)
                    if (i > 3 && Math.random() > 0.4) {
                        this.addObstacles(road.position.z, roadWidth, segmentLength);
                    }
                }
                
                console.log('Road generated with', segmentCount, 'segments');
            }

            addRoadMarkings(zPos, roadWidth, segmentLength) {
                // Center line (dashed)
                const dashLength = 3;
                const gapLength = 2;
                const dashCount = Math.floor(segmentLength / (dashLength + gapLength));
                
                for (let i = 0; i < dashCount; i++) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, dashLength);
                    const lineMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffff00,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.3
                    });
                    
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    const zOffset = (i * (dashLength + gapLength)) - segmentLength/2 + dashLength/2;
                    line.position.set(0, 0.01, zPos + zOffset);
                    this.scene.add(line);
                }
                
                // Side lines
                const sideLineGeometry = new THREE.PlaneGeometry(0.5, segmentLength);
                const sideLineMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.2
                });
                
                const sideLine = new THREE.Mesh(sideLineGeometry, sideLineMaterial);
                sideLine.rotation.x = -Math.PI / 2;
                sideLine.position.set(-roadWidth/2, 0.01, zPos);
                this.scene.add(sideLine);
                
                const sideLine2 = sideLine.clone();
                sideLine2.position.set(roadWidth/2, 0.01, zPos);
                this.scene.add(sideLine2);
            }

            addObstacles(zPos, roadWidth, segmentLength) {
                const obstacleTypes = ['crate', 'lamp', 'house'];
                const obstacleCount = Math.floor(Math.random() * 3) + 1;
                
                for (let i = 0; i < obstacleCount; i++) {
                    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    const obstacle = this.assets.models[type].scene.clone();
                    
                    // Position obstacle on sides of road
                    const side = Math.random() > 0.5 ? 1 : -1;
                    const xPos = (roadWidth/2 + 2.5) * side;
                    const zOffset = (Math.random() - 0.5) * segmentLength * 0.8;
                    
                    obstacle.position.set(xPos, 0, zPos + zOffset);
                    
                    // Adjust y position based on type
                    if (type === 'crate') {
                        obstacle.position.y = 0.5;
                    } else if (type === 'lamp') {
                        obstacle.position.y = 0;
                    } else if (type === 'house') {
                        obstacle.position.y = 0;
                        obstacle.scale.setScalar(0.8);
                    }
                    
                    // Add physics properties
                    obstacle.userData = {
                        type: type,
                        damage: type === 'crate' ? 20 : type === 'lamp' ? 10 : 30,
                        collided: false
                    };
                    
                    // Make obstacles cast shadows
                    obstacle.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    this.scene.add(obstacle);
                    this.obstacles.push(obstacle);
                }
            }

            startSoloGame() {
                console.log('Starting solo game with', this.botCount, 'bots');
                this.isMultiplayer = false;
                
                // Clear any existing players/bots
                this.resetGameObjects();
                
                // Create player
                this.createPlayer(0, false);
                
                // Create bots
                for (let i = 0; i < this.botCount; i++) {
                    this.createBot(i);
                }
                
                // Start game
                this.startGame();
            }

            createMultiplayerRoom() {
                // Generate room code
                this.roomCode = Math.random().toString(36).substring(2, 6).toUpperCase();
                this.uiElements.roomCode.textContent = this.roomCode;
                
                // Show room code section
                this.uiElements.roomCodeSection.classList.remove('hidden');
                
                // Initialize WebRTC (placeholder)
                console.log('Creating multiplayer room:', this.roomCode);
                
                // For demo, simulate host player
                this.createPlayer(0, true);
                this.updatePlayerList();
            }

            showJoinSection() {
                this.uiElements.joinSection.classList.remove('hidden');
            }

            joinMultiplayerRoom() {
                const code = this.uiElements.roomCodeInput.value.toUpperCase();
                if (code.length === 4) {
                    this.roomCode = code;
                    this.uiElements.roomCode.textContent = code;
                    this.uiElements.roomCodeSection.classList.remove('hidden');
                    this.uiElements.joinSection.classList.add('hidden');
                    
                    console.log('Joining room:', code);
                    // WebRTC connection would go here
                } else {
                    alert('Please enter a 4-character room code');
                }
            }

            updatePlayerList() {
                this.uiElements.playerListItems.innerHTML = '';
                
                // Add host
                const hostItem = document.createElement('li');
                hostItem.innerHTML = `
                    <div class="player-color" style="background: #ff4757;"></div>
                    <span>Host (You)</span>
                `;
                this.uiElements.playerListItems.appendChild(hostItem);
            }

            startMultiplayerGame() {
                console.log('Starting multiplayer game');
                this.isMultiplayer = true;
                this.startGame();
            }

            startGame() {
                // Reset game state
                this.currentSegment = 0;
                this.lastTime = performance.now();
                
                // Show game HUD
                this.showScreen('playing');
                
                // Initialize products display
                this.updateProductsDisplay();
                
                // Focus canvas for keyboard input
                document.getElementById('gameCanvas').focus();
                
                console.log('Game started!');
            }

            createPlayer(id, isMultiplayer) {
                if (!this.assets.models.cart) {
                    console.error('Cart model not loaded!');
                    return null;
                }
                
                const cart = this.assets.models.cart.scene.clone();
                const player = this.assets.models.player.scene.clone();
                
                // Position player in cart
                player.position.set(0, 0.8, 0);
                cart.add(player);
                
                // Set initial position
                const startX = (id % 4) * 3 - 4.5;
                cart.position.set(startX, 0.5, 0);
                cart.rotation.y = Math.PI;
                
                // Make cart cast shadows
                cart.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Add to scene
                this.scene.add(cart);
                
                // Store player data
                const playerData = {
                    id: id,
                    cart: cart,
                    player: player,
                    speed: 0,
                    maxSpeed: 40,
                    acceleration: 0.8,
                    braking: 1.5,
                    steering: 0.05,
                    health: 100,
                    products: this.maxProducts,
                    profit: 0,
                    distance: 0,
                    boostCooldown: 0,
                    isBot: false,
                    isMultiplayer: isMultiplayer,
                    color: id === 0 ? 0xff4757 : 0x70a1ff
                };
                
                // Set cart color
                cart.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.color.setHex(playerData.color);
                    }
                });
                
                this.carts.push(cart);
                this.players.push(playerData);
                
                console.log('Player created:', playerData);
                
                return playerData;
            }

            createBot(id) {
                const playerData = this.createPlayer(id + 1, false);
                if (!playerData) return;
                
                playerData.isBot = true;
                playerData.color = 0xff6b6b;
                playerData.acceleration = 0.6 + Math.random() * 0.2; // Slightly randomize bot stats
                playerData.maxSpeed = 35 + Math.random() * 10;
                
                // Set bot cart color
                playerData.cart.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.color.setHex(playerData.color);
                    }
                });
                
                this.bots.push(playerData);
                console.log('Bot created:', playerData);
            }

            processInput() {
                // Reset input
                this.input.steering = 0;
                this.input.throttle = 0;
                this.input.brake = 0;
                this.input.boost = false;
                
                // Keyboard input
                if (this.keys['w'] || this.keys['arrowup']) this.input.throttle = 1;
                if (this.keys['s'] || this.keys['arrowdown']) this.input.brake = 1;
                if (this.keys['a'] || this.keys['arrowleft']) this.input.steering = 1;
                if (this.keys['d'] || this.keys['arrowright']) this.input.steering = -1;
                if (this.keys[' ']) this.input.boost = true;
                
                // Gamepad input
                for (const index in this.gamepads) {
                    const gamepad = navigator.getGamepads()[index];
                    if (!gamepad) continue;
                    
                    // Left stick for steering
                    if (Math.abs(gamepad.axes[0]) > 0.1) {
                        this.input.steering = -gamepad.axes[0];
                    }
                    
                    // Right trigger for throttle (axes[2] on some gamepads, buttons[7] on others)
                    if (gamepad.axes.length > 2) {
                        const triggerValue = (gamepad.axes[2] + 1) / 2;
                        if (triggerValue > 0.1) this.input.throttle = triggerValue;
                    }
                    
                    // Left trigger for brake
                    if (gamepad.axes.length > 5) {
                        const brakeValue = (gamepad.axes[5] + 1) / 2;
                        if (brakeValue > 0.1) this.input.brake = brakeValue;
                    }
                    
                    // A button (button 0) for boost
                    if (gamepad.buttons[0]?.pressed) {
                        this.input.boost = true;
                    }
                    
                    // Start button (button 9) for pause
                    if (gamepad.buttons[9]?.pressed) {
                        this.togglePause();
                    }
                }
            }

            updatePlayer(player, deltaTime) {
                if (!player || !player.cart) return;
                
                // Update boost cooldown
                if (player.boostCooldown > 0) {
                    player.boostCooldown -= deltaTime;
                }
                
                if (!player.isBot) {
                    // Human player input
                    const acceleration = this.input.acceleration || 0.8;
                    const steering = this.input.steering || 0;
                    const throttle = this.input.throttle || 0;
                    const brake = this.input.brake || 0;
                    const boost = this.input.boost || false;
                    
                    // Apply boost
                    let boostMultiplier = 1;
                    if (boost && player.boostCooldown <= 0) {
                        boostMultiplier = 2.0;
                        player.boostCooldown = 3; // 3 second cooldown
                    }
                    
                    // Calculate speed
                    if (throttle > 0 && player.speed < player.maxSpeed) {
                        player.speed += acceleration * throttle * deltaTime * 60 * boostMultiplier;
                    }
                    
                    if (brake > 0 && player.speed > -player.maxSpeed * 0.5) {
                        player.speed -= acceleration * player.braking * brake * deltaTime * 60;
                    }
                    
                    // Apply friction
                    if (throttle === 0 && brake === 0) {
                        player.speed *= Math.pow(0.98, deltaTime * 60);
                    }
                    
                    // Apply steering (more effective at higher speeds)
                    const steeringEffect = Math.min(Math.abs(player.speed) / 10, 1);
                    if (Math.abs(player.speed) > 1) {
                        player.cart.rotation.y += steering * player.steering * steeringEffect * deltaTime * 60;
                    }
                    
                    // Move cart
                    const direction = new THREE.Vector3(0, 0, 1);
                    direction.applyQuaternion(player.cart.quaternion);
                    player.cart.position.add(direction.multiplyScalar(player.speed * deltaTime));
                    
                    // Keep cart on ground with slight bounce
                    const targetY = 0.5 + Math.sin(Date.now() * 0.01) * 0.05 * Math.abs(player.speed) / player.maxSpeed;
                    player.cart.position.y = targetY;
                    
                    // Update distance
                    player.distance += Math.abs(player.speed) * deltaTime;
                    
                    // Update camera to follow player
                    if (this.players[0] === player) {
                        this.updateCamera(player);
                    }
                    
                    // Update HUD
                    this.updateHUD(player);
                } else {
                    // Bot AI
                    this.updateBotAI(player, deltaTime);
                }
                
                // Check collisions
                this.checkCollisions(player);
                
                // Update road segments (semi-endless)
                this.updateRoadSegments(player);
                
                // Add slight random movement for visual appeal
                if (Math.abs(player.speed) > 5) {
                    const wobble = Math.sin(Date.now() * 0.005 + player.id) * 0.02 * (player.speed / player.maxSpeed);
                    player.cart.rotation.z = wobble;
                }
            }

            updateBotAI(bot, deltaTime) {
                // Simple bot AI: chase nearest player or drive forward
                let targetPlayer = this.players.find(p => !p.isBot && p.products > 0);
                
                if (targetPlayer && Math.random() > 0.3) {
                    // Calculate direction to target
                    const direction = new THREE.Vector3()
                        .subVectors(targetPlayer.cart.position, bot.cart.position)
                        .normalize();
                    
                    // Calculate angle difference
                    const botForward = new THREE.Vector3(0, 0, 1).applyQuaternion(bot.cart.quaternion);
                    const angle = botForward.angleTo(direction);
                    
                    // Steer towards target
                    const cross = new THREE.Vector3().crossVectors(botForward, direction);
                    const steerDirection = cross.y > 0 ? 1 : -1;
                    
                    // Apply steering with some randomness for "funny behavior"
                    const randomFactor = 0.3 + Math.random() * 0.4;
                    bot.cart.rotation.y += steerDirection * bot.steering * randomFactor * deltaTime * 60;
                    
                    // Accelerate
                    if (bot.speed < bot.maxSpeed * 0.8) {
                        bot.speed += bot.acceleration * deltaTime * 60;
                    }
                    
                    // Random boost (bots are less skilled)
                    if (Math.random() > 0.99 && bot.boostCooldown <= 0) {
                        bot.speed *= 1.5;
                        bot.boostCooldown = 4;
                    }
                    
                    // Random mistakes (funny behavior)
                    if (Math.random() > 0.995) {
                        bot.cart.rotation.y += (Math.random() - 0.5) * 2;
                        bot.speed *= 0.5;
                    }
                } else {
                    // Just drive forward with some random steering
                    if (bot.speed < bot.maxSpeed * 0.6) {
                        bot.speed += bot.acceleration * 0.5 * deltaTime * 60;
                    }
                    
                    // Gentle random steering
                    bot.cart.rotation.y += (Math.random() - 0.5) * 0.1 * deltaTime * 60;
                }
                
                // Move bot
                const direction = new THREE.Vector3(0, 0, 1);
                direction.applyQuaternion(bot.cart.quaternion);
                bot.cart.position.add(direction.multiplyScalar(bot.speed * deltaTime));
                
                // Keep bot on ground
                bot.cart.position.y = 0.5;
                
                // Update distance
                bot.distance += Math.abs(bot.speed) * deltaTime;
            }

            updateCamera(player) {
                if (!player || !player.cart) return;
                
                // Third-person camera behind cart
                const distance = 8;
                const height = 4;
                
                // Calculate camera position
                const offset = new THREE.Vector3(0, height, distance);
                offset.applyQuaternion(player.cart.quaternion);
                
                const targetPosition = player.cart.position.clone().add(offset);
                const lookAtPosition = player.cart.position.clone();
                lookAtPosition.y += 1;
                
                // Smooth camera movement
                this.camera.position.lerp(targetPosition, 0.1);
                this.camera.lookAt(lookAtPosition);
                
                // Camera shake on low health or collisions
                if (player.health < 50) {
                    const shakeIntensity = (100 - player.health) / 100;
                    this.camera.position.x += (Math.random() - 0.5) * 0.1 * shakeIntensity;
                    this.camera.position.y += (Math.random() - 0.5) * 0.1 * shakeIntensity;
                }
            }

            updateHUD(player) {
                if (!player) return;
                
                // Speed
                const speedKmh = Math.abs(player.speed * 3.6);
                this.uiElements.speedValue.textContent = `${speedKmh.toFixed(0)} km/h`;
                
                // Update speedometer needle
                const maxSpeed = 120;
                const angle = (speedKmh / maxSpeed) * Math.PI - Math.PI / 2;
                this.uiElements.speedNeedle.style.transform = `translateX(-50%) rotate(${angle}rad)`;
                
                // Products
                this.uiElements.productCount.textContent = `${player.products}/${this.maxProducts}`;
                
                // Profit (increase over time based on speed and products)
                if (player.speed > 5) {
                    player.profit += (player.speed / 10) * (player.products / this.maxProducts) * 0.1;
                }
                this.uiElements.profitValue.textContent = `$${player.profit.toFixed(0)}`;
                
                // Distance to goal
                const remainingDistance = Math.max(0, this.roadLength - player.distance);
                this.uiElements.distanceValue.textContent = `${remainingDistance.toFixed(0)}m`;
                
                // Check win condition
                if (remainingDistance <= 0) {
                    this.endGame(player, true);
                }
                
                // Update product damage display
                this.updateProductDamageDisplay(player);
            }

            updateProductsDisplay() {
                this.uiElements.productsGrid.innerHTML = '';
                
                for (let i = 0; i < this.maxProducts; i++) {
                    const product = document.createElement('div');
                    product.className = 'product-item';
                    product.textContent = '';
                    product.dataset.index = i;
                    this.uiElements.productsGrid.appendChild(product);
                }
            }

            updateProductDamageDisplay(player) {
                const products = this.uiElements.productsGrid.querySelectorAll('.product-item');
                products.forEach((product, index) => {
                    if (index >= player.products) {
                        product.classList.add('damaged');
                    } else {
                        product.classList.remove('damaged');
                    }
                });
            }

            checkCollisions(player) {
                if (!player || !player.cart) return;
                
                // Check obstacle collisions
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    if (!obstacle || !obstacle.userData) continue;
                    
                    const distance = player.cart.position.distanceTo(obstacle.position);
                    const collisionDistance = obstacle.userData.type === 'house' ? 3 : 1.5;
                    
                    if (distance < collisionDistance && !obstacle.userData.collided) {
                        // Collision detected
                        this.handleCollision(player, obstacle);
                        obstacle.userData.collided = true;
                        
                        // Reset collision flag after a delay
                        setTimeout(() => {
                            if (obstacle.userData) {
                                obstacle.userData.collided = false;
                            }
                        }, 1000);
                    }
                }
                
                // Check bot collisions
                for (const bot of this.bots) {
                    if (bot === player || !bot.cart) continue;
                    
                    const distance = player.cart.position.distanceTo(bot.cart.position);
                    const collisionDistance = 2;
                    
                    if (distance < collisionDistance) {
                        // Bot hit player
                        this.handleBotCollision(player, bot);
                    }
                }
                
                // Check road boundaries
                const roadHalfWidth = 5;
                if (Math.abs(player.cart.position.x) > roadHalfWidth) {
                    // Off road - damage products
                    if (Math.random() > 0.9) { // Chance-based to not be too punishing
                        player.products = Math.max(0, player.products - 1);
                        player.health -= 2;
                        
                        if (player.products === 0) {
                            this.endGame(player, false);
                        }
                        
                        // Play sound
                        this.assets.sounds.product_destroyed.play();
                    }
                }
            }

            handleCollision(player, obstacle) {
                // Reduce health and products
                const damage = obstacle.userData.damage || 10;
                player.health -= damage;
                player.products = Math.max(0, player.products - 1);
                player.profit = Math.max(0, player.profit - 20);
                
                // Play collision sound
                if (obstacle.userData.type === 'crate') {
                    this.assets.sounds.crash.play();
                } else if (obstacle.userData.type === 'lamp') {
                    this.assets.sounds.slap.play();
                } else {
                    this.assets.sounds.crash.play();
                }
                
                // Bounce effect
                const bounceDirection = new THREE.Vector3()
                    .subVectors(player.cart.position, obstacle.position)
                    .normalize();
                
                player.cart.position.add(bounceDirection.multiplyScalar(1.5));
                player.speed *= -0.3;
                
                // Visual feedback - flash red
                player.cart.traverse(child => {
                    if (child.isMesh && child.material) {
                        const originalColor = child.material.color.clone();
                        child.material.color.setHex(0xff0000);
                        setTimeout(() => {
                            if (child.material) {
                                child.material.color.copy(originalColor);
                            }
                        }, 100);
                    }
                });
                
                // Check game over
                if (player.health <= 0 || player.products === 0) {
                    this.endGame(player, false);
                }
                
                console.log('Collision with', obstacle.userData.type, 'Health:', player.health, 'Products:', player.products);
            }

            handleBotCollision(player, bot) {
                // Reduce products when hit by bot
                player.products = Math.max(0, player.products - 1);
                player.profit = Math.max(0, player.profit - 10);
                
                // Play sound
                this.assets.sounds.slap.play();
                
                // Push player
                const pushDirection = new THREE.Vector3()
                    .subVectors(player.cart.position, bot.cart.position)
                    .normalize();
                
                player.cart.position.add(pushDirection.multiplyScalar(2));
                player.speed *= 0.5;
                bot.speed *= 0.7;
                
                if (player.products === 0) {
                    this.endGame(player, false);
                }
            }

            updateRoadSegments(player) {
                if (!player) return;
                
                // Check if player has moved past a segment
                const segmentLength = 50;
                const segmentIndex = Math.floor(-player.cart.position.z / segmentLength);
                
                if (segmentIndex > this.currentSegment) {
                    this.currentSegment = segmentIndex;
                    
                    // Move oldest segment to the front
                    const oldestSegment = this.roadSegments.shift();
                    if (oldestSegment) {
                        oldestSegment.position.z = -(segmentIndex + this.roadSegments.length) * segmentLength;
                        this.roadSegments.push(oldestSegment);
                        
                        // Add new obstacles to the new segment
                        if (Math.random() > 0.3) {
                            this.addObstacles(oldestSegment.position.z, 10, segmentLength);
                        }
                    }
                }
            }

            togglePause() {
                if (this.gameState === 'PLAYING') {
                    this.gameState = 'PAUSED';
                    this.showScreen('pauseMenu');
                } else if (this.gameState === 'PAUSED') {
                    this.gameState = 'PLAYING';
                    this.showScreen('playing');
                }
            }

            endGame(player, won) {
                this.gameState = 'ENDED';
                
                // Update end screen
                this.uiElements.endTitle.textContent = won ? 'Delivery Complete!' : 'Delivery Failed!';
                this.uiElements.endTitle.style.color = won ? '#2ed573' : '#ff4757';
                
                this.uiElements.finalProfit.textContent = `$${player.profit.toFixed(0)}`;
                this.uiElements.deliveredCount.textContent = `${player.products}/${this.maxProducts}`;
                this.uiElements.totalDistance.textContent = `${player.distance.toFixed(0)}m`;
                
                this.showScreen('endScreen');
                
                console.log(won ? 'Game won!' : 'Game lost!', 'Profit:', player.profit);
            }

            resetGameObjects() {
                // Clear all game objects
                this.players.forEach(player => {
                    if (player.cart && player.cart.parent) {
                        this.scene.remove(player.cart);
                    }
                });
                
                this.bots.forEach(bot => {
                    if (bot.cart && bot.cart.parent) {
                        this.scene.remove(bot.cart);
                    }
                });
                
                this.obstacles.forEach(obstacle => {
                    if (obstacle && obstacle.parent) {
                        this.scene.remove(obstacle);
                    }
                });
                
                // Reset arrays
                this.players = [];
                this.bots = [];
                this.obstacles = [];
                this.carts = [];
            }

            restartGame() {
                console.log('Restarting game...');
                
                // Clear all game objects
                this.resetGameObjects();
                
                // Clear obstacles from scene
                this.obstacles.forEach(obstacle => {
                    if (obstacle.parent) {
                        this.scene.remove(obstacle);
                    }
                });
                this.obstacles = [];
                
                // Generate new road
                this.generateRoad();
                
                // Restart based on previous mode
                if (this.isMultiplayer) {
                    // For multiplayer, go back to lobby
                    this.showScreen('multiplayerLobby');
                } else {
                    // For solo, start new game
                    this.startSoloGame();
                }
            }

            quitToMenu() {
                console.log('Quitting to menu...');
                
                // Clear game objects
                this.resetGameObjects();
                
                // Clear obstacles
                this.obstacles.forEach(obstacle => {
                    if (obstacle.parent) {
                        this.scene.remove(obstacle);
                    }
                });
                this.obstacles = [];
                
                // Show main menu
                this.showScreen('startMenu');
            }

            gameLoop(currentTime = 0) {
                // Calculate delta time
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                // Fixed time step for physics
                const fixedDelta = Math.min(deltaTime, 0.033); // Cap at 30fps for physics
                
                // Process input
                this.processInput();
                
                // Update game state if playing
                if (this.gameState === 'PLAYING') {
                    // Update all players
                    this.players.forEach(player => {
                        this.updatePlayer(player, fixedDelta);
                    });
                    
                    // Update all bots
                    this.bots.forEach(bot => {
                        this.updatePlayer(bot, fixedDelta);
                    });
                }
                
                // Render
                this.renderer.render(this.scene, this.camera);
                
                // Continue loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }
    </script>
</body>
</html>
