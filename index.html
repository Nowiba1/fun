<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Escape - Local Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r162/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        header {
            padding: 15px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 2px solid #0f3460;
            z-index: 100;
        }
        
        h1 {
            color: #e94560;
            font-size: 2.2rem;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.7);
        }
        
        .subtitle {
            color: #4cc9f0;
            font-size: 1rem;
        }
        
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        #game-container {
            flex: 3;
            position: relative;
        }
        
        #ui-container {
            flex: 1;
            padding: 20px;
            background: rgba(15, 52, 96, 0.3);
            border-left: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            min-width: 300px;
            overflow-y: auto;
        }
        
        .panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #1a5fb4;
            box-shadow: 0 0 15px rgba(26, 95, 180, 0.3);
        }
        
        .panel h2 {
            color: #4cc9f0;
            margin-bottom: 15px;
            font-size: 1.3rem;
            border-bottom: 1px solid #1a5fb4;
            padding-bottom: 8px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }
        
        label {
            margin-bottom: 5px;
            color: #a5d8ff;
            font-size: 0.9rem;
        }
        
        input, select, button {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #1a5fb4;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 1rem;
        }
        
        button {
            background: linear-gradient(to right, #e94560, #ff6b8b);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            margin-top: 5px;
        }
        
        button:hover {
            background: linear-gradient(to right, #ff6b8b, #e94560);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
        }
        
        #start-multiplayer {
            background: linear-gradient(to right, #1a5fb4, #4cc9f0);
        }
        
        #start-multiplayer:hover {
            background: linear-gradient(to right, #4cc9f0, #1a5fb4);
            box-shadow: 0 5px 15px rgba(76, 201, 240, 0.4);
        }
        
        .players-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(26, 95, 180, 0.2);
            border-radius: 5px;
            border: 1px solid rgba(76, 201, 240, 0.3);
        }
        
        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .player-info {
            display: flex;
            align-items: center;
        }
        
        .player-score {
            font-weight: bold;
            color: #f1fa8c;
        }
        
        .instructions {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #a5d8ff;
            line-height: 1.5;
        }
        
        .instructions h3 {
            color: #f1fa8c;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #f1fa8c;
        }
        
        .stat-label {
            color: #a5d8ff;
            font-size: 0.8rem;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .hidden {
            display: none !important;
        }
        
        #connection-status {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .connected {
            background-color: #4ade80;
            box-shadow: 0 0 10px #4ade80;
        }
        
        .disconnected {
            background-color: #f87171;
            box-shadow: 0 0 10px #f87171;
        }
        
        .connecting {
            background-color: #fbbf24;
            box-shadow: 0 0 10px #fbbf24;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        #connection-code {
            font-family: monospace;
            font-size: 1.5rem;
            letter-spacing: 3px;
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            border: 2px dashed #4cc9f0;
            margin: 15px 0;
            color: #f1fa8c;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            border: 2px solid #4cc9f0;
            box-shadow: 0 0 30px rgba(76, 201, 240, 0.5);
            text-align: center;
        }
        
        .modal h2 {
            color: #e94560;
            margin-bottom: 20px;
        }
        
        .modal p {
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .footer {
            text-align: center;
            padding: 10px;
            font-size: 0.8rem;
            color: #a5d8ff;
            background: rgba(0, 0, 0, 0.5);
            border-top: 1px solid #0f3460;
        }
    </style>
</head>
<body>
    <header>
        <h1>3D Maze Escape</h1>
        <p class="subtitle">Navigate the maze, collect coins, and compete with friends on the same Wi-Fi!</p>
    </header>
    
    <div class="container">
        <div id="game-container">
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <div id="ui-container">
            <div class="panel">
                <h2>Game Controls</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Maze Size:</label>
                        <select id="maze-size">
                            <option value="10">Small (10x10)</option>
                            <option value="15" selected>Medium (15x15)</option>
                            <option value="20">Large (20x20)</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Player Name:</label>
                        <input type="text" id="player-name" value="Player1" maxlength="12">
                    </div>
                </div>
                
                <button id="generate-maze">Generate New Maze</button>
                <button id="start-multiplayer">Start Multiplayer Game</button>
            </div>
            
            <div class="panel">
                <h2>Connection Status</h2>
                <div id="connection-status">
                    <div class="status-dot disconnected"></div>
                    <span id="status-text">Disconnected</span>
                </div>
                
                <div id="connection-ui" class="hidden">
                    <p>Share this code with friends on the same Wi-Fi:</p>
                    <div id="connection-code">-----</div>
                    <p>Or enter a friend's code to join their game:</p>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="join-code" placeholder="Enter code">
                        <button id="join-game">Join Game</button>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Players</h2>
                <div id="players-container" class="players-list">
                    <div class="player-item">
                        <div class="player-info">
                            <div class="player-color" style="background-color: #e94560;"></div>
                            <span>You (Player1)</span>
                        </div>
                        <div class="player-score">0</div>
                    </div>
                </div>
                
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="coins-count">0</div>
                        <div class="stat-label">Coins Collected</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="players-count">1</div>
                        <div class="stat-label">Players Online</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="time-count">0</div>
                        <div class="stat-label">Seconds</div>
                    </div>
                </div>
            </div>
            
            <div class="panel instructions">
                <h3>How to Play</h3>
                <ul>
                    <li><strong>WASD</strong> or <strong>Arrow Keys</strong> to move</li>
                    <li><strong>Mouse</strong> to look around</li>
                    <li><strong>Collect coins</strong> to increase your score</li>
                    <li>For multiplayer: Share your code with friends on the same Wi-Fi</li>
                    <li>First player to collect 10 coins wins!</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div id="welcome-modal" class="modal">
        <div class="modal-content">
            <h2>Welcome to 3D Maze Escape!</h2>
            <p>This is a 3D maze game that runs entirely in your browser. You can play solo or with friends on the same Wi-Fi network.</p>
            <p>To play multiplayer:</p>
            <ol style="text-align: left; margin: 15px 0;">
                <li>Click "Start Multiplayer Game"</li>
                <li>Share the generated code with friends</li>
                <li>Friends enter the code to join your game</li>
            </ol>
            <p>All communication is peer-to-peer using WebRTC - no server required!</p>
            <button id="start-playing" style="width: 100%; padding: 15px; font-size: 1.2rem;">Start Playing</button>
        </div>
    </div>
    
    <div class="footer">
        <p>Built with Three.js & WebRTC | Works entirely in your browser with no backend</p>
    </div>

    <script>
        // Game variables
        let scene, camera, renderer, maze, player, coins = [];
        let mazeSize = 15;
        let mazeGrid = [];
        let players = {};
        let localPlayerId = null;
        let playerName = "Player1";
        let coinsCollected = 0;
        let gameTime = 0;
        let gameTimer = null;
        
        // WebRTC variables
        let peerConnection = null;
        let dataChannel = null;
        let isHost = false;
        let connectionCode = "";
        
        // DOM elements
        const gameCanvas = document.getElementById('gameCanvas');
        const mazeSizeSelect = document.getElementById('maze-size');
        const playerNameInput = document.getElementById('player-name');
        const generateMazeBtn = document.getElementById('generate-maze');
        const startMultiplayerBtn = document.getElementById('start-multiplayer');
        const playersContainer = document.getElementById('players-container');
        const coinsCountEl = document.getElementById('coins-count');
        const playersCountEl = document.getElementById('players-count');
        const timeCountEl = document.getElementById('time-count');
        const connectionStatus = document.getElementById('connection-status');
        const statusText = document.getElementById('status-text');
        const statusDot = document.querySelector('.status-dot');
        const connectionUI = document.getElementById('connection-ui');
        const connectionCodeEl = document.getElementById('connection-code');
        const joinCodeInput = document.getElementById('join-code');
        const joinGameBtn = document.getElementById('join-game');
        const welcomeModal = document.getElementById('welcome-modal');
        const startPlayingBtn = document.getElementById('start-playing');
        
        // Initialize game
        function init() {
            // Set up Three.js scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x16213e, 10, 50);
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(1, 1, 1);
            
            // Set up renderer
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(gameCanvas.parentElement.clientWidth, gameCanvas.parentElement.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            // Create initial maze
            generateMaze();
            
            // Create local player
            createPlayer(true);
            localPlayerId = player.id;
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            gameCanvas.addEventListener('click', () => {
                gameCanvas.requestPointerLock();
            });
            gameCanvas.addEventListener('mousemove', onMouseMove);
            
            // UI event listeners
            generateMazeBtn.addEventListener('click', () => {
                mazeSize = parseInt(mazeSizeSelect.value);
                generateMaze();
                if (dataChannel && dataChannel.readyState === 'open') {
                    sendGameUpdate('mazeRegenerate', { mazeSize });
                }
            });
            
            playerNameInput.addEventListener('change', () => {
                playerName = playerNameInput.value;
                if (player) {
                    player.name = playerName;
                    updatePlayersUI();
                    if (dataChannel && dataChannel.readyState === 'open') {
                        sendGameUpdate('playerUpdate', { id: localPlayerId, name: playerName });
                    }
                }
            });
            
            startMultiplayerBtn.addEventListener('click', startMultiplayer);
            joinGameBtn.addEventListener('click', joinMultiplayer);
            startPlayingBtn.addEventListener('click', () => {
                welcomeModal.style.display = 'none';
            });
            
            // Start game timer
            gameTimer = setInterval(() => {
                gameTime++;
                timeCountEl.textContent = gameTime;
            }, 1000);
            
            // Start animation loop
            animate();
        }
        
        // Generate a random maze
        function generateMaze() {
            // Clear existing maze
            if (maze) {
                scene.remove(maze);
            }
            
            // Clear coins
            coins.forEach(coin => scene.remove(coin.mesh));
            coins = [];
            
            // Initialize maze grid
            mazeGrid = [];
            for (let z = 0; z < mazeSize; z++) {
                mazeGrid[z] = [];
                for (let x = 0; x < mazeSize; x++) {
                    mazeGrid[z][x] = {
                        wall: true,
                        visited: false
                    };
                }
            }
            
            // Use depth-first search to generate maze
            const stack = [];
            const startX = 0;
            const startZ = 0;
            
            mazeGrid[startZ][startX].visited = true;
            mazeGrid[startZ][startX].wall = false;
            stack.push([startX, startZ]);
            
            while (stack.length > 0) {
                const [x, z] = stack[stack.length - 1];
                const neighbors = getUnvisitedNeighbors(x, z);
                
                if (neighbors.length > 0) {
                    const [nx, nz, dir] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    
                    // Remove wall between current cell and neighbor
                    mazeGrid[z][x].wall = false;
                    mazeGrid[nz][nx].wall = false;
                    
                    // Remove wall in between
                    const wx = x + (nx - x) / 2;
                    const wz = z + (nz - z) / 2;
                    if (wx >= 0 && wx < mazeSize && wz >= 0 && wz < mazeSize) {
                        mazeGrid[wz][wx].wall = false;
                    }
                    
                    mazeGrid[nz][nx].visited = true;
                    stack.push([nx, nz]);
                } else {
                    stack.pop();
                }
            }
            
            // Create exit
            mazeGrid[mazeSize-1][mazeSize-1].wall = false;
            
            // Build maze walls
            const mazeGeometry = new THREE.BoxGeometry(1, 2, 1);
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a5fb4,
                shininess: 30
            });
            
            maze = new THREE.Group();
            
            for (let z = 0; z < mazeSize; z++) {
                for (let x = 0; x < mazeSize; x++) {
                    if (mazeGrid[z][x].wall) {
                        const wall = new THREE.Mesh(mazeGeometry, wallMaterial);
                        wall.position.set(x - mazeSize/2, 0, z - mazeSize/2);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        maze.add(wall);
                    } else {
                        // Chance to place a coin in open spaces (not at start)
                        if ((x !== 0 || z !== 0) && Math.random() < 0.1) {
                            createCoin(x - mazeSize/2, z - mazeSize/2);
                        }
                    }
                }
            }
            
            // Add floor
            const floorGeometry = new THREE.PlaneGeometry(mazeSize * 2, mazeSize * 2);
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x16213e,
                shininess: 10
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1;
            floor.receiveShadow = true;
            maze.add(floor);
            
            scene.add(maze);
            
            // Reset player position
            if (player) {
                player.position.set(-mazeSize/2 + 0.5, 0, -mazeSize/2 + 0.5);
                player.rotation.y = 0;
                camera.rotation.set(0, 0, 0);
            }
        }
        
        // Get unvisited neighbors for maze generation
        function getUnvisitedNeighbors(x, z) {
            const neighbors = [];
            const directions = [
                [x+2, z, 'right'],
                [x-2, z, 'left'],
                [x, z+2, 'down'],
                [x, z-2, 'up']
            ];
            
            for (const [nx, nz, dir] of directions) {
                if (nx >= 0 && nx < mazeSize && nz >= 0 && nz < mazeSize && !mazeGrid[nz][nx].visited) {
                    neighbors.push([nx, nz, dir]);
                }
            }
            
            return neighbors;
        }
        
// Create a player
function createPlayer(isLocal = false) {
    const playerId = 'player_' + Math.random().toString(36).substr(2, 9);
    const playerColor = new THREE.Color(
        Math.random() * 0.5 + 0.5,
        Math.random() * 0.5 + 0.5,
        Math.random() * 0.5 + 0.5
    );
    
    // Créer un joueur avec des formes simples
    const playerGroup = new THREE.Group();
    
    // Corps principal (cylindre)
    const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8);
    const playerMaterial = new THREE.MeshPhongMaterial({ 
        color: playerColor,
        shininess: 50
    });
    const body = new THREE.Mesh(bodyGeometry, playerMaterial);
    body.position.y = 0.4;
    body.castShadow = true;
    body.receiveShadow = true;
    playerGroup.add(body);
    
    // Tête (sphère)
    const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
    const head = new THREE.Mesh(headGeometry, playerMaterial);
    head.position.y = 1.1;
    head.castShadow = true;
    playerGroup.add(head);
    
    // Indicateur avant (pour voir la direction)
    const indicatorGeometry = new THREE.ConeGeometry(0.15, 0.4, 4);
    const indicatorMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xff0000,
        emissive: 0x330000
    });
    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
    indicator.position.z = 0.35;
    indicator.position.y = 0.8;
    indicator.rotation.x = Math.PI / 2;
    playerGroup.add(indicator);

    const playerObj = {
        id: playerId,
        name: isLocal ? playerName : `Player${Object.keys(players).length + 1}`,
        mesh: playerGroup,
        position: new THREE.Vector3(-mazeSize/2 + 0.5, 0, -mazeSize/2 + 0.5),
        rotation: new THREE.Euler(0, 0, 0),
        color: playerColor.getHexString(),
        score: 0,
        isLocal: isLocal
    };
    
    if (isLocal) {
        player = playerObj;
        scene.add(player.mesh);
    } else {
        players[playerId] = playerObj;
        scene.add(playerObj.mesh);
        updatePlayersUI();
    }
    
    return playerId;
}
        // Create a coin
        function createCoin(x, z) {
            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 16);
            const coinMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xf1fa8c,
                emissive: 0x444400,
                shininess: 100
            });
            const coinMesh = new THREE.Mesh(coinGeometry, coinMaterial);
            coinMesh.position.set(x, 0.5, z);
            coinMesh.rotation.x = Math.PI / 2;
            coinMesh.castShadow = true;
            
            const coin = {
                mesh: coinMesh,
                position: new THREE.Vector3(x, 0.5, z),
                collected: false
            };
            
            coins.push(coin);
            scene.add(coinMesh);
        }
        
        // Update players UI
        function updatePlayersUI() {
            playersContainer.innerHTML = '';
            
            // Add local player
            const localPlayerItem = document.createElement('div');
            localPlayerItem.className = 'player-item';
            localPlayerItem.innerHTML = `
                <div class="player-info">
                    <div class="player-color" style="background-color: #${player.color};"></div>
                    <span>${player.name} (You)</span>
                </div>
                <div class="player-score">${player.score}</div>
            `;
            playersContainer.appendChild(localPlayerItem);
            
            // Add other players
            for (const playerId in players) {
                const otherPlayer = players[playerId];
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                playerItem.innerHTML = `
                    <div class="player-info">
                        <div class="player-color" style="background-color: #${otherPlayer.color};"></div>
                        <span>${otherPlayer.name}</span>
                    </div>
                    <div class="player-score">${otherPlayer.score}</div>
                `;
                playersContainer.appendChild(playerItem);
            }
            
            playersCountEl.textContent = Object.keys(players).length + 1;
        }
        
        // Handle keyboard input
        const keys = {};
        
        function onKeyDown(event) {
            keys[event.code] = true;
        }
        
        function onKeyUp(event) {
            keys[event.code] = false;
        }
        
        // Handle mouse movement
        function onMouseMove(event) {
            if (document.pointerLockElement === gameCanvas && player) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                
                player.rotation.y -= movementX * 0.002;
                camera.rotation.x -= movementY * 0.002;
                
                // Limit vertical camera movement
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        }
        
        // Update player movement
        function updatePlayer() {
            if (!player) return;
            
            const speed = 0.1;
            const prevPosition = player.position.clone();
            
            // Move forward/backward
            if (keys['KeyW'] || keys['ArrowUp']) {
                player.position.x -= Math.sin(player.rotation.y) * speed;
                player.position.z -= Math.cos(player.rotation.y) * speed;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                player.position.x += Math.sin(player.rotation.y) * speed;
                player.position.z += Math.cos(player.rotation.y) * speed;
            }
            
            // Strafe left/right
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.position.x -= Math.cos(player.rotation.y) * speed;
                player.position.z += Math.sin(player.rotation.y) * speed;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.position.x += Math.cos(player.rotation.y) * speed;
                player.position.z -= Math.sin(player.rotation.y) * speed;
            }
            
            // Check collision with walls
            const playerGridX = Math.floor(player.position.x + mazeSize/2);
            const playerGridZ = Math.floor(player.position.z + mazeSize/2);
            
            if (playerGridX >= 0 && playerGridX < mazeSize && 
                playerGridZ >= 0 && playerGridZ < mazeSize &&
                mazeGrid[playerGridZ][playerGridX].wall) {
                // Collision detected, revert to previous position
                player.position.copy(prevPosition);
            }
            
            // Update player mesh position
            player.mesh.position.copy(player.position);
            player.mesh.rotation.y = player.rotation.y;
            
            // Update camera position
            camera.position.set(
                player.position.x,
                player.position.y + 1,
                player.position.z
            );
            camera.rotation.y = player.rotation.y;
            
            // Check coin collection
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                if (!coin.collected && player.position.distanceTo(coin.position) < 0.8) {
                    coin.collected = true;
                    scene.remove(coin.mesh);
                    coins.splice(i, 1);
                    
                    player.score++;
                    coinsCollected++;
                    coinsCountEl.textContent = coinsCollected;
                    
                    // Create new coin
                    const newX = Math.floor(Math.random() * mazeSize) - mazeSize/2 + 0.5;
                    const newZ = Math.floor(Math.random() * mazeSize) - mazeSize/2 + 0.5;
                    createCoin(newX, newZ);
                    
                    // Send update to other players
                    if (dataChannel && dataChannel.readyState === 'open') {
                        sendGameUpdate('coinCollected', {
                            playerId: localPlayerId,
                            coinIndex: i,
                            newCoin: { x: newX, z: newZ }
                        });
                    }
                    
                    updatePlayersUI();
                    
                    // Check for win condition
                    if (player.score >= 10) {
                        alert(`Congratulations ${player.name}! You collected 10 coins and won!`);
                        player.score = 0;
                        coinsCollected = 0;
                        coinsCountEl.textContent = '0';
                        generateMaze();
                    }
                }
            }
            
            // Send position update to other players
            if (dataChannel && dataChannel.readyState === 'open' && 
                (prevPosition.x !== player.position.x || prevPosition.z !== player.position.z || 
                 prevPosition.y !== player.position.y)) {
                sendGameUpdate('playerMove', {
                    id: localPlayerId,
                    position: { x: player.position.x, y: player.position.y, z: player.position.z },
                    rotation: { y: player.rotation.y }
                });
            }
        }
        
        // Update other players
        function updateOtherPlayers() {
            for (const playerId in players) {
                const otherPlayer = players[playerId];
                otherPlayer.mesh.position.lerp(otherPlayer.position, 0.2);
                otherPlayer.mesh.rotation.y = otherPlayer.rotation.y;
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            updateOtherPlayers();
            
            // Animate coins
            const time = Date.now() * 0.001;
            coins.forEach(coin => {
                if (coin.mesh) {
                    coin.mesh.rotation.z = time * 2;
                    coin.mesh.position.y = 0.5 + Math.sin(time * 3) * 0.1;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = gameCanvas.parentElement.clientWidth / gameCanvas.parentElement.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(gameCanvas.parentElement.clientWidth, gameCanvas.parentElement.clientHeight);
        }
        
        // Multiplayer functions
        function startMultiplayer() {
            isHost = true;
            connectionCode = generateConnectionCode();
            connectionCodeEl.textContent = connectionCode;
            connectionUI.classList.remove('hidden');
            
            updateConnectionStatus('Connecting...', 'connecting');
            
            // For demo purposes, we'll simulate WebRTC connection
            // In a real implementation, you would use WebRTC API
            setTimeout(() => {
                updateConnectionStatus('Connected as Host', 'connected');
                
                // Create a mock remote player for demonstration
                const remotePlayerId = createPlayer(false);
                
                // Simulate receiving data from remote player
                simulateRemotePlayer(remotePlayerId);
            }, 1500);
            
            startMultiplayerBtn.disabled = true;
            startMultiplayerBtn.textContent = 'Hosting Game';
        }
        
        function joinMultiplayer() {
            const code = joinCodeInput.value.trim();
            if (code.length !== 5) {
                alert('Please enter a valid 5-character code');
                return;
            }
            
            isHost = false;
            connectionCode = code;
            connectionCodeEl.textContent = code;
            connectionUI.classList.remove('hidden');
            
            updateConnectionStatus('Connecting...', 'connecting');
            
            // For demo purposes, we'll simulate WebRTC connection
            setTimeout(() => {
                updateConnectionStatus('Connected to Host', 'connected');
                
                // Create a mock remote player for demonstration
                const remotePlayerId = createPlayer(false);
                
                // Simulate receiving data from remote player
                simulateRemotePlayer(remotePlayerId);
            }, 1500);
            
            startMultiplayerBtn.disabled = true;
            startMultiplayerBtn.textContent = 'Joined Game';
        }
        
        function generateConnectionCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 5; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        
        function updateConnectionStatus(text, status) {
            statusText.textContent = text;
            statusDot.className = 'status-dot ' + status;
        }
        
        function sendGameUpdate(type, data) {
            // In a real implementation, this would send data via WebRTC data channel
            console.log(`Sending ${type}:`, data);
            
            // For demo, we'll just log it
            if (type === 'playerMove') {
                // Simulate receiving this update
                setTimeout(() => {
                    if (Math.random() > 0.5) { // Randomly simulate network delay/loss
                        receiveGameUpdate(type, data);
                    }
                }, 100 + Math.random() * 200);
            }
        }
        
        function receiveGameUpdate(type, data) {
            console.log(`Received ${type}:`, data);
            
            switch (type) {
                case 'playerMove':
                    if (players[data.id]) {
                        players[data.id].position.set(data.position.x, data.position.y, data.position.z);
                        players[data.id].rotation.y = data.rotation.y;
                    }
                    break;
                    
                case 'coinCollected':
                    if (data.playerId === localPlayerId) return;
                    
                    if (coins[data.coinIndex]) {
                        scene.remove(coins[data.coinIndex].mesh);
                        coins.splice(data.coinIndex, 1);
                        
                        createCoin(data.newCoin.x, data.newCoin.z);
                        
                        if (players[data.playerId]) {
                            players[data.playerId].score++;
                            updatePlayersUI();
                        }
                    }
                    break;
                    
                case 'playerUpdate':
                    if (players[data.id]) {
                        players[data.id].name = data.name;
                        updatePlayersUI();
                    }
                    break;
                    
                case 'mazeRegenerate':
                    mazeSize = data.mazeSize;
                    mazeSizeSelect.value = mazeSize;
                    generateMaze();
                    break;
            }
        }
        
        // Simulate a remote player for demo purposes
        function simulateRemotePlayer(playerId) {
            // Move the remote player randomly
            setInterval(() => {
                if (players[playerId] && Math.random() > 0.7) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 0.1;
                    
                    players[playerId].position.x += Math.sin(angle) * distance;
                    players[playerId].position.z += Math.cos(angle) * distance;
                    
                    // Keep player in bounds
                    players[playerId].position.x = Math.max(-mazeSize/2 + 0.5, Math.min(mazeSize/2 - 0.5, players[playerId].position.x));
                    players[playerId].position.z = Math.max(-mazeSize/2 + 0.5, Math.min(mazeSize/2 - 0.5, players[playerId].position.z));
                    
                    // Random rotation
                    players[playerId].rotation.y += (Math.random() - 0.5) * 0.1;
                }
            }, 100);
            
            // Simulate coin collection
            setInterval(() => {
                if (coins.length > 0 && Math.random() > 0.9) {
                    const coinIndex = Math.floor(Math.random() * coins.length);
                    receiveGameUpdate('coinCollected', {
                        playerId: playerId,
                        coinIndex: coinIndex,
                        newCoin: { 
                            x: Math.floor(Math.random() * mazeSize) - mazeSize/2 + 0.5, 
                            z: Math.floor(Math.random() * mazeSize) - mazeSize/2 + 0.5 
                        }
                    });
                }
            }, 2000);
        }
        
        // Initialize the game when the page loads
        window.onload = init;
    </script>
</body>
</html>
