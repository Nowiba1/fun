<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Riders: Delivery Chaos</title>
    
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        /* UI Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            padding: 20px;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: #ff6b6b;
            text-shadow: 3px 3px 0 #ff4757;
            text-align: center;
        }

        h2 {
            font-size: 2em;
            margin-bottom: 30px;
            color: #70a1ff;
        }

        .menu-container {
            max-width: 600px;
            width: 90%;
            background: rgba(30, 30, 60, 0.8);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff6b6b;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }

        button {
            padding: 15px 30px;
            font-size: 1.2em;
            background: linear-gradient(45deg, #ff6b6b, #ff4757);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 180px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
            background: linear-gradient(45deg, #ff4757, #ff3838);
        }

        button.secondary {
            background: linear-gradient(45deg, #3742fa, #5352ed);
        }

        button.secondary:hover {
            background: linear-gradient(45deg, #5352ed, #3742fa);
        }

        .input-group {
            margin: 20px 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #70a1ff;
            font-size: 1.1em;
        }

        input, select {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #3742fa;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .room-code {
            font-size: 2.5em;
            letter-spacing: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            color: #2ed573;
        }

        .player-list {
            list-style: none;
            margin: 20px 0;
        }

        .player-list li {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            align-items: center;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            min-width: 250px;
            z-index: 10;
        }

        .hud-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }

        .hud-label {
            color: #70a1ff;
            font-weight: bold;
        }

        .hud-value {
            color: #2ed573;
            font-weight: bold;
            font-size: 1.1em;
        }

        #speedometer {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 150px;
            height: 150px;
        }

        .speed-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 3px;
            height: 60px;
            background: #ff4757;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(0deg);
            transition: transform 0.1s;
        }

        .speed-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            font-size: 0.8em;
            color: white;
        }

        .products-grid {
            display: grid;
            grid-template-columns: repeat(5, 30px);
            gap: 5px;
            margin-top: 10px;
        }

        .product-item {
            width: 30px;
            height: 30px;
            background: #2ed573;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .product-item.damaged {
            background: #ff4757;
            transform: scale(0.8);
        }

        /* Loading Screen */
        #loadingScreen {
            background: #1a1a2e;
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 30px 0;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff4757);
            width: 0%;
            transition: width 0.3s;
            border-radius: 10px;
        }

        .loading-text {
            margin-top: 20px;
            color: #70a1ff;
        }

        /* Controls Info */
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #3742fa;
            color: white;
            max-width: 300px;
        }

        .controls-info h3 {
            color: #70a1ff;
            margin-bottom: 10px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .control-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Loading Screen -->
        <div id="loadingScreen" class="screen">
            <h1>Cart Riders</h1>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
            <div class="loading-text" id="loadingText">Loading assets...</div>
        </div>

        <!-- Start Menu -->
        <div id="startMenu" class="screen hidden">
            <div class="menu-container">
                <h1>Delivery Chaos</h1>
                
                <div class="button-group">
                    <button id="playSolo">Solo Delivery</button>
                    <button id="multiplayer" class="secondary">Multiplayer Race</button>
                    <button id="settings">Settings</button>
                </div>

                <div class="input-group">
                    <label for="botCount">Bot Count (0-4):</label>
                    <input type="range" id="botCount" min="0" max="4" value="2">
                    <span id="botCountDisplay">2</span>
                </div>

                <div class="controls-info">
                    <h3>Controls</h3>
                    <div class="control-item">
                        <span>Move:</span>
                        <span class="control-key">WASD / Arrows</span>
                    </div>
                    <div class="control-item">
                        <span>Boost:</span>
                        <span class="control-key">SPACE / A Button</span>
                    </div>
                    <div class="control-item">
                        <span>Pause:</span>
                        <span class="control-key">ESC / Start</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Multiplayer Lobby -->
        <div id="multiplayerLobby" class="screen hidden">
            <div class="menu-container">
                <h2>Multiplayer Lobby</h2>
                
                <div class="button-group">
                    <button id="createRoom">Create Room</button>
                    <button id="joinRoom" class="secondary">Join Room</button>
                    <button id="backToMenu">Back</button>
                </div>

                <div id="roomCodeSection" class="hidden">
                    <div class="room-code" id="roomCode">----</div>
                    <p>Share this code with other players!</p>
                    <div id="playerList">
                        <h3>Players (1/8):</h3>
                        <ul class="player-list" id="playerListItems">
                            <li>
                                <div class="player-color" style="background: #ff4757;"></div>
                                <span>Host (You)</span>
                            </li>
                        </ul>
                    </div>
                    <button id="startGame">Start Game</button>
                </div>

                <div id="joinSection" class="hidden">
                    <div class="input-group">
                        <label for="roomCodeInput">Enter Room Code:</label>
                        <input type="text" id="roomCodeInput" maxlength="4" placeholder="ABCD">
                    </div>
                    <button id="connectToRoom">Connect</button>
                </div>
            </div>
        </div>

        <!-- Game HUD -->
        <div id="hud" class="hidden">
            <div class="hud-item">
                <span class="hud-label">Speed:</span>
                <span class="hud-value" id="speedValue">0 km/h</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Products:</span>
                <span class="hud-value" id="productCount">15/15</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Profit:</span>
                <span class="hud-value" id="profitValue">$0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Distance:</span>
                <span class="hud-value" id="distanceValue">1000m</span>
            </div>
            <div class="products-grid" id="productsGrid"></div>
        </div>

        <!-- Speedometer -->
        <div id="speedometer" class="hidden">
            <div class="speed-labels">
                <span style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%);">0</span>
                <span style="position: absolute; top: 50%; right: 10px; transform: translateY(-50%);">50</span>
                <span style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);">100</span>
                <span style="position: absolute; top: 50%; left: 10px; transform: translateY(-50%);">-50</span>
            </div>
            <div class="speed-needle" id="speedNeedle"></div>
        </div>

        <!-- Pause Menu -->
        <div id="pauseMenu" class="screen hidden">
            <div class="menu-container">
                <h2>Game Paused</h2>
                <div class="button-group">
                    <button id="resumeGame">Resume</button>
                    <button id="restartGame">Restart</button>
                    <button id="quitToMenu">Quit to Menu</button>
                </div>
            </div>
        </div>

        <!-- End Screen -->
        <div id="endScreen" class="screen hidden">
            <div class="menu-container">
                <h1 id="endTitle">Delivery Complete!</h1>
                <div style="font-size: 1.5em; margin: 20px 0;">
                    <div>Final Profit: <span id="finalProfit" style="color: #2ed573;">$0</span></div>
                    <div>Products Delivered: <span id="deliveredCount" style="color: #2ed573;">0/15</span></div>
                    <div>Distance Traveled: <span id="totalDistance" style="color: #70a1ff;">0m</span></div>
                </div>
                <div class="button-group">
                    <button id="playAgain">Play Again</button>
                    <button id="endToMenu">Main Menu</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Texture Manager with Fallbacks
        class TextureManager {
            constructor() {
                this.textures = {};
                this.loader = new THREE.TextureLoader();
                this.defaultColors = {
                    cart: 0xff4757,
                    player: 0x70a1ff,
                    crate: 0x2ed573,
                    lamp: 0xcccccc,
                    house: 0x3742fa,
                    building: 0x5352ed,
                    road: 0x333333,
                    ground: 0x2d3436
                };
            }

            createFallbackTexture(color) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Create simple pattern
                ctx.fillStyle = `rgb(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255})`;
                ctx.fillRect(0, 0, 256, 256);
                
                // Add some pattern
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                for(let i = 0; i < 256; i += 32) {
                    for(let j = 0; j < 256; j += 32) {
                        if((i + j) % 64 === 0) {
                            ctx.fillRect(i, j, 16, 16);
                        }
                    }
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(4, 4);
                
                return texture;
            }

            getTexture(type, path = null) {
                if (path && !this.textures[type]) {
                    this.textures[type] = new Promise((resolve) => {
                        this.loader.load(
                            path,
                            (texture) => {
                                texture.wrapS = THREE.RepeatWrapping;
                                texture.wrapT = THREE.RepeatWrapping;
                                texture.repeat.set(2, 2);
                                resolve(texture);
                            },
                            undefined,
                            () => {
                                // Fallback if texture fails to load
                                resolve(this.createFallbackTexture(this.defaultColors[type] || 0x808080));
                            }
                        );
                    });
                }
                
                if (!this.textures[type]) {
                    this.textures[type] = Promise.resolve(this.createFallbackTexture(this.defaultColors[type] || 0x808080));
                }
                
                return this.textures[type];
            }
        }

        // Model Manager with Fallbacks
        class ModelManager {
            constructor() {
                this.models = {};
                this.loader = new THREE.GLTFLoader();
                this.textureManager = new TextureManager();
            }

            async createFallbackModel(type) {
                const group = new THREE.Group();
                
                switch(type) {
                    case 'cart':
                        // Shopping cart
                        const cartBody = new THREE.BoxGeometry(1.8, 0.8, 3);
                        const cartMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0xff4757,
                            metalness: 0.6,
                            roughness: 0.4
                        });
                        const body = new THREE.Mesh(cartBody, cartMaterial);
                        body.position.y = 0.4;
                        body.castShadow = true;
                        group.add(body);
                        
                        // Cart handle
                        const handleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5);
                        const handle = new THREE.Mesh(handleGeometry, cartMaterial);
                        handle.position.set(0, 1.2, -1);
                        handle.rotation.z = Math.PI / 2;
                        handle.castShadow = true;
                        group.add(handle);
                        
                        // Wheels
                        const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1);
                        const wheelMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x333333,
                            metalness: 0.8,
                            roughness: 0.2
                        });
                        
                        const positions = [
                            [0.8, 0.2, 1],
                            [-0.8, 0.2, 1],
                            [0.8, 0.2, -1],
                            [-0.8, 0.2, -1]
                        ];
                        
                        positions.forEach(pos => {
                            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                            wheel.position.set(pos[0], pos[1], pos[2]);
                            wheel.rotation.z = Math.PI / 2;
                            wheel.castShadow = true;
                            group.add(wheel);
                        });
                        break;
                        
                    case 'player':
                        // Player character
                        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1);
                        const playerMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x70a1ff,
                            metalness: 0.2,
                            roughness: 0.6
                        });
                        const playerBody = new THREE.Mesh(bodyGeometry, playerMaterial);
                        playerBody.position.y = 0.5;
                        playerBody.castShadow = true;
                        group.add(playerBody);
                        
                        // Head
                        const headGeometry = new THREE.SphereGeometry(0.2);
                        const head = new THREE.Mesh(headGeometry, playerMaterial);
                        head.position.y = 1.2;
                        head.castShadow = true;
                        group.add(head);
                        break;
                        
                    case 'crate':
                        // Crate
                        const crateGeometry = new THREE.BoxGeometry(1, 1, 1);
                        const crateMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x2ed573,
                            metalness: 0.1,
                            roughness: 0.8
                        });
                        const crate = new THREE.Mesh(crateGeometry, crateMaterial);
                        crate.castShadow = true;
                        group.add(crate);
                        break;
                        
                    case 'lamp':
                        // Street lamp
                        const poleGeometry = new THREE.CylinderGeometry(0.1, 0.15, 4);
                        const poleMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0xaaaaaa,
                            metalness: 0.7,
                            roughness: 0.3
                        });
                        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                        pole.castShadow = true;
                        group.add(pole);
                        
                        // Light
                        const lightGeometry = new THREE.SphereGeometry(0.3);
                        const lightMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0xffdd59,
                            emissive: 0xffdd59,
                            emissiveIntensity: 0.5
                        });
                        const light = new THREE.Mesh(lightGeometry, lightMaterial);
                        light.position.y = 2.2;
                        light.castShadow = true;
                        group.add(light);
                        
                        // Add actual light source
                        const pointLight = new THREE.PointLight(0xffdd59, 1, 10);
                        pointLight.position.y = 2.2;
                        group.add(pointLight);
                        break;
                        
                    case 'house':
                        // Building
                        const houseGeometry = new THREE.BoxGeometry(4, 3, 4);
                        const houseMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x3742fa,
                            metalness: 0.1,
                            roughness: 0.7
                        });
                        const house = new THREE.Mesh(houseGeometry, houseMaterial);
                        house.position.y = 1.5;
                        house.castShadow = true;
                        group.add(house);
                        
                        // Roof
                        const roofGeometry = new THREE.ConeGeometry(3, 2, 4);
                        const roofMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0xff6b6b,
                            metalness: 0.2,
                            roughness: 0.8
                        });
                        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                        roof.position.y = 3.5;
                        roof.rotation.y = Math.PI / 4;
                        roof.castShadow = true;
                        group.add(roof);
                        
                        // Windows
                        const windowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
                        const windowMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0xffff00,
                            emissive: 0xffff00,
                            emissiveIntensity: 0.3
                        });
                        
                        const windowPositions = [
                            [1.1, 1.5, 2.01],
                            [-1.1, 1.5, 2.01],
                            [1.1, 1.5, -2.01],
                            [-1.1, 1.5, -2.01],
                            [2.01, 1.5, 1.1],
                            [2.01, 1.5, -1.1]
                        ];
                        
                        windowPositions.forEach(pos => {
                            const window = new THREE.Mesh(windowGeometry, windowMaterial);
                            window.position.set(pos[0], pos[1], pos[2]);
                            if (Math.abs(pos[0]) > 2) {
                                window.rotation.y = Math.PI / 2;
                            }
                            group.add(window);
                        });
                        break;
                        
                    default:
                        // Generic cube for unknown models
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshStandardMaterial({ 
                            color: 0x808080,
                            metalness: 0.3,
                            roughness: 0.6
                        });
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.castShadow = true;
                        group.add(mesh);
                }
                
                return { scene: group };
            }

            async loadModel(type, path) {
                try {
                    if (!path) {
                        throw new Error('No path provided');
                    }
                    
                    return new Promise((resolve, reject) => {
                        this.loader.load(
                            path,
                            (gltf) => {
                                console.log(`Model loaded: ${type}`);
                                // Ensure all meshes have materials
                                gltf.scene.traverse((child) => {
                                    if (child.isMesh) {
                                        if (!child.material) {
                                            child.material = new THREE.MeshStandardMaterial({ 
                                                color: this.textureManager.defaultColors[type] || 0x808080,
                                                metalness: 0.3,
                                                roughness: 0.6
                                            });
                                        }
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                    }
                                });
                                this.models[type] = gltf;
                                resolve(gltf);
                            },
                            undefined,
                            (error) => {
                                console.warn(`Failed to load model ${type}:`, error);
                                this.createFallbackModel(type).then(resolve).catch(reject);
                            }
                        );
                    });
                } catch (error) {
                    console.warn(`Error loading ${type}, using fallback:`, error);
                    return this.createFallbackModel(type);
                }
            }

            getModel(type) {
                return this.models[type];
            }
        }

        // Sound Manager with Fallbacks
        class SoundManager {
            constructor() {
                this.sounds = {};
                this.audioContext = null;
                this.enabled = false;
            }

            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.enabled = true;
                } catch (e) {
                    console.warn('Web Audio API not supported, sounds disabled');
                    this.enabled = false;
                }
            }

            createFallbackSound(type) {
                return {
                    play: () => {
                        if (!this.enabled) return;
                        
                        try {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            let frequency = 200;
                            let duration = 0.3;
                            
                            switch(type) {
                                case 'crash':
                                    frequency = 150;
                                    duration = 0.4;
                                    break;
                                case 'slap':
                                    frequency = 300;
                                    duration = 0.2;
                                    break;
                                case 'product_destroyed':
                                    frequency = 100;
                                    duration = 0.5;
                                    break;
                            }
                            
                            oscillator.frequency.value = frequency;
                            oscillator.type = 'sawtooth';
                            gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + duration);
                        } catch (e) {
                            // Silent fail for audio errors
                        }
                    }
                };
            }

            async loadSound(type, path) {
                if (!this.enabled) {
                    this.sounds[type] = this.createFallbackSound(type);
                    return;
                }

                try {
                    const response = await fetch(path);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    
                    this.sounds[type] = {
                        play: () => {
                            try {
                                const source = this.audioContext.createBufferSource();
                                source.buffer = audioBuffer;
                                source.connect(this.audioContext.destination);
                                source.start();
                            } catch (e) {
                                // Fallback to generated sound
                                this.createFallbackSound(type).play();
                            }
                        }
                    };
                } catch (error) {
                    console.warn(`Failed to load sound ${type}:`, error);
                    this.sounds[type] = this.createFallbackSound(type);
                }
            }

            play(type) {
                if (this.sounds[type]) {
                    this.sounds[type].play();
                }
            }
        }

        // Main Game Class
        class CartRidersGame {
            constructor() {
                // Managers
                this.modelManager = new ModelManager();
                this.soundManager = new SoundManager();
                this.textureManager = new TextureManager();
                
                // Three.js setup
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                // Game objects
                this.carts = [];
                this.players = [];
                this.bots = [];
                this.obstacles = [];
                this.roadSegments = [];
                this.buildings = [];
                
                // Game state
                this.gameState = 'LOADING';
                this.isMultiplayer = false;
                this.botCount = 2;
                
                // Physics
                this.gravity = 9.8;
                
                // UI elements
                this.uiElements = {};
                this.bindUIElements();
                
                // Input
                this.keys = {};
                this.gamepads = {};
                this.input = {
                    steering: 0,
                    throttle: 0,
                    brake: 0,
                    boost: false
                };
                
                // WebRTC
                this.peer = null;
                this.connections = {};
                this.roomCode = '';
                
                // Game variables
                this.playerCount = 0;
                this.maxProducts = 15;
                this.roadLength = 5000; // Much longer road
                this.currentSegment = 0;
                this.lastTime = 0;
                this.roadTurnAngle = 0;
                this.roadCurve = 0;
                
                // Start initialization
                this.init();
            }

            bindUIElements() {
                // Screens
                this.uiElements.loadingScreen = document.getElementById('loadingScreen');
                this.uiElements.startMenu = document.getElementById('startMenu');
                this.uiElements.multiplayerLobby = document.getElementById('multiplayerLobby');
                this.uiElements.hud = document.getElementById('hud');
                this.uiElements.pauseMenu = document.getElementById('pauseMenu');
                this.uiElements.endScreen = document.getElementById('endScreen');
                
                // Buttons
                this.uiElements.playSolo = document.getElementById('playSolo');
                this.uiElements.multiplayer = document.getElementById('multiplayer');
                this.uiElements.createRoom = document.getElementById('createRoom');
                this.uiElements.joinRoom = document.getElementById('joinRoom');
                this.uiElements.backToMenu = document.getElementById('backToMenu');
                this.uiElements.startGame = document.getElementById('startGame');
                this.uiElements.connectToRoom = document.getElementById('connectToRoom');
                this.uiElements.resumeGame = document.getElementById('resumeGame');
                this.uiElements.restartGame = document.getElementById('restartGame');
                this.uiElements.quitToMenu = document.getElementById('quitToMenu');
                this.uiElements.playAgain = document.getElementById('playAgain');
                this.uiElements.endToMenu = document.getElementById('endToMenu');
                
                // Inputs
                this.uiElements.botCount = document.getElementById('botCount');
                this.uiElements.botCountDisplay = document.getElementById('botCountDisplay');
                this.uiElements.roomCode = document.getElementById('roomCode');
                this.uiElements.roomCodeInput = document.getElementById('roomCodeInput');
                this.uiElements.roomCodeSection = document.getElementById('roomCodeSection');
                this.uiElements.joinSection = document.getElementById('joinSection');
                this.uiElements.playerListItems = document.getElementById('playerListItems');
                
                // HUD
                this.uiElements.speedValue = document.getElementById('speedValue');
                this.uiElements.productCount = document.getElementById('productCount');
                this.uiElements.profitValue = document.getElementById('profitValue');
                this.uiElements.distanceValue = document.getElementById('distanceValue');
                this.uiElements.productsGrid = document.getElementById('productsGrid');
                this.uiElements.speedNeedle = document.getElementById('speedNeedle');
                
                // End screen
                this.uiElements.endTitle = document.getElementById('endTitle');
                this.uiElements.finalProfit = document.getElementById('finalProfit');
                this.uiElements.deliveredCount = document.getElementById('deliveredCount');
                this.uiElements.totalDistance = document.getElementById('totalDistance');
            }

            async init() {
                // Initialize sound
                this.soundManager.init();
                
                // Initialize Three.js
                this.initThreeJS();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Load assets
                await this.loadAssets();
                
                // Generate initial world
                this.generateWorld();
                
                // Show start menu
                this.showScreen('startMenu');
                
                // Start game loop
                this.gameLoop();
            }

            initThreeJS() {
                console.log('Initializing Three.js...');
                
                const canvas = document.getElementById('gameCanvas');
                
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x1a1a2e, 10, 1000);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    2000
                );
                this.camera.position.set(0, 5, 10);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(100, 200, 100);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 4096;
                directionalLight.shadow.mapSize.height = 4096;
                directionalLight.shadow.camera.left = -200;
                directionalLight.shadow.camera.right = 200;
                directionalLight.shadow.camera.top = 200;
                directionalLight.shadow.camera.bottom = -200;
                this.scene.add(directionalLight);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                console.log('Three.js initialized successfully');
            }

            setupEventListeners() {
                // Keyboard input
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    // Handle pause
                    if (e.key === 'Escape') {
                        this.togglePause();
                    }
                    
                    // Prevent spacebar from scrolling
                    if (e.key === ' ') {
                        e.preventDefault();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Gamepad input
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad.id);
                    this.gamepads[e.gamepad.index] = e.gamepad;
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Gamepad disconnected:', e.gamepad.id);
                    delete this.gamepads[e.gamepad.index];
                });
                
                // UI Button events
                this.uiElements.playSolo.addEventListener('click', () => this.startSoloGame());
                this.uiElements.multiplayer.addEventListener('click', () => this.showScreen('multiplayerLobby'));
                this.uiElements.createRoom.addEventListener('click', () => this.createMultiplayerRoom());
                this.uiElements.joinRoom.addEventListener('click', () => this.showJoinSection());
                this.uiElements.backToMenu.addEventListener('click', () => this.showScreen('startMenu'));
                this.uiElements.startGame.addEventListener('click', () => this.startMultiplayerGame());
                this.uiElements.connectToRoom.addEventListener('click', () => this.joinMultiplayerRoom());
                this.uiElements.resumeGame.addEventListener('click', () => this.togglePause());
                this.uiElements.restartGame.addEventListener('click', () => this.restartGame());
                this.uiElements.quitToMenu.addEventListener('click', () => this.quitToMenu());
                this.uiElements.playAgain.addEventListener('click', () => this.restartGame());
                this.uiElements.endToMenu.addEventListener('click', () => this.quitToMenu());
                
                // Bot count slider
                this.uiElements.botCount.addEventListener('input', (e) => {
                    this.botCount = parseInt(e.target.value);
                    this.uiElements.botCountDisplay.textContent = this.botCount;
                });
            }

            async loadAssets() {
                console.log('Loading assets...');
                
                // Define model paths - try multiple possible locations
                const modelPaths = [
                    'models/cart.glb',
                    'assets/models/cart.glb',
                    './models/cart.glb'
                ];
                
                const soundPaths = {
                    crash: ['sounds/crash.mp3', 'assets/sounds/crash.mp3'],
                    slap: ['sounds/slap.mp3', 'assets/sounds/slap.mp3'],
                    product_destroyed: ['sounds/product_destroyed.mp3', 'assets/sounds/product_destroyed.mp3']
                };
                
                // Try to load models with fallbacks
                const modelTypes = ['cart', 'player', 'crate', 'lamp', 'house'];
                
                for (let i = 0; i < modelTypes.length; i++) {
                    const type = modelTypes[i];
                    
                    // Try multiple possible paths
                    let modelLoaded = false;
                    for (const basePath of ['models/', 'assets/models/', './models/']) {
                        try {
                            await this.modelManager.loadModel(type, `${basePath}${type}.glb`);
                            modelLoaded = true;
                            break;
                        } catch (e) {
                            continue;
                        }
                    }
                    
                    // If no model loaded, use fallback
                    if (!modelLoaded) {
                        console.log(`Using fallback model for ${type}`);
                        this.modelManager.models[type] = await this.modelManager.createFallbackModel(type);
                    }
                    
                    // Update loading progress
                    const progress = Math.floor((i + 1) / modelTypes.length * 90);
                    this.updateLoadingProgress(progress);
                }
                
                // Load sounds
                for (const [type, paths] of Object.entries(soundPaths)) {
                    for (const path of paths) {
                        try {
                            await this.soundManager.loadSound(type, path);
                            break;
                        } catch (e) {
                            continue;
                        }
                    }
                }
                
                // Complete loading
                this.updateLoadingProgress(100);
                console.log('Assets loaded successfully');
            }

            updateLoadingProgress(percent) {
                const progressBar = document.getElementById('loadingProgress');
                const loadingText = document.getElementById('loadingText');
                
                progressBar.style.width = percent + '%';
                
                if (percent < 20) {
                    loadingText.textContent = 'Initializing game engine...';
                } else if (percent < 40) {
                    loadingText.textContent = 'Loading 3D models...';
                } else if (percent < 60) {
                    loadingText.textContent = 'Setting up physics...';
                } else if (percent < 80) {
                    loadingText.textContent = 'Creating game world...';
                } else if (percent < 100) {
                    loadingText.textContent = 'Finalizing...';
                } else {
                    loadingText.textContent = 'Ready to play!';
                }
            }

            showScreen(screenName) {
                // Hide all screens
                Object.values(this.uiElements).forEach(element => {
                    if (element && element.classList && element.classList.contains('screen')) {
                        element.classList.add('hidden');
                    }
                });
                
                // Show requested screen
                if (this.uiElements[screenName]) {
                    this.uiElements[screenName].classList.remove('hidden');
                }
                
                // Update game state
                switch(screenName) {
                    case 'startMenu':
                        this.gameState = 'MENU';
                        break;
                    case 'multiplayerLobby':
                        this.gameState = 'LOBBY';
                        break;
                    case 'playing':
                        this.gameState = 'PLAYING';
                        this.uiElements.hud.classList.remove('hidden');
                        document.getElementById('speedometer').classList.remove('hidden');
                        break;
                    case 'pauseMenu':
                        this.gameState = 'PAUSED';
                        break;
                    case 'endScreen':
                        this.gameState = 'ENDED';
                        break;
                }
            }

            generateWorld() {
                console.log('Generating world...');
                
                // Clear existing world
                this.clearWorld();
                
                // Add ground
                this.addGround();
                
                // Generate very long road with turns
                this.generateLongRoad();
                
                // Add buildings and environment
                this.addEnvironment();
                
                console.log('World generated successfully');
            }

            clearWorld() {
                // Clear road segments
                this.roadSegments.forEach(segment => {
                    if (segment && segment.parent) {
                        this.scene.remove(segment);
                    }
                });
                this.roadSegments = [];
                
                // Clear obstacles
                this.obstacles.forEach(obstacle => {
                    if (obstacle && obstacle.parent) {
                        this.scene.remove(obstacle);
                    }
                });
                this.obstacles = [];
                
                // Clear buildings
                this.buildings.forEach(building => {
                    if (building && building.parent) {
                        this.scene.remove(building);
                    }
                });
                this.buildings = [];
            }

            addGround() {
                const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
                const groundTexture = this.textureManager.createFallbackTexture(0x2d3436);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    map: groundTexture,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.1;
                ground.receiveShadow = true;
                this.scene.add(ground);
            }

            generateLongRoad() {
                const roadWidth = 12;
                const segmentLength = 100;
                const totalSegments = 50; // 50 * 100 = 5000m road
                
                let currentZ = 0;
                this.roadTurnAngle = 0;
                
                for (let i = 0; i < totalSegments; i++) {
                    // Calculate road position with curves
                    const segmentCurve = Math.sin(i * 0.2) * 0.05; // Gentle sine wave curve
                    this.roadCurve = segmentCurve;
                    
                    const roadX = Math.sin(this.roadTurnAngle) * 50; // Road can curve left/right
                    
                    // Create road segment
                    const geometry = new THREE.PlaneGeometry(roadWidth, segmentLength);
                    const roadTexture = this.textureManager.createFallbackTexture(0x333333);
                    const material = new THREE.MeshStandardMaterial({ 
                        map: roadTexture,
                        side: THREE.DoubleSide,
                        roughness: 0.8
                    });
                    
                    const road = new THREE.Mesh(geometry, material);
                    road.rotation.x = -Math.PI / 2;
                    road.position.set(roadX, 0.01, currentZ);
                    road.rotation.y = this.roadTurnAngle;
                    road.receiveShadow = true;
                    
                    this.scene.add(road);
                    this.roadSegments.push(road);
                    
                    // Add road markings
                    this.addRoadMarkings(road.position, road.rotation.y, roadWidth, segmentLength);
                    
                    // Add obstacles (skip first few segments)
                    if (i > 5 && Math.random() > 0.5) {
                        this.addObstacles(road.position, road.rotation.y, roadWidth, segmentLength);
                    }
                    
                    // Update for next segment
                    currentZ -= segmentLength;
                    
                    // Gradually turn the road
                    if (i % 10 === 0) {
                        // Every 10 segments, decide to turn left, right, or continue straight
                        const turnChoice = Math.random();
                        if (turnChoice < 0.3) {
                            this.roadTurnAngle += Math.PI / 8; // Turn left
                        } else if (turnChoice < 0.6) {
                            this.roadTurnAngle -= Math.PI / 8; // Turn right
                        }
                        // Clamp turn angle to prevent extreme turns
                        this.roadTurnAngle = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, this.roadTurnAngle));
                    }
                }
            }

            addRoadMarkings(position, rotation, roadWidth, segmentLength) {
                // Center line (dashed)
                const dashLength = 5;
                const gapLength = 3;
                const dashCount = Math.floor(segmentLength / (dashLength + gapLength));
                
                for (let i = 0; i < dashCount; i++) {
                    const lineGeometry = new THREE.PlaneGeometry(0.3, dashLength);
                    const lineMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffff00,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.5
                    });
                    
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    const zOffset = (i * (dashLength + gapLength)) - segmentLength/2 + dashLength/2;
                    line.position.set(0, 0.02, zOffset);
                    line.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);
                    line.position.add(position);
                    line.rotation.y = rotation;
                    
                    this.scene.add(line);
                }
                
                // Side lines
                const sideLineGeometry = new THREE.PlaneGeometry(0.5, segmentLength);
                const sideLineMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.3
                });
                
                const leftLine = new THREE.Mesh(sideLineGeometry, sideLineMaterial);
                leftLine.rotation.x = -Math.PI / 2;
                leftLine.position.set(-roadWidth/2, 0.02, 0);
                leftLine.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);
                leftLine.position.add(position);
                leftLine.rotation.y = rotation;
                this.scene.add(leftLine);
                
                const rightLine = leftLine.clone();
                rightLine.position.set(roadWidth/2, 0.02, 0);
                rightLine.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);
                rightLine.position.add(position);
                rightLine.rotation.y = rotation;
                this.scene.add(rightLine);
            }

            addObstacles(position, rotation, roadWidth, segmentLength) {
                const obstacleTypes = ['crate', 'lamp', 'house'];
                const obstacleCount = Math.floor(Math.random() * 4) + 1;
                
                for (let i = 0; i < obstacleCount; i++) {
                    const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                    const model = this.modelManager.getModel(type);
                    
                    if (!model) {
                        console.warn(`Model ${type} not found, skipping obstacle`);
                        continue;
                    }
                    
                    const obstacle = model.scene.clone();
                    
                    // Position obstacle
                    const side = Math.random() > 0.5 ? 1 : -1;
                    const xPos = (roadWidth/2 + 3) * side;
                    const zOffset = (Math.random() - 0.5) * segmentLength * 0.7;
                    
                    obstacle.position.set(xPos, 0, zOffset);
                    
                    // Adjust based on type
                    if (type === 'crate') {
                        obstacle.position.y = 0.5;
                    } else if (type === 'lamp') {
                        obstacle.position.y = 0;
                    } else if (type === 'house') {
                        obstacle.position.y = 0;
                        obstacle.scale.setScalar(0.6 + Math.random() * 0.4);
                    }
                    
                    // Apply rotation and position
                    obstacle.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);
                    obstacle.position.add(position);
                    obstacle.rotation.y = rotation + (Math.random() - 0.5) * Math.PI / 4;
                    
                    // Add physics properties
                    obstacle.userData = {
                        type: type,
                        damage: type === 'crate' ? 25 : type === 'lamp' ? 15 : 35,
                        collided: false
                    };
                    
                    // Ensure shadows
                    obstacle.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    this.scene.add(obstacle);
                    this.obstacles.push(obstacle);
                }
            }

            addEnvironment() {
                // Add buildings along the road
                const buildingCount = 100;
                
                for (let i = 0; i < buildingCount; i++) {
                    const building = this.createBuilding();
                    
                    // Position buildings on sides of road
                    const side = i % 2 === 0 ? 1 : -1;
                    const distance = 15 + Math.random() * 20;
                    const zPos = -i * 50 - Math.random() * 100;
                    
                    building.position.set(distance * side, 0, zPos);
                    building.rotation.y = (Math.random() - 0.5) * Math.PI / 2;
                    building.scale.setScalar(0.8 + Math.random() * 0.4);
                    
                    this.scene.add(building);
                    this.buildings.push(building);
                }
                
                // Add trees and other props
                this.addProps();
            }

            createBuilding() {
                const building = new THREE.Group();
                
                // Base
                const width = 6 + Math.random() * 4;
                const height = 4 + Math.random() * 6;
                const depth = 6 + Math.random() * 4;
                
                const baseGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingTexture = this.textureManager.createFallbackTexture(
                    Math.random() > 0.5 ? 0x3742fa : 0x5352ed
                );
                const baseMaterial = new THREE.MeshStandardMaterial({ 
                    map: buildingTexture,
                    roughness: 0.7,
                    metalness: 0.2
                });
                
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = height / 2;
                base.castShadow = true;
                base.receiveShadow = true;
                building.add(base);
                
                // Roof
                const roofGeometry = new THREE.ConeGeometry(width * 0.8, 2, 4);
                const roofMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff6b6b,
                    roughness: 0.8
                });
                
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = height + 1;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                building.add(roof);
                
                // Windows
                const windowGeometry = new THREE.PlaneGeometry(0.8, 1);
                const windowMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.4
                });
                
                for (let i = 0; i < 4; i++) {
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    const side = i % 2 === 0 ? 1 : -1;
                    const isFront = i < 2;
                    
                    window.position.set(
                        isFront ? 0 : (width/2 + 0.01) * side,
                        height * 0.6,
                        isFront ? (depth/2 + 0.01) * side : 0
                    );
                    
                    if (!isFront) {
                        window.rotation.y = Math.PI / 2;
                    }
                    
                    building.add(window);
                }
                
                return building;
            }

            addProps() {
                // Add trees, bushes, etc.
                const propCount = 200;
                
                for (let i = 0; i < propCount; i++) {
                    const prop = this.createTree();
                    
                    // Random position in environment
                    const side = i % 2 === 0 ? 1 : -1;
                    const distance = 30 + Math.random() * 50;
                    const zPos = -i * 25 - Math.random() * 50;
                    const xPos = distance * side + (Math.random() - 0.5) * 20;
                    
                    prop.position.set(xPos, 0, zPos);
                    prop.scale.setScalar(0.5 + Math.random() * 0.5);
                    
                    this.scene.add(prop);
                }
            }

            createTree() {
                const tree = new THREE.Group();
                
                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2);
                const trunkMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9
                });
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1;
                trunk.castShadow = true;
                tree.add(trunk);
                
                // Leaves
                const leavesGeometry = new THREE.ConeGeometry(1.5, 3, 8);
                const leavesMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x2ed573,
                    roughness: 0.8
                });
                
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 3;
                leaves.castShadow = true;
                tree.add(leaves);
                
                return tree;
            }

            startSoloGame() {
                console.log('Starting solo game with', this.botCount, 'bots');
                this.isMultiplayer = false;
                
                // Clear any existing players/bots
                this.resetGameObjects();
                
                // Create player
                this.createPlayer(0, false);
                
                // Create bots
                for (let i = 0; i < this.botCount; i++) {
                    this.createBot(i);
                }
                
                // Start game
                this.startGame();
            }

            createMultiplayerRoom() {
                // Generate room code
                this.roomCode = Math.random().toString(36).substring(2, 6).toUpperCase();
                this.uiElements.roomCode.textContent = this.roomCode;
                
                // Show room code section
                this.uiElements.roomCodeSection.classList.remove('hidden');
                
                console.log('Creating multiplayer room:', this.roomCode);
                
                // For demo, simulate host player
                this.createPlayer(0, true);
                this.updatePlayerList();
            }

            showJoinSection() {
                this.uiElements.joinSection.classList.remove('hidden');
            }

            joinMultiplayerRoom() {
                const code = this.uiElements.roomCodeInput.value.toUpperCase();
                if (code.length === 4) {
                    this.roomCode = code;
                    this.uiElements.roomCode.textContent = code;
                    this.uiElements.roomCodeSection.classList.remove('hidden');
                    this.uiElements.joinSection.classList.add('hidden');
                    
                    console.log('Joining room:', code);
                } else {
                    alert('Please enter a 4-character room code');
                }
            }

            updatePlayerList() {
                this.uiElements.playerListItems.innerHTML = '';
                
                // Add host
                const hostItem = document.createElement('li');
                hostItem.innerHTML = `
                    <div class="player-color" style="background: #ff4757;"></div>
                    <span>Host (You)</span>
                `;
                this.uiElements.playerListItems.appendChild(hostItem);
            }

            startMultiplayerGame() {
                console.log('Starting multiplayer game');
                this.isMultiplayer = true;
                this.startGame();
            }

            startGame() {
                // Reset game state
                this.currentSegment = 0;
                this.lastTime = performance.now();
                
                // Show game HUD
                this.showScreen('playing');
                
                // Initialize products display
                this.updateProductsDisplay();
                
                // Focus canvas for keyboard input
                document.getElementById('gameCanvas').focus();
                
                console.log('Game started!');
            }

            createPlayer(id, isMultiplayer) {
                const cartModel = this.modelManager.getModel('cart');
                const playerModel = this.modelManager.getModel('player');
                
                if (!cartModel || !playerModel) {
                    console.error('Cart or player model not found');
                    return null;
                }
                
                const cart = cartModel.scene.clone();
                const player = playerModel.scene.clone();
                
                // Position player in cart
                player.position.set(0, 0.8, 0);
                cart.add(player);
                
                // Set initial position
                const startX = (id % 4) * 4 - 6;
                cart.position.set(startX, 0.5, 0);
                cart.rotation.y = Math.PI;
                
                // Ensure shadows
                cart.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Add to scene
                this.scene.add(cart);
                
                // Store player data
                const playerData = {
                    id: id,
                    cart: cart,
                    player: player,
                    speed: 0,
                    maxSpeed: 45,
                    acceleration: 0.9,
                    braking: 1.8,
                    steering: 0.06,
                    health: 100,
                    products: this.maxProducts,
                    profit: 0,
                    distance: 0,
                    boostCooldown: 0,
                    isBot: false,
                    isMultiplayer: isMultiplayer,
                    color: id === 0 ? 0xff4757 : 0x70a1ff
                };
                
                // Color the cart
                cart.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.color.setHex(playerData.color);
                    }
                });
                
                this.carts.push(cart);
                this.players.push(playerData);
                
                return playerData;
            }

            createBot(id) {
                const playerData = this.createPlayer(id + 1, false);
                if (!playerData) return;
                
                playerData.isBot = true;
                playerData.color = 0xff6b6b;
                playerData.acceleration = 0.7 + Math.random() * 0.3;
                playerData.maxSpeed = 40 + Math.random() * 15;
                playerData.steering = 0.04 + Math.random() * 0.04;
                
                // Color the bot cart
                playerData.cart.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.color.setHex(playerData.color);
                    }
                });
                
                this.bots.push(playerData);
            }

            processInput() {
                // Reset input
                this.input.steering = 0;
                this.input.throttle = 0;
                this.input.brake = 0;
                this.input.boost = false;
                
                // Keyboard input
                if (this.keys['w'] || this.keys['arrowup']) this.input.throttle = 1;
                if (this.keys['s'] || this.keys['arrowdown']) this.input.brake = 1;
                if (this.keys['a'] || this.keys['arrowleft']) this.input.steering = 1;
                if (this.keys['d'] || this.keys['arrowright']) this.input.steering = -1;
                if (this.keys[' ']) this.input.boost = true;
                
                // Gamepad input
                for (const index in this.gamepads) {
                    const gamepad = navigator.getGamepads()[index];
                    if (!gamepad) continue;
                    
                    // Left stick for steering
                    if (Math.abs(gamepad.axes[0]) > 0.1) {
                        this.input.steering = -gamepad.axes[0];
                    }
                    
                    // Triggers for throttle/brake
                    if (gamepad.axes.length > 2) {
                        const triggerValue = (gamepad.axes[2] + 1) / 2;
                        if (triggerValue > 0.1) this.input.throttle = triggerValue;
                    }
                    
                    if (gamepad.axes.length > 5) {
                        const brakeValue = (gamepad.axes[5] + 1) / 2;
                        if (brakeValue > 0.1) this.input.brake = brakeValue;
                    }
                    
                    // A button for boost
                    if (gamepad.buttons[0]?.pressed) {
                        this.input.boost = true;
                    }
                    
                    // Start button for pause
                    if (gamepad.buttons[9]?.pressed) {
                        this.togglePause();
                    }
                }
            }

            updatePlayer(player, deltaTime) {
                if (!player || !player.cart) return;
                
                // Update boost cooldown
                if (player.boostCooldown > 0) {
                    player.boostCooldown -= deltaTime;
                }
                
                if (!player.isBot) {
                    // Human player input
                    const steering = this.input.steering || 0;
                    const throttle = this.input.throttle || 0;
                    const brake = this.input.brake || 0;
                    const boost = this.input.boost || false;
                    
                    // Apply boost
                    let boostMultiplier = 1;
                    if (boost && player.boostCooldown <= 0) {
                        boostMultiplier = 2.2;
                        player.boostCooldown = 3;
                    }
                    
                    // Calculate speed
                    if (throttle > 0 && player.speed < player.maxSpeed) {
                        player.speed += player.acceleration * throttle * deltaTime * 60 * boostMultiplier;
                    }
                    
                    if (brake > 0 && player.speed > -player.maxSpeed * 0.5) {
                        player.speed -= player.acceleration * player.braking * brake * deltaTime * 60;
                    }
                    
                    // Apply friction
                    if (throttle === 0 && brake === 0) {
                        player.speed *= Math.pow(0.97, deltaTime * 60);
                    }
                    
                    // Apply steering
                    const steeringEffect = Math.min(Math.abs(player.speed) / 10, 1);
                    if (Math.abs(player.speed) > 1) {
                        player.cart.rotation.y += steering * player.steering * steeringEffect * deltaTime * 60;
                    }
                    
                    // Move cart
                    const direction = new THREE.Vector3(0, 0, 1);
                    direction.applyQuaternion(player.cart.quaternion);
                    player.cart.position.add(direction.multiplyScalar(player.speed * deltaTime));
                    
                    // Apply road curve effect
                    const curveInfluence = Math.abs(player.speed) / player.maxSpeed;
                    player.cart.position.x += this.roadCurve * curveInfluence * deltaTime * 30;
                    
                    // Keep cart on ground with bounce
                    const targetY = 0.5 + Math.sin(Date.now() * 0.01) * 0.05 * Math.abs(player.speed) / player.maxSpeed;
                    player.cart.position.y = targetY;
                    
                    // Update distance
                    player.distance += Math.abs(player.speed) * deltaTime;
                    
                    // Update camera
                    if (this.players[0] === player) {
                        this.updateCamera(player);
                    }
                    
                    // Update HUD
                    this.updateHUD(player);
                } else {
                    // Bot AI
                    this.updateBotAI(player, deltaTime);
                }
                
                // Check collisions
                this.checkCollisions(player);
                
                // Add wobble effect
                if (Math.abs(player.speed) > 5) {
                    const wobble = Math.sin(Date.now() * 0.005 + player.id) * 0.02 * (player.speed / player.maxSpeed);
                    player.cart.rotation.z = wobble;
                }
                
                // Check if player fell off the world
                if (player.cart.position.y < -10) {
                    player.cart.position.set(0, 5, 0);
                    player.speed = 0;
                    player.health -= 20;
                    this.soundManager.play('crash');
                }
            }

            updateBotAI(bot, deltaTime) {
                // Simple bot AI with road following
                let targetPlayer = this.players.find(p => !p.isBot && p.products > 0);
                
                if (targetPlayer && Math.random() > 0.2) {
                    // Chase player
                    const direction = new THREE.Vector3()
                        .subVectors(targetPlayer.cart.position, bot.cart.position)
                        .normalize();
                    
                    const botForward = new THREE.Vector3(0, 0, 1).applyQuaternion(bot.cart.quaternion);
                    const angle = botForward.angleTo(direction);
                    const cross = new THREE.Vector3().crossVectors(botForward, direction);
                    const steerDirection = cross.y > 0 ? 1 : -1;
                    
                    const randomFactor = 0.4 + Math.random() * 0.3;
                    bot.cart.rotation.y += steerDirection * bot.steering * randomFactor * deltaTime * 60;
                    
                    // Accelerate
                    if (bot.speed < bot.maxSpeed * 0.85) {
                        bot.speed += bot.acceleration * deltaTime * 60;
                    }
                    
                    // Random boost
                    if (Math.random() > 0.98 && bot.boostCooldown <= 0) {
                        bot.speed *= 1.6;
                        bot.boostCooldown = 5;
                    }
                    
                    // Random mistakes
                    if (Math.random() > 0.99) {
                        bot.cart.rotation.y += (Math.random() - 0.5) * 1.5;
                        bot.speed *= 0.7;
                    }
                } else {
                    // Follow road
                    if (bot.speed < bot.maxSpeed * 0.7) {
                        bot.speed += bot.acceleration * 0.6 * deltaTime * 60;
                    }
                    
                    // Gentle steering to stay on road
                    const roadCenter = Math.sin(this.roadTurnAngle) * 50;
                    const offsetFromCenter = bot.cart.position.x - roadCenter;
                    bot.cart.rotation.y -= offsetFromCenter * 0.01 * deltaTime * 60;
                }
                
                // Move bot
                const direction = new THREE.Vector3(0, 0, 1);
                direction.applyQuaternion(bot.cart.quaternion);
                bot.cart.position.add(direction.multiplyScalar(bot.speed * deltaTime));
                
                // Apply road curve
                const curveInfluence = Math.abs(bot.speed) / bot.maxSpeed;
                bot.cart.position.x += this.roadCurve * curveInfluence * deltaTime * 30;
                
                bot.cart.position.y = 0.5;
                bot.distance += Math.abs(bot.speed) * deltaTime;
            }

            updateCamera(player) {
                if (!player || !player.cart) return;
                
                // Dynamic camera distance based on speed
                const speedFactor = Math.min(player.speed / player.maxSpeed, 1);
                const baseDistance = 10;
                const baseHeight = 4;
                const extraDistance = speedFactor * 5;
                const extraHeight = speedFactor * 2;
                
                const distance = baseDistance + extraDistance;
                const height = baseHeight + extraHeight;
                
                // Calculate camera position
                const offset = new THREE.Vector3(0, height, distance);
                offset.applyQuaternion(player.cart.quaternion);
                
                const targetPosition = player.cart.position.clone().add(offset);
                const lookAtPosition = player.cart.position.clone();
                lookAtPosition.y += 1;
                
                // Smooth camera movement
                this.camera.position.lerp(targetPosition, 0.1);
                this.camera.lookAt(lookAtPosition);
                
                // Camera shake on low health
                if (player.health < 50) {
                    const shakeIntensity = (100 - player.health) / 200;
                    this.camera.position.x += (Math.random() - 0.5) * 0.2 * shakeIntensity;
                    this.camera.position.y += (Math.random() - 0.5) * 0.2 * shakeIntensity;
                }
            }

            updateHUD(player) {
                if (!player) return;
                
                // Speed
                const speedKmh = Math.abs(player.speed * 3.6);
                this.uiElements.speedValue.textContent = `${speedKmh.toFixed(0)} km/h`;
                
                // Speedometer needle
                const maxSpeed = 150;
                const angle = (speedKmh / maxSpeed) * Math.PI - Math.PI / 2;
                this.uiElements.speedNeedle.style.transform = `translateX(-50%) rotate(${angle}rad)`;
                
                // Products
                this.uiElements.productCount.textContent = `${player.products}/${this.maxProducts}`;
                
                // Profit (increase with speed and products)
                if (player.speed > 5) {
                    player.profit += (player.speed / 10) * (player.products / this.maxProducts) * 0.15;
                }
                this.uiElements.profitValue.textContent = `$${player.profit.toFixed(0)}`;
                
                // Distance to goal
                const remainingDistance = Math.max(0, this.roadLength - player.distance);
                this.uiElements.distanceValue.textContent = `${remainingDistance.toFixed(0)}m`;
                
                // Update product display
                this.updateProductDamageDisplay(player);
                
                // Check win condition
                if (remainingDistance <= 0) {
                    this.endGame(player, true);
                }
            }

            updateProductsDisplay() {
                this.uiElements.productsGrid.innerHTML = '';
                
                for (let i = 0; i < this.maxProducts; i++) {
                    const product = document.createElement('div');
                    product.className = 'product-item';
                    product.textContent = '';
                    product.dataset.index = i;
                    this.uiElements.productsGrid.appendChild(product);
                }
            }

            updateProductDamageDisplay(player) {
                const products = this.uiElements.productsGrid.querySelectorAll('.product-item');
                products.forEach((product, index) => {
                    if (index >= player.products) {
                        product.classList.add('damaged');
                    } else {
                        product.classList.remove('damaged');
                    }
                });
            }

            checkCollisions(player) {
                if (!player || !player.cart) return;
                
                // Check obstacle collisions
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    if (!obstacle || !obstacle.userData) continue;
                    
                    const distance = player.cart.position.distanceTo(obstacle.position);
                    const collisionDistance = obstacle.userData.type === 'house' ? 4 : 2;
                    
                    if (distance < collisionDistance && !obstacle.userData.collided) {
                        this.handleCollision(player, obstacle);
                        obstacle.userData.collided = true;
                        
                        setTimeout(() => {
                            if (obstacle.userData) {
                                obstacle.userData.collided = false;
                            }
                        }, 1000);
                    }
                }
                
                // Check bot collisions
                for (const bot of this.bots) {
                    if (bot === player || !bot.cart) continue;
                    
                    const distance = player.cart.position.distanceTo(bot.cart.position);
                    const collisionDistance = 2.5;
                    
                    if (distance < collisionDistance) {
                        this.handleBotCollision(player, bot);
                    }
                }
                
                // Check road boundaries
                const roadHalfWidth = 6;
                if (Math.abs(player.cart.position.x) > roadHalfWidth + 10) {
                    // Way off road - damage
                    if (Math.random() > 0.7) {
                        player.products = Math.max(0, player.products - 1);
                        player.health -= 3;
                        
                        if (player.products === 0) {
                            this.endGame(player, false);
                        }
                        
                        this.soundManager.play('product_destroyed');
                    }
                }
            }

            handleCollision(player, obstacle) {
                const damage = obstacle.userData.damage || 15;
                player.health -= damage;
                player.products = Math.max(0, player.products - 1);
                player.profit = Math.max(0, player.profit - 25);
                
                // Play sound based on obstacle type
                if (obstacle.userData.type === 'crate') {
                    this.soundManager.play('crash');
                } else if (obstacle.userData.type === 'lamp') {
                    this.soundManager.play('slap');
                } else {
                    this.soundManager.play('crash');
                }
                
                // Bounce effect
                const bounceDirection = new THREE.Vector3()
                    .subVectors(player.cart.position, obstacle.position)
                    .normalize();
                
                player.cart.position.add(bounceDirection.multiplyScalar(2));
                player.speed *= -0.4;
                
                // Visual feedback
                player.cart.traverse(child => {
                    if (child.isMesh && child.material) {
                        const originalColor = child.material.color.clone();
                        child.material.color.setHex(0xff0000);
                        setTimeout(() => {
                            if (child.material) {
                                child.material.color.copy(originalColor);
                            }
                        }, 150);
                    }
                });
                
                if (player.health <= 0 || player.products === 0) {
                    this.endGame(player, false);
                }
            }

            handleBotCollision(player, bot) {
                player.products = Math.max(0, player.products - 1);
                player.profit = Math.max(0, player.profit - 15);
                
                this.soundManager.play('slap');
                
                const pushDirection = new THREE.Vector3()
                    .subVectors(player.cart.position, bot.cart.position)
                    .normalize();
                
                player.cart.position.add(pushDirection.multiplyScalar(2.5));
                player.speed *= 0.6;
                bot.speed *= 0.8;
                
                if (player.products === 0) {
                    this.endGame(player, false);
                }
            }

            togglePause() {
                if (this.gameState === 'PLAYING') {
                    this.gameState = 'PAUSED';
                    this.showScreen('pauseMenu');
                } else if (this.gameState === 'PAUSED') {
                    this.gameState = 'PLAYING';
                    this.showScreen('playing');
                }
            }

            endGame(player, won) {
                this.gameState = 'ENDED';
                
                this.uiElements.endTitle.textContent = won ? 'Delivery Complete!' : 'Delivery Failed!';
                this.uiElements.endTitle.style.color = won ? '#2ed573' : '#ff4757';
                
                this.uiElements.finalProfit.textContent = `$${player.profit.toFixed(0)}`;
                this.uiElements.deliveredCount.textContent = `${player.products}/${this.maxProducts}`;
                this.uiElements.totalDistance.textContent = `${player.distance.toFixed(0)}m`;
                
                this.showScreen('endScreen');
            }

            resetGameObjects() {
                // Clear players
                this.players.forEach(player => {
                    if (player.cart && player.cart.parent) {
                        this.scene.remove(player.cart);
                    }
                });
                
                // Clear bots
                this.bots.forEach(bot => {
                    if (bot.cart && bot.cart.parent) {
                        this.scene.remove(bot.cart);
                    }
                });
                
                // Reset arrays
                this.players = [];
                this.bots = [];
                this.carts = [];
            }

            restartGame() {
                this.resetGameObjects();
                
                if (this.isMultiplayer) {
                    this.showScreen('multiplayerLobby');
                } else {
                    this.startSoloGame();
                }
            }

            quitToMenu() {
                this.resetGameObjects();
                this.showScreen('startMenu');
            }

            gameLoop(currentTime = 0) {
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                const fixedDelta = Math.min(deltaTime, 0.033);
                
                this.processInput();
                
                if (this.gameState === 'PLAYING') {
                    this.players.forEach(player => {
                        this.updatePlayer(player, fixedDelta);
                    });
                    
                    this.bots.forEach(bot => {
                        this.updatePlayer(bot, fixedDelta);
                    });
                }
                
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }

        // Start the game
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof THREE === 'undefined') {
                alert('Error: THREE.js failed to load. Please check your internet connection.');
                return;
            }
            
            window.game = new CartRidersGame();
        });
    </script>
</body>
</html>
