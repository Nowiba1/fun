<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cart Riders: Delivery Chaos</title>
    
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #0a0a1a;
            color: white;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            outline: none;
        }

        /* UI Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0a0a1a 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .hidden {
            display: none !important;
        }

        .ui-panel {
            background: linear-gradient(145deg, rgba(30, 30, 50, 0.95), rgba(20, 20, 40, 0.98));
            padding: 40px;
            border-radius: 24px;
            border: 3px solid #00ff88;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.5),
                0 0 60px rgba(0, 255, 136, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            max-width: 600px;
            width: 90%;
            backdrop-filter: blur(20px);
            animation: panelSlide 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes panelSlide {
            from { 
                opacity: 0; 
                transform: translateY(-50px) scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }

        h1 {
            font-size: 4.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-align: center;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            font-weight: 900;
            letter-spacing: 2px;
        }

        h2 {
            font-size: 2.2rem;
            margin-bottom: 30px;
            color: #00aaff;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }

        .btn {
            padding: 18px 36px;
            font-size: 1.3rem;
            background: linear-gradient(135deg, #00ff88, #00aaff);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            margin: 12px;
            min-width: 220px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 8px 25px rgba(0, 255, 136, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.2), 
                transparent);
            transition: 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 
                0 15px 35px rgba(0, 255, 136, 0.4),
                0 0 30px rgba(0, 255, 136, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn:active {
            transform: translateY(-2px) scale(0.98);
        }

        .btn.secondary {
            background: linear-gradient(135deg, #ff5500, #ffaa00);
            box-shadow: 
                0 8px 25px rgba(255, 85, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn.secondary:hover {
            box-shadow: 
                0 15px 35px rgba(255, 85, 0, 0.4),
                0 0 30px rgba(255, 85, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .input-group {
            margin: 25px 0;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #00ff88;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        input, select {
            width: 100%;
            padding: 15px;
            font-size: 1.1rem;
            border: 2px solid #00aaff;
            border-radius: 12px;
            background: rgba(0, 20, 40, 0.8);
            color: white;
            transition: all 0.3s;
            box-shadow: 
                inset 0 2px 10px rgba(0, 0, 0, 0.5),
                0 0 15px rgba(0, 170, 255, 0.3);
        }

        input:focus, select:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 
                inset 0 2px 10px rgba(0, 0, 0, 0.5),
                0 0 25px rgba(0, 255, 136, 0.5);
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 12px;
            background: linear-gradient(90deg, #00ff88, #00aaff);
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #ff5500;
            cursor: pointer;
            box-shadow: 
                0 0 20px rgba(255, 85, 0, 0.8),
                0 0 40px rgba(255, 85, 0, 0.4);
            border: 2px solid white;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 25px;
            left: 25px;
            background: rgba(0, 10, 20, 0.9);
            padding: 20px;
            border-radius: 20px;
            border: 3px solid #00ff88;
            min-width: 280px;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 10px 30px rgba(0, 255, 136, 0.2),
                inset 0 0 20px rgba(0, 255, 136, 0.1);
            z-index: 10;
            animation: hudSlide 0.5s ease-out;
        }

        @keyframes hudSlide {
            from { 
                opacity: 0; 
                transform: translateX(-50px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }

        .hud-item {
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hud-label {
            color: #88ffaa;
            font-weight: bold;
            font-size: 1.2rem;
            margin-right: 20px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .hud-value {
            color: white;
            font-size: 1.4rem;
            font-weight: bold;
            text-shadow: 
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 255, 255, 0.4);
        }

        .progress-container {
            margin: 15px 0;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(0, 255, 136, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, 
                #00ff88 0%, 
                #00cc66 25%, 
                #00aaff 50%, 
                #0088ff 75%, 
                #ff5500 100%);
            transition: width 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
            animation: progressShine 2s infinite;
        }

        @keyframes progressShine {
            0% { left: -100%; }
            100% { left: 200%; }
        }

        /* Player List */
        .player-list-container {
            position: absolute;
            top: 25px;
            right: 25px;
            background: rgba(20, 0, 10, 0.9);
            padding: 20px;
            border-radius: 20px;
            border: 3px solid #ff5500;
            min-width: 250px;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 10px 30px rgba(255, 85, 0, 0.2),
                inset 0 0 20px rgba(255, 85, 0, 0.1);
            z-index: 10;
        }

        .player-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 12px;
            border-radius: 10px;
            background: linear-gradient(90deg, 
                rgba(255, 85, 0, 0.2), 
                rgba(255, 170, 0, 0.1));
            border: 1px solid rgba(255, 85, 0, 0.3);
            transition: all 0.3s;
        }

        .player-entry:hover {
            background: linear-gradient(90deg, 
                rgba(255, 85, 0, 0.4), 
                rgba(255, 170, 0, 0.3));
            transform: translateX(-5px);
            box-shadow: 0 5px 15px rgba(255, 85, 0, 0.3);
        }

        .player-name {
            color: white;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .player-products {
            color: #00ff88;
            font-weight: bold;
            font-size: 1.2rem;
        }

        /* Loading Screen */
        .loading-container {
            text-align: center;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(0, 255, 136, 0.1);
            border-top: 8px solid #00ff88;
            border-right: 8px solid #00aaff;
            border-bottom: 8px solid #ff5500;
            border-left: 8px solid #ffaa00;
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            margin: 30px auto;
            box-shadow: 
                0 0 30px rgba(0, 255, 136, 0.5),
                0 0 60px rgba(0, 170, 255, 0.3);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-progress {
            width: 400px;
            height: 25px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            margin: 30px auto;
            border: 2px solid rgba(0, 255, 136, 0.3);
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, rgba(255, 85, 0, 0.95), rgba(255, 170, 0, 0.95));
            padding: 25px 50px;
            border-radius: 20px;
            border: 3px solid #ffff88;
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
            z-index: 2000;
            animation: notificationPop 2s forwards;
            text-align: center;
            box-shadow: 
                0 0 50px rgba(255, 85, 0, 0.7),
                0 0 100px rgba(255, 170, 0, 0.5);
            max-width: 80%;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        @keyframes notificationPop {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5) rotate(-10deg); 
            }
            15% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1) rotate(5deg); 
            }
            30% { 
                transform: translate(-50%, -50%) scale(0.95) rotate(-3deg); 
            }
            45% { 
                transform: translate(-50%, -50%) scale(1.05) rotate(2deg); 
            }
            60%, 85% { 
                transform: translate(-50%, -50%) scale(1) rotate(0deg); 
                opacity: 1; 
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.8) rotate(10deg); 
            }
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            border: 3px solid #00aaff;
            backdrop-filter: blur(5px);
            overflow: hidden;
            z-index: 10;
        }

        .minimap-content {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Instructions */
        .instructions {
            position: absolute;
            bottom: 25px;
            left: 25px;
            background: rgba(10, 10, 0, 0.9);
            padding: 20px;
            border-radius: 20px;
            border: 3px solid #ffaa00;
            max-width: 350px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .instruction-item {
            margin: 8px 0;
            color: #ffff88;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
        }

        .key {
            display: inline-block;
            background: linear-gradient(145deg, #333, #000);
            padding: 8px 15px;
            border-radius: 8px;
            margin: 0 8px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
            border: 2px solid #ffaa00;
            box-shadow: 
                0 4px 0 #cc8800,
                inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }

        /* Touch Controls */
        .touch-controls {
            position: absolute;
            bottom: 25px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 25px;
            z-index: 10;
            pointer-events: none;
        }

        .touch-control-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }

        .touch-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.3);
            border: 3px solid #00ff88;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 5px 15px rgba(0, 255, 136, 0.3),
                inset 0 0 20px rgba(0, 255, 136, 0.2);
            touch-action: manipulation;
            user-select: none;
        }

        .touch-button:active {
            transform: scale(0.95);
            background: rgba(0, 255, 136, 0.5);
        }

        .touch-joystick {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(0, 170, 255, 0.3);
            border: 3px solid #00aaff;
            position: relative;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
        }

        .joystick-handle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        /* Mobile detection */
        @media (hover: hover) and (pointer: fine) {
            .touch-controls {
                display: none;
            }
        }

        @media (hover: none) and (pointer: coarse) {
            .instructions {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Loading Screen -->
        <div id="loadingScreen" class="screen">
            <div class="ui-panel">
                <h1>CART RIDERS</h1>
                <h2>Delivery Chaos</h2>
                <div class="loading-container">
                    <div class="loading-spinner"></div>
                    <div class="loading-progress">
                        <div id="loadingProgressBar" class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div id="loadingText" style="color: #88ffaa; margin-top: 20px; font-size: 1.2rem;">
                        Loading game world...
                    </div>
                </div>
            </div>
        </div>

        <!-- Start Menu -->
        <div id="startMenu" class="screen hidden">
            <div class="ui-panel">
                <h1>CART RIDERS</h1>
                <h2>Delivery Chaos</h2>
                
                <div class="input-group">
                    <label for="playerName">Player Name:</label>
                    <input type="text" id="playerName" value="Cart Rider" maxlength="15">
                </div>

                <div class="input-group">
                    <label for="botCount">AI Bots (0-4):</label>
                    <input type="range" id="botCount" min="0" max="4" value="2">
                    <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                        <span style="color: #88ffaa;">None</span>
                        <span id="botCountDisplay" style="color: #00ff88; font-weight: bold;">2</span>
                        <span style="color: #88ffaa;">Maximum</span>
                    </div>
                </div>

                <div style="text-align: center; margin: 40px 0;">
                    <button class="btn" onclick="game.startSoloGame()">üéÆ Solo Game</button>
                    <button class="btn secondary" onclick="game.showScreen('multiplayerMenu')">üë• Multiplayer</button>
                    <button class="btn secondary" onclick="game.showScreen('settingsMenu')">‚öôÔ∏è Settings</button>
                </div>
            </div>
        </div>

        <!-- Multiplayer Menu -->
        <div id="multiplayerMenu" class="screen hidden">
            <div class="ui-panel">
                <h2>Multiplayer</h2>
                
                <div class="input-group">
                    <label for="roomCode">Room Code:</label>
                    <input type="text" id="roomCode" placeholder="Enter 6-digit code" maxlength="6" style="text-align: center; letter-spacing: 3px;">
                </div>

                <div style="text-align: center; margin: 40px 0;">
                    <button class="btn" onclick="game.createRoom()">üè† Create Room</button>
                    <button class="btn" onclick="game.joinRoom()">üîó Join Room</button>
                    <button class="btn secondary" onclick="game.showScreen('startMenu')">‚¨Ö Back</button>
                </div>
            </div>
        </div>

        <!-- Settings Menu -->
        <div id="settingsMenu" class="screen hidden">
            <div class="ui-panel">
                <h2>Settings</h2>
                
                <div class="input-group">
                    <label for="graphicsQuality">Graphics Quality:</label>
                    <select id="graphicsQuality">
                        <option value="low">Low (Fastest)</option>
                        <option value="medium" selected>Medium (Balanced)</option>
                        <option value="high">High (Quality)</option>
                        <option value="ultra">Ultra (Best)</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="cameraSensitivity">Camera Sensitivity:</label>
                    <input type="range" id="cameraSensitivity" min="0.5" max="2" step="0.1" value="1">
                    <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                        <span style="color: #88ffaa;">Slow</span>
                        <span id="sensitivityDisplay" style="color: #00ff88; font-weight: bold;">Normal</span>
                        <span style="color: #88ffaa;">Fast</span>
                    </div>
                </div>

                <div style="text-align: center; margin: 40px 0;">
                    <button class="btn" onclick="game.saveSettings()">üíæ Save Settings</button>
                    <button class="btn secondary" onclick="game.showScreen('startMenu')">‚¨Ö Back</button>
                </div>
            </div>
        </div>

        <!-- Game HUD -->
        <div id="hud" class="hidden">
            <div class="hud-item">
                <span class="hud-label">üí∞ Profit:</span>
                <span class="hud-value" id="profitValue">$0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">üì¶ Products:</span>
                <span class="hud-value" id="productValue">100/100</span>
            </div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div id="productFill" class="progress-fill" style="width: 100%"></div>
                </div>
            </div>
            <div class="hud-item">
                <span class="hud-label">üöÄ Speed:</span>
                <span class="hud-value" id="speedValue">0 km/h</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">üéØ Distance:</span>
                <span class="hud-value" id="distanceValue">0m</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">‚ö° Boost:</span>
                <span class="hud-value" id="boostValue">100%</span>
            </div>
        </div>

        <!-- Player List -->
        <div id="playerList" class="player-list-container hidden">
            <h3 style="color: #ff5500; margin-bottom: 15px; text-align: center;">Players</h3>
            <div id="playerListContent">
                <!-- Player entries will be added here -->
            </div>
        </div>

        <!-- Minimap -->
        <div id="minimap" class="hidden">
            <div class="minimap-content">
                <canvas id="minimapCanvas"></canvas>
            </div>
        </div>

        <!-- Instructions -->
        <div id="instructions" class="instructions hidden">
            <h3 style="color: #ffaa00; margin-bottom: 15px; text-align: center;">Controls</h3>
            <div class="instruction-item">
                <span class="key">W</span> / <span class="key">‚Üë</span> <span>Accelerate</span>
            </div>
            <div class="instruction-item">
                <span class="key">A</span> <span class="key">D</span> / <span class="key">‚Üê</span> <span class="key">‚Üí</span> <span>Steer</span>
            </div>
            <div class="instruction-item">
                <span class="key">SPACE</span> <span>Boost</span>
            </div>
            <div class="instruction-item">
                <span class="key">S</span> / <span class="key">‚Üì</span> <span>Brake</span>
            </div>
            <div class="instruction-item">
                <span class="key">ESC</span> <span>Pause</span>
            </div>
        </div>

        <!-- Touch Controls -->
        <div class="touch-controls hidden">
            <div class="touch-control-group">
                <div class="touch-button" id="touchBoost">‚ö°</div>
                <div class="touch-button" id="touchBrake">‚èπÔ∏è</div>
            </div>
            <div class="touch-joystick" id="touchJoystick">
                <div class="joystick-handle"></div>
            </div>
            <div class="touch-control-group">
                <div class="touch-button" id="touchMenu">‚â°</div>
                <div class="touch-button" id="touchReset">üîÑ</div>
            </div>
        </div>

        <!-- Notification Container -->
        <div id="notificationContainer"></div>
    </div>

    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            // Core Settings
            MAX_PLAYERS: 8,
            MAX_BOTS: 4,
            INITIAL_PRODUCTS: 100,
            PRODUCT_VALUE: 10,
            ROAD_WIDTH: 30,
            LANE_WIDTH: 10,
            MAX_SPEED: 120,
            BOOST_POWER: 2.0,
            BOOST_DURATION: 3,
            BOOST_COOLDOWN: 5,
            BOT_SPAWN_DELAY: 10, // Seconds between bot spawns
            BOT_SPAWN_SPEED_THRESHOLD: 30, // Player speed required for bot spawn
            
            // Camera Settings
            CAMERA_DISTANCE: 25,
            CAMERA_HEIGHT: 12,
            CAMERA_SMOOTHNESS: 0.1,
            CAMERA_LEAN_FACTOR: 0.3,
            CAMERA_ZOOM_FACTOR: 0.5,
            
            // Physics Settings
            GRAVITY: 9.8,
            FRICTION: 0.97,
            STEERING_SENSITIVITY: 0.08,
            DRIFT_FACTOR: 0.92,
            TURN_FORCE: 0.05,
            
            // World Settings
            ROAD_SEGMENT_LENGTH: 100,
            BUILDING_SPACING: 5,
            BUILDING_VARIATION: 3,
            TURN_CHANCE: 0.2,
            HILL_CHANCE: 0.1,
            WEATHER_CHANGE_INTERVAL: 60, // Seconds
            
            // Performance Settings
            MAX_OBSTACLES: 100,
            MAX_BUILDINGS: 200,
            RENDER_DISTANCE: 1000,
            OBJECT_POOL_SIZE: 50
        };

        // ============================================
        // GAME STATE MANAGEMENT
        // ============================================
        class GameState {
            constructor() {
                // Game State
                this.screen = 'loading';
                this.gameActive = false;
                this.paused = false;
                this.gameTime = 0;
                this.deltaTime = 0.016;
                this.lastTime = 0;
                
                // Players
                this.players = new Map();
                this.bots = [];
                this.localPlayer = null;
                this.playerCount = 0;
                
                // World
                this.world = null;
                this.camera = null;
                this.renderer = null;
                this.scene = null;
                
                // Input
                this.keys = {};
                this.touchInput = {
                    joystickX: 0,
                    joystickY: 0,
                    boost: false,
                    brake: false
                };
                
                // Settings
                this.settings = {
                    graphicsQuality: 'medium',
                    cameraSensitivity: 1.0,
                    volume: 80,
                    showInstructions: true
                };
                
                // Performance
                this.frameCount = 0;
                this.fps = 60;
                this.lastFpsUpdate = 0;
                
                // Game Data
                this.score = 0;
                this.distance = 0;
                this.productsDelivered = 0;
                this.productsLost = 0;
            }
        }

        // ============================================
        // ASSET MANAGER
        // ============================================
        class AssetManager {
            constructor() {
                this.models = new Map();
                this.textures = new Map();
                this.loader = new THREE.GLTFLoader();
                this.textureLoader = new THREE.TextureLoader();
                this.loadedAssets = 0;
                this.totalAssets = 0;
            }

            async loadAllAssets() {
                const assetList = [
                    { type: 'model', name: 'cart', path: 'models/cart.glb' },
                    { type: 'model', name: 'player', path: 'models/player.glb' },
                    { type: 'model', name: 'building1', path: 'models/building1.glb' },
                    { type: 'model', name: 'building2', path: 'models/building2.glb' },
                    { type: 'model', name: 'building3', path: 'models/building3.glb' }
                ];

                this.totalAssets = assetList.length;
                
                for (const asset of assetList) {
                    try {
                        if (asset.type === 'model') {
                            await this.loadModel(asset.name, asset.path);
                        } else if (asset.type === 'texture') {
                            await this.loadTexture(asset.name, asset.path);
                        }
                    } catch (error) {
                        console.warn(`Failed to load ${asset.name}:`, error);
                        // Create placeholder
                        if (asset.type === 'model') {
                            this.createPlaceholderModel(asset.name);
                        }
                    }
                    this.updateProgress();
                }
                
                // Create procedural textures
                this.createProceduralTextures();
            }

            loadModel(name, path) {
                return new Promise((resolve, reject) => {
                    this.loader.load(
                        path,
                        (gltf) => {
                            this.models.set(name, gltf.scene);
                            resolve();
                        },
                        undefined,
                        (error) => {
                            reject(error);
                        }
                    );
                });
            }

            loadTexture(name, path) {
                return new Promise((resolve, reject) => {
                    this.textureLoader.load(
                        path,
                        (texture) => {
                            this.textures.set(name, texture);
                            resolve();
                        },
                        undefined,
                        (error) => {
                            reject(error);
                        }
                    );
                });
            }

            createPlaceholderModel(type) {
                let geometry, material;
                
                switch(type) {
                    case 'cart':
                        geometry = new THREE.BoxGeometry(2, 1.5, 4);
                        material = new THREE.MeshStandardMaterial({ 
                            color: 0xff5500,
                            metalness: 0.3,
                            roughness: 0.7
                        });
                        break;
                    case 'player':
                        geometry = new THREE.BoxGeometry(0.8, 1.8, 0.4);
                        material = new THREE.MeshStandardMaterial({ 
                            color: 0x00aaff,
                            metalness: 0.2,
                            roughness: 0.8
                        });
                        break;
                    default: // building
                        geometry = new THREE.BoxGeometry(8, 15, 8);
                        material = new THREE.MeshStandardMaterial({ 
                            color: 0x888888,
                            metalness: 0.1,
                            roughness: 0.9
                        });
                }
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.models.set(type, mesh);
            }

            createProceduralTextures() {
                // Create building textures
                const buildingTextures = ['brick', 'concrete', 'glass', 'metal'];
                
                buildingTextures.forEach(type => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    switch(type) {
                        case 'brick':
                            ctx.fillStyle = '#b7410e';
                            ctx.fillRect(0, 0, 256, 256);
                            ctx.strokeStyle = '#8b310a';
                            ctx.lineWidth = 2;
                            for(let y = 0; y < 256; y += 32) {
                                for(let x = 0; x < 256; x += 64) {
                                    ctx.strokeRect(x + (y % 64 === 0 ? 32 : 0), y, 64, 32);
                                }
                            }
                            break;
                        case 'concrete':
                            ctx.fillStyle = '#9e9e9e';
                            ctx.fillRect(0, 0, 256, 256);
                            for(let i = 0; i < 1000; i++) {
                                const gray = 100 + Math.random() * 100;
                                ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                                ctx.fillRect(
                                    Math.random() * 256,
                                    Math.random() * 256,
                                    Math.random() * 3 + 1,
                                    Math.random() * 3 + 1
                                );
                            }
                            break;
                        case 'glass':
                            const gradient = ctx.createLinearGradient(0, 0, 256, 256);
                            gradient.addColorStop(0, 'rgba(100, 200, 255, 0.8)');
                            gradient.addColorStop(1, 'rgba(50, 150, 255, 0.4)');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(0, 0, 256, 256);
                            break;
                        case 'metal':
                            ctx.fillStyle = '#cccccc';
                            ctx.fillRect(0, 0, 256, 256);
                            ctx.fillStyle = '#aaaaaa';
                            for(let i = 0; i < 100; i++) {
                                ctx.fillRect(
                                    Math.random() * 256,
                                    Math.random() * 256,
                                    4, 20
                                );
                                ctx.fillRect(
                                    Math.random() * 256,
                                    Math.random() * 256,
                                    20, 4
                                );
                            }
                            break;
                    }
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    this.textures.set(type, texture);
                });
                
                // Create road texture
                const roadCanvas = document.createElement('canvas');
                roadCanvas.width = 512;
                roadCanvas.height = 512;
                const roadCtx = roadCanvas.getContext('2d');
                
                // Asphalt
                roadCtx.fillStyle = '#333333';
                roadCtx.fillRect(0, 0, 512, 512);
                
                // Add noise for asphalt texture
                for(let i = 0; i < 5000; i++) {
                    const gray = 40 + Math.random() * 30;
                    roadCtx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                    roadCtx.fillRect(
                        Math.random() * 512,
                        Math.random() * 512,
                        Math.random() * 2 + 1,
                        Math.random() * 2 + 1
                    );
                }
                
                // Lane markings
                roadCtx.fillStyle = '#ffff00';
                const laneWidth = 512 / 3;
                for(let i = 1; i < 3; i++) {
                    for(let j = 0; j < 10; j++) {
                        roadCtx.fillRect(
                            laneWidth * i - 1,
                            j * 50 + 10,
                            2,
                            30
                        );
                    }
                }
                
                const roadTexture = new THREE.CanvasTexture(roadCanvas);
                roadTexture.wrapS = THREE.RepeatWrapping;
                roadTexture.wrapT = THREE.RepeatWrapping;
                roadTexture.repeat.set(8, 50);
                this.textures.set('road', roadTexture);
            }

            updateProgress() {
                this.loadedAssets++;
                const percent = Math.round((this.loadedAssets / this.totalAssets) * 100);
                
                document.getElementById('loadingProgressBar').style.width = `${percent}%`;
                document.getElementById('loadingText').textContent = 
                    `Loading assets... ${percent}%`;
            }
        }

        // ============================================
        // WORLD GENERATOR
        // ============================================
        class WorldGenerator {
            constructor() {
                this.roadPoints = [];
                this.buildings = [];
                this.roadMeshes = [];
                this.currentRoadIndex = 0;
                this.roadCurvature = 0;
                this.roadSlope = 0;
                this.roadBanking = 0;
                this.lastPlayerZ = 0;
                
                // Road segments pool
                this.roadPool = [];
                this.buildingPool = [];
                this.initObjectPools();
            }

            initObjectPools() {
                // Create road segment pool
                for(let i = 0; i < CONFIG.OBJECT_POOL_SIZE; i++) {
                    const geometry = new THREE.PlaneGeometry(CONFIG.ROAD_WIDTH, CONFIG.ROAD_SEGMENT_LENGTH);
                    const material = new THREE.MeshStandardMaterial({
                        map: game.assets.textures.get('road'),
                        side: THREE.DoubleSide,
                        roughness: 0.9,
                        metalness: 0.1
                    });
                    const road = new THREE.Mesh(geometry, material);
                    road.rotation.x = -Math.PI / 2;
                    road.receiveShadow = true;
                    road.visible = false;
                    game.scene.add(road);
                    this.roadPool.push(road);
                }
                
                // Create building pool
                for(let i = 0; i < CONFIG.MAX_BUILDINGS; i++) {
                    const building = this.createRandomBuilding();
                    building.visible = false;
                    game.scene.add(building);
                    this.buildingPool.push(building);
                }
            }

            generateInitialWorld() {
                // Generate initial road points
                for(let i = 0; i < 20; i++) {
                    this.generateRoadPoint(-i * CONFIG.ROAD_SEGMENT_LENGTH);
                }
                
                // Create initial road meshes
                this.updateRoadMeshes();
                
                // Create initial buildings
                this.generateBuildings();
            }

            generateRoadPoint(z) {
                // Add variation to road
                this.roadCurvature += (Math.random() - 0.5) * 0.1;
                this.roadCurvature = Math.max(-0.3, Math.min(0.3, this.roadCurvature));
                
                this.roadSlope += (Math.random() - 0.5) * 0.05;
                this.roadSlope = Math.max(-0.2, Math.min(0.2, this.roadSlope));
                
                this.roadBanking = this.roadCurvature * 0.5;
                
                const x = this.roadCurvature * 100;
                const y = this.roadSlope * 50;
                
                this.roadPoints.push({
                    x: x,
                    y: y,
                    z: z,
                    curvature: this.roadCurvature,
                    slope: this.roadSlope,
                    banking: this.roadBanking
                });
                
                // Keep road points manageable
                if(this.roadPoints.length > 100) {
                    this.roadPoints.shift();
                }
            }

            updateRoadMeshes() {
                // Use object pool for road segments
                for(let i = 0; i < this.roadPool.length; i++) {
                    if(i < this.roadPoints.length - 1) {
                        const point = this.roadPoints[i];
                        const nextPoint = this.roadPoints[i + 1];
                        const road = this.roadPool[i];
                        
                        if(road) {
                            road.position.set(
                                (point.x + nextPoint.x) / 2,
                                point.y,
                                point.z
                            );
                            
                            // Calculate rotation based on slope and banking
                            const slopeAngle = Math.atan2(nextPoint.y - point.y, CONFIG.ROAD_SEGMENT_LENGTH);
                            road.rotation.x = -Math.PI / 2 + slopeAngle;
                            road.rotation.z = point.banking;
                            
                            road.visible = true;
                            this.roadMeshes[i] = road;
                        }
                    } else {
                        if(this.roadPool[i]) {
                            this.roadPool[i].visible = false;
                        }
                    }
                }
            }

            createRandomBuilding() {
                // Get building model or create placeholder
                let building;
                const buildingTypes = ['building1', 'building2', 'building3'];
                const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                
                if(game.assets.models.has(type)) {
                    building = game.assets.models.get(type).clone();
                } else {
                    // Create procedural building
                    const width = 8 + Math.random() * 8;
                    const height = 15 + Math.random() * 20;
                    const depth = 8 + Math.random() * 8;
                    
                    const geometry = new THREE.BoxGeometry(width, height, depth);
                    const textureType = ['brick', 'concrete', 'glass', 'metal'][Math.floor(Math.random() * 4)];
                    const texture = game.assets.textures.get(textureType);
                    
                    const material = new THREE.MeshStandardMaterial({
                        map: texture,
                        roughness: 0.8,
                        metalness: textureType === 'metal' ? 0.6 : 0.1
                    });
                    
                    building = new THREE.Mesh(geometry, material);
                    
                    // Add windows
                    const windowGeometry = new THREE.BoxGeometry(width * 0.8, height * 0.7, 0.1);
                    const windowMaterial = new THREE.MeshStandardMaterial({
                        color: 0x88ccff,
                        emissive: 0x88ccff,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.7
                    });
                    const windows = new THREE.Mesh(windowGeometry, windowMaterial);
                    windows.position.y = height * 0.1;
                    building.add(windows);
                }
                
                building.castShadow = true;
                building.receiveShadow = true;
                
                // Add collision box
                building.userData = {
                    type: 'building',
                    width: 10,
                    height: 20,
                    depth: 10
                };
                
                return building;
            }

            generateBuildings() {
                // Place buildings along the road
                let buildingIndex = 0;
                let lastBuildingZ = -1000;
                
                for(let i = 0; i < this.roadPoints.length; i += 5) {
                    const point = this.roadPoints[i];
                    
                    // Place buildings on both sides
                    for(let side = -1; side <= 1; side += 2) {
                        if(buildingIndex >= this.buildingPool.length) break;
                        
                        const building = this.buildingPool[buildingIndex];
                        if(!building) continue;
                        
                        // Random gap between buildings (0-3 meters)
                        const gap = Math.random() * 3;
                        const buildingZ = point.z - (Math.abs(side) - 1) * gap;
                        
                        if(buildingZ - lastBuildingZ < CONFIG.BUILDING_SPACING) continue;
                        
                        // Position building
                        const roadOffset = CONFIG.ROAD_WIDTH / 2 + 5 + Math.random() * 10;
                        const x = point.x + side * roadOffset;
                        const y = point.y;
                        
                        building.position.set(x, y, buildingZ);
                        
                        // Random rotation for variety
                        building.rotation.y = Math.random() * Math.PI / 4 * side;
                        
                        // Random scale variation
                        const scale = 0.8 + Math.random() * 0.4;
                        building.scale.set(scale, scale, scale);
                        
                        building.visible = true;
                        
                        this.buildings.push({
                            mesh: building,
                            x: x,
                            z: buildingZ,
                            side: side
                        });
                        
                        buildingIndex++;
                        lastBuildingZ = buildingZ;
                    }
                }
                
                // Hide unused buildings
                for(let i = buildingIndex; i < this.buildingPool.length; i++) {
                    this.buildingPool[i].visible = false;
                }
            }

            update(playerZ) {
                // Generate new road points as player moves
                while(this.roadPoints.length < 50 || 
                      playerZ - this.roadPoints[this.roadPoints.length - 1].z < 500) {
                    const lastPoint = this.roadPoints[this.roadPoints.length - 1];
                    this.generateRoadPoint(lastPoint.z - CONFIG.ROAD_SEGMENT_LENGTH);
                }
                
                // Update road meshes
                this.updateRoadMeshes();
                
                // Update buildings
                this.updateBuildings(playerZ);
                
                // Clean up old road points
                while(this.roadPoints.length > 0 && 
                      playerZ - this.roadPoints[0].z > CONFIG.RENDER_DISTANCE) {
                    this.roadPoints.shift();
                }
                
                this.lastPlayerZ = playerZ;
            }

            updateBuildings(playerZ) {
                // Remove buildings that are too far behind
                this.buildings = this.buildings.filter(building => {
                    if(playerZ - building.z > CONFIG.RENDER_DISTANCE) {
                        building.mesh.visible = false;
                        return false;
                    }
                    return true;
                });
                
                // Add new buildings ahead
                const lastBuilding = this.buildings[this.buildings.length - 1];
                if(!lastBuilding || playerZ - lastBuilding.z < 200) {
                    this.generateBuildings();
                }
            }

            getRoadPosition(z) {
                // Find road point at given z position
                for(let i = 0; i < this.roadPoints.length - 1; i++) {
                    const p1 = this.roadPoints[i];
                    const p2 = this.roadPoints[i + 1];
                    
                    if(z >= p1.z && z <= p2.z) {
                        const t = (z - p1.z) / (p2.z - p1.z);
                        return {
                            x: p1.x + (p2.x - p1.x) * t,
                            y: p1.y + (p2.y - p1.y) * t,
                            rotation: p1.banking + (p2.banking - p1.banking) * t
                        };
                    }
                }
                
                return { x: 0, y: 0, rotation: 0 };
            }
        }

        // ============================================
        // PLAYER SYSTEM
        // ============================================
        class PlayerSystem {
            constructor() {
                this.players = new Map();
                this.bots = [];
                this.localPlayerId = null;
            }

            createPlayer(id, name, isLocal = false) {
                const player = {
                    id: id,
                    name: name,
                    isLocal: isLocal,
                    isBot: false,
                    
                    // Physics
                    position: new THREE.Vector3(0, 1, 0),
                    rotation: 0,
                    velocity: new THREE.Vector3(0, 0, 0),
                    speed: 0,
                    
                    // Game stats
                    products: CONFIG.INITIAL_PRODUCTS,
                    profit: 0,
                    boost: 100,
                    distance: 0,
                    
                    // Visual
                    cart: null,
                    character: null,
                    
                    // State
                    drifting: false,
                    boosting: false,
                    boostCooldown: 0,
                    lastCollision: 0
                };
                
                // Create visual
                this.createPlayerVisual(player);
                
                this.players.set(id, player);
                
                if(isLocal) {
                    this.localPlayerId = id;
                    game.state.localPlayer = player;
                }
                
                return player;
            }

            createPlayerVisual(player) {
                // Create cart
                let cart;
                if(game.assets.models.has('cart')) {
                    cart = game.assets.models.get('cart').clone();
                } else {
                    const geometry = new THREE.BoxGeometry(2, 1.5, 4);
                    const material = new THREE.MeshStandardMaterial({
                        color: player.isLocal ? 0x00ff88 : 0xff5500,
                        metalness: 0.3,
                        roughness: 0.7
                    });
                    cart = new THREE.Mesh(geometry, material);
                }
                
                cart.scale.set(1.5, 1.5, 1.5);
                cart.castShadow = true;
                cart.receiveShadow = true;
                
                // Create character
                let character;
                if(game.assets.models.has('player')) {
                    character = game.assets.models.get('player').clone();
                } else {
                    const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.4);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x00aaff,
                        metalness: 0.2,
                        roughness: 0.8
                    });
                    character = new THREE.Mesh(geometry, material);
                }
                
                character.position.y = 1.2;
                character.castShadow = true;
                character.receiveShadow = true;
                
                cart.add(character);
                game.scene.add(cart);
                
                player.cart = cart;
                player.character = character;
            }

            updatePlayer(player, deltaTime) {
                if(!player.cart) return;
                
                // Update boost
                if(player.boostCooldown > 0) {
                    player.boostCooldown -= deltaTime;
                }
                
                if(player.boosting && player.boost > 0 && player.boostCooldown <= 0) {
                    player.boost -= 20 * deltaTime;
                    if(player.boost <= 0) {
                        player.boosting = false;
                        player.boostCooldown = CONFIG.BOOST_COOLDOWN;
                    }
                } else if(!player.boosting && player.boost < 100) {
                    player.boost = Math.min(100, player.boost + 15 * deltaTime);
                }
                
                // Get input
                let steering = 0;
                let throttle = 0;
                let brake = false;
                
                if(player.isLocal) {
                    // Local player input
                    steering = game.input.steering;
                    throttle = game.input.throttle;
                    brake = game.input.brake;
                    
                    if(game.input.boost && player.boost > 10 && !player.boosting && player.boostCooldown <= 0) {
                        player.boosting = true;
                    }
                }
                
                // Apply physics
                this.applyPhysics(player, steering, throttle, brake, deltaTime);
                
                // Update position based on road
                this.updatePositionOnRoad(player);
                
                // Update visual
                this.updatePlayerVisual(player, deltaTime);
                
                // Update distance
                player.distance += Math.abs(player.speed) * deltaTime;
                
                // Update profit
                if(player.speed > 5) {
                    const profitGain = player.speed * deltaTime * CONFIG.PRODUCT_VALUE * 
                                     (player.products / CONFIG.INITIAL_PRODUCTS);
                    player.profit += profitGain;
                    game.state.score += profitGain;
                }
                
                // Check collisions
                this.checkCollisions(player);
                
                // Update game state
                game.state.distance = Math.max(game.state.distance, player.distance);
            }

            applyPhysics(player, steering, throttle, brake, deltaTime) {
                // Acceleration
                if(throttle > 0) {
                    const acceleration = 30 * deltaTime * throttle;
                    player.speed = Math.min(player.speed + acceleration, CONFIG.MAX_SPEED);
                }
                
                // Braking
                if(brake) {
                    const deceleration = 40 * deltaTime;
                    player.speed = Math.max(player.speed - deceleration, -CONFIG.MAX_SPEED * 0.3);
                }
                
                // Coasting
                if(throttle === 0 && !brake) {
                    player.speed *= Math.pow(CONFIG.FRICTION, deltaTime * 60);
                    if(Math.abs(player.speed) < 0.5) player.speed = 0;
                }
                
                // Boost
                if(player.boosting && player.speed > 5) {
                    player.speed = Math.min(player.speed * CONFIG.BOOST_POWER, CONFIG.MAX_SPEED * 1.5);
                }
                
                // Steering (affected by speed)
                const steeringFactor = 1 - (player.speed / CONFIG.MAX_SPEED) * 0.6;
                const steeringPower = Math.PI / 3 * steeringFactor * deltaTime * 8;
                
                player.rotation += steering * steeringPower * game.state.settings.cameraSensitivity;
                
                // Drifting
                player.drifting = Math.abs(steering) > 0.5 && player.speed > 30;
                if(player.drifting) {
                    player.speed *= CONFIG.DRIFT_FACTOR;
                    player.rotation += steering * steeringPower * 1.5;
                }
                
                // Calculate velocity
                player.velocity.x = Math.sin(player.rotation) * player.speed;
                player.velocity.z = Math.cos(player.rotation) * player.speed;
            }

            updatePositionOnRoad(player) {
                // Get road position at player's z
                const roadPos = game.world.getRoadPosition(player.position.z);
                
                // Move player
                player.position.x += player.velocity.x * game.state.deltaTime;
                player.position.z += player.velocity.z * game.state.deltaTime;
                player.position.y = roadPos.y + 1;
                
                // Constrain to road
                const halfWidth = CONFIG.ROAD_WIDTH / 2 - 3;
                if(Math.abs(player.position.x - roadPos.x) > halfWidth) {
                    player.position.x = roadPos.x + Math.sign(player.position.x - roadPos.x) * halfWidth;
                    
                    // Damage products if hitting road edge
                    const now = Date.now();
                    if(now - player.lastCollision > 1000) {
                        player.products = Math.max(0, player.products - 5);
                        player.lastCollision = now;
                        game.showNotification('üí• Road Edge! -5 Products');
                    }
                }
                
                // Update cart position and rotation
                if(player.cart) {
                    player.cart.position.copy(player.position);
                    
                    // Add banking based on road curvature
                    const targetRotation = player.rotation + roadPos.rotation;
                    player.cart.rotation.y = targetRotation;
                    
                    // Add tilt based on steering
                    const lean = game.input.steering * CONFIG.CAMERA_LEAN_FACTOR;
                    player.cart.rotation.z = -lean;
                    
                    // Bounce animation
                    const bounce = Math.sin(Date.now() * 0.005 * player.speed) * 0.1;
                    player.cart.position.y += bounce;
                    
                    // Character animation
                    if(player.character) {
                        const bob = Math.sin(Date.now() * 0.01 * player.speed) * 0.2;
                        player.character.position.y = 1.2 + bob;
                    }
                }
            }

            updatePlayerVisual(player, deltaTime) {
                // Add visual effects based on state
                if(player.cart) {
                    // Boost effect
                    if(player.boosting) {
                        const boostIntensity = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                        player.cart.traverse(child => {
                            if(child.isMesh && child.material.emissive) {
                                child.material.emissive.setHex(0x00ffff);
                                child.material.emissiveIntensity = boostIntensity;
                            }
                        });
                    }
                    
                    // Damage effect
                    const damagePercent = 1 - (player.products / CONFIG.INITIAL_PRODUCTS);
                    if(damagePercent > 0.5) {
                        const pulse = Math.sin(Date.now() * 0.005) * 0.5 + 0.5;
                        player.cart.traverse(child => {
                            if(child.isMesh) {
                                child.material.color.lerp(
                                    new THREE.Color(0xff0000),
                                    damagePercent * pulse * deltaTime
                                );
                            }
                        });
                    }
                }
            }

            checkCollisions(player) {
                // Check building collisions
                for(const building of game.world.buildings) {
                    if(!building.mesh.visible) continue;
                    
                    const dx = player.position.x - building.x;
                    const dz = player.position.z - building.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if(distance < 8) {
                        // Push player away from building
                        const pushForce = player.speed * 0.5;
                        player.position.x += (dx / distance) * pushForce * game.state.deltaTime;
                        player.position.z += (dz / distance) * pushForce * game.state.deltaTime;
                        
                        // Damage
                        const now = Date.now();
                        if(now - player.lastCollision > 500) {
                            const damage = Math.floor(Math.abs(player.speed) * 0.5) + 10;
                            player.products = Math.max(0, player.products - damage);
                            player.lastCollision = now;
                            game.showNotification(`üí• Building! -${damage} Products`);
                        }
                        
                        player.speed *= 0.5;
                        break;
                    }
                }
            }

            spawnBot() {
                if(this.bots.length >= CONFIG.MAX_BOTS) return null;
                
                const botId = `bot_${Date.now()}`;
                const bot = this.createPlayer(botId, `ü§ñ Bot ${this.bots.length + 1}`, false);
                bot.isBot = true;
                
                // Position bot behind player
                const player = game.state.localPlayer;
                if(player) {
                    bot.position.z = player.position.z - 50;
                    bot.position.x = (Math.random() - 0.5) * CONFIG.ROAD_WIDTH * 0.8;
                }
                
                // Bot settings
                bot.speed = 20 + Math.random() * 10;
                bot.aggression = 0.5 + Math.random() * 0.5;
                bot.skill = 0.3 + Math.random() * 0.7;
                bot.lastDecision = 0;
                bot.targetSpeed = bot.speed;
                
                this.bots.push(bot);
                return bot;
            }

            updateBots(deltaTime) {
                const player = game.state.localPlayer;
                if(!player) return;
                
                // Spawn new bots based on player speed
                const now = Date.now();
                if(this.bots.length < CONFIG.MAX_BOTS && 
                   player.speed > CONFIG.BOT_SPAWN_SPEED_THRESHOLD &&
                   now - game.state.lastBotSpawn > CONFIG.BOT_SPAWN_DELAY * 1000) {
                    this.spawnBot();
                    game.state.lastBotSpawn = now;
                }
                
                // Update each bot
                for(const bot of this.bots) {
                    if(!bot.cart) continue;
                    
                    // AI Decision making
                    if(now - bot.lastDecision > 1000) {
                        bot.lastDecision = now;
                        
                        // Choose behavior
                        const behaviors = ['follow', 'attack', 'avoid', 'overtake'];
                        const behavior = behaviors[Math.floor(Math.random() * behaviors.length)];
                        
                        switch(behavior) {
                            case 'follow':
                                bot.targetSpeed = player.speed * (0.8 + Math.random() * 0.4);
                                break;
                            case 'attack':
                                bot.targetSpeed = player.speed * 1.2;
                                break;
                            case 'avoid':
                                bot.targetSpeed = player.speed * 0.6;
                                break;
                            case 'overtake':
                                bot.targetSpeed = CONFIG.MAX_SPEED * 0.9;
                                break;
                        }
                    }
                    
                    // Smooth speed adjustment
                    const speedDiff = bot.targetSpeed - bot.speed;
                    if(Math.abs(speedDiff) > 1) {
                        bot.speed += Math.sign(speedDiff) * 10 * deltaTime;
                    }
                    
                    // Steering AI
                    const dx = player.position.x - bot.position.x;
                    const distance = Math.abs(dx);
                    const sameLane = distance < CONFIG.LANE_WIDTH / 2;
                    
                    let steering = 0;
                    
                    if(sameLane && bot.speed > player.speed * 1.1) {
                        // Try to overtake
                        steering = dx > 0 ? -1 : 1;
                    } else if(!sameLane) {
                        // Move toward player's lane
                        steering = dx > 0 ? 1 : -1;
                    } else {
                        // Random slight steering
                        steering = (Math.random() - 0.5) * 0.5;
                    }
                    
                    // Apply steering
                    const steeringFactor = 1 - (bot.speed / CONFIG.MAX_SPEED) * 0.6;
                    const steeringPower = Math.PI / 4 * steeringFactor * deltaTime * 6;
                    bot.rotation += steering * steeringPower * bot.skill;
                    
                    // Calculate velocity
                    bot.velocity.x = Math.sin(bot.rotation) * bot.speed;
                    bot.velocity.z = Math.cos(bot.rotation) * bot.speed;
                    
                    // Update position
                    bot.position.x += bot.velocity.x * deltaTime;
                    bot.position.z += bot.velocity.z * deltaTime;
                    
                    // Constrain to road
                    const roadPos = game.world.getRoadPosition(bot.position.z);
                    const halfWidth = CONFIG.ROAD_WIDTH / 2 - 3;
                    if(Math.abs(bot.position.x - roadPos.x) > halfWidth) {
                        bot.position.x = roadPos.x + Math.sign(bot.position.x - roadPos.x) * halfWidth;
                        bot.rotation += Math.PI * 0.5; // Turn away from edge
                    }
                    
                    // Update visual
                    if(bot.cart) {
                        bot.cart.position.copy(bot.position);
                        bot.cart.position.y = roadPos.y + 1;
                        bot.cart.rotation.y = bot.rotation + roadPos.rotation;
                        
                        // Bounce animation
                        const bounce = Math.sin(Date.now() * 0.005 * bot.speed) * 0.1;
                        bot.cart.position.y += bounce;
                    }
                    
                    // Check collision with player
                    const playerDistance = bot.position.distanceTo(player.position);
                    if(playerDistance < 3 && now - bot.lastCollision > 1000) {
                        const damage = Math.floor(Math.abs(bot.speed) * 0.3) + 5;
                        player.products = Math.max(0, player.products - damage);
                        bot.lastCollision = now;
                        game.showNotification(`ü§ñ Bot Attack! -${damage} Products`);
                    }
                }
                
                // Remove bots that are too far behind
                this.bots = this.bots.filter(bot => {
                    if(player.position.z - bot.position.z > 200) {
                        if(bot.cart) {
                            game.scene.remove(bot.cart);
                        }
                        this.players.delete(bot.id);
                        return false;
                    }
                    return true;
                });
            }
        }

        // ============================================
        // CAMERA SYSTEM
        // ============================================
        class CameraSystem {
            constructor(camera) {
                this.camera = camera;
                this.target = null;
                this.offset = new THREE.Vector3(0, CONFIG.CAMERA_HEIGHT, CONFIG.CAMERA_DISTANCE);
                this.currentOffset = this.offset.clone();
                this.lookAt = new THREE.Vector3(0, 2, 0);
                this.smoothness = CONFIG.CAMERA_SMOOTHNESS;
                this.shakeIntensity = 0;
                this.shakeDecay = 0.9;
            }

            setTarget(target) {
                this.target = target;
            }

            update(deltaTime) {
                if(!this.target || !this.target.cart) return;
                
                // Get target position and rotation
                const targetPos = this.target.cart.position;
                const targetRot = this.target.cart.rotation;
                
                // Calculate desired camera position (in front of player)
                const desiredOffset = this.offset.clone();
                
                // Zoom based on speed
                const speedFactor = Math.min(this.target.speed / CONFIG.MAX_SPEED, 1);
                const zoomFactor = 1 + speedFactor * CONFIG.CAMERA_ZOOM_FACTOR;
                desiredOffset.multiplyScalar(zoomFactor);
                
                // Apply target rotation to offset
                desiredOffset.applyQuaternion(this.target.cart.quaternion);
                
                // Add camera shake
                if(this.shakeIntensity > 0) {
                    desiredOffset.x += (Math.random() - 0.5) * this.shakeIntensity;
                    desiredOffset.y += (Math.random() - 0.5) * this.shakeIntensity;
                    desiredOffset.z += (Math.random() - 0.5) * this.shakeIntensity;
                    this.shakeIntensity *= this.shakeDecay;
                }
                
                // Calculate desired position
                const desiredPosition = targetPos.clone().add(desiredOffset);
                
                // Smooth interpolation
                this.currentOffset.lerp(desiredOffset, this.smoothness * deltaTime * 60);
                
                // Update camera position
                this.camera.position.copy(targetPos).add(this.currentOffset);
                
                // Calculate look-at point (slightly ahead of player)
                const lookAtOffset = new THREE.Vector3(0, 2, 5);
                lookAtOffset.applyQuaternion(this.target.cart.quaternion);
                this.lookAt.copy(targetPos).add(lookAtOffset);
                
                // Look at point with smooth interpolation
                const currentLookAt = this.camera.getWorldDirection(new THREE.Vector3())
                    .multiplyScalar(10)
                    .add(this.camera.position);
                currentLookAt.lerp(this.lookAt, this.smoothness * deltaTime * 60 * 0.8);
                
                this.camera.lookAt(currentLookAt);
            }

            shake(intensity = 0.5) {
                this.shakeIntensity = Math.max(this.shakeIntensity, intensity);
            }
        }

        // ============================================
        // WEATHER & TIME SYSTEM
        // ============================================
        class WeatherSystem {
            constructor(scene) {
                this.scene = scene;
                this.currentTime = 12; // 12:00 noon
                this.timeSpeed = 0.1; // Real seconds per game hour
                this.weather = 'clear';
                this.lights = [];
                this.fog = null;
                this.skybox = null;
                
                this.init();
            }

            init() {
                // Create sun
                this.sun = new THREE.DirectionalLight(0xffffff, 1.5);
                this.sun.position.set(100, 200, 100);
                this.sun.castShadow = true;
                this.sun.shadow.mapSize.width = 4096;
                this.sun.shadow.mapSize.height = 4096;
                this.sun.shadow.camera.left = -200;
                this.sun.shadow.camera.right = 200;
                this.sun.shadow.camera.top = 200;
                this.sun.shadow.camera.bottom = -200;
                this.scene.add(this.sun);
                
                // Create ambient light
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(this.ambientLight);
                
                // Create fog
                this.fog = new THREE.Fog(0x88aaff, 300, 2000);
                this.scene.fog = this.fog;
                
                // Create sky
                this.createSky();
                
                // Create street lights
                this.createStreetLights();
            }

            createSky() {
                // Create sky sphere
                const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
                const skyMaterial = new THREE.ShaderMaterial({
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vWorldPosition;
                        uniform float timeOfDay;
                        
                        void main() {
                            // Time of day colors
                            vec3 dawnColor = vec3(1.0, 0.5, 0.3);
                            vec3 dayColor = vec3(0.4, 0.6, 1.0);
                            vec3 duskColor = vec3(1.0, 0.3, 0.5);
                            vec3 nightColor = vec3(0.1, 0.1, 0.3);
                            
                            // Calculate time factor
                            float timeFactor;
                            vec3 skyColor;
                            
                            if(timeOfDay < 6.0) {
                                // Night to dawn
                                timeFactor = timeOfDay / 6.0;
                                skyColor = mix(nightColor, dawnColor, timeFactor);
                            } else if(timeOfDay < 12.0) {
                                // Dawn to day
                                timeFactor = (timeOfDay - 6.0) / 6.0;
                                skyColor = mix(dawnColor, dayColor, timeFactor);
                            } else if(timeOfDay < 18.0) {
                                // Day to dusk
                                timeFactor = (timeOfDay - 12.0) / 6.0;
                                skyColor = mix(dayColor, duskColor, timeFactor);
                            } else {
                                // Dusk to night
                                timeFactor = (timeOfDay - 18.0) / 6.0;
                                skyColor = mix(duskColor, nightColor, timeFactor);
                            }
                            
                            // Add gradient based on height
                            float heightFactor = clamp(vWorldPosition.y / 500.0, 0.0, 1.0);
                            vec3 finalColor = mix(skyColor * 0.5, skyColor, heightFactor);
                            
                            // Add stars at night
                            if(timeOfDay < 6.0 || timeOfDay > 18.0) {
                                float star = step(0.999, sin(vWorldPosition.x * 100.0) * sin(vWorldPosition.y * 100.0) * sin(vWorldPosition.z * 100.0));
                                finalColor += vec3(star * 0.5);
                            }
                            
                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `,
                    uniforms: {
                        timeOfDay: { value: 12.0 }
                    },
                    side: THREE.BackSide
                });
                
                this.skybox = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(this.skybox);
            }

            createStreetLights() {
                // Create street lights along the road
                for(let i = 0; i < 20; i++) {
                    // Left side
                    const leftLight = this.createStreetLight(-CONFIG.ROAD_WIDTH / 2 - 5, -i * 50);
                    this.scene.add(leftLight);
                    this.lights.push(leftLight);
                    
                    // Right side
                    const rightLight = this.createStreetLight(CONFIG.ROAD_WIDTH / 2 + 5, -i * 50);
                    this.scene.add(rightLight);
                    this.lights.push(rightLight);
                }
            }

            createStreetLight(x, z) {
                const group = new THREE.Group();
                
                // Pole
                const poleGeometry = new THREE.CylinderGeometry(0.1, 0.15, 8);
                const poleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.y = 4;
                pole.castShadow = true;
                group.add(pole);
                
                // Light housing
                const housingGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const housingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff88,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                const housing = new THREE.Mesh(housingGeometry, housingMaterial);
                housing.position.y = 8;
                group.add(housing);
                
                // Point light
                const pointLight = new THREE.PointLight(0xffff88, 1, 30);
                pointLight.position.y = 8;
                pointLight.castShadow = true;
                group.add(pointLight);
                
                group.position.set(x, 0, z);
                
                return group;
            }

            update(deltaTime) {
                // Update time
                this.currentTime += deltaTime * this.timeSpeed;
                if(this.currentTime >= 24) {
                    this.currentTime -= 24;
                }
                
                // Update sky
                if(this.skybox && this.skybox.material.uniforms) {
                    this.skybox.material.uniforms.timeOfDay.value = this.currentTime;
                }
                
                // Update sun position
                const sunAngle = (this.currentTime / 24) * Math.PI * 2;
                const sunDistance = 500;
                this.sun.position.x = Math.cos(sunAngle) * sunDistance;
                this.sun.position.y = Math.sin(sunAngle) * sunDistance;
                this.sun.position.z = 100;
                
                // Update sun intensity based on time
                let sunIntensity = 0;
                let ambientIntensity = 0;
                
                if(this.currentTime >= 6 && this.currentTime <= 18) {
                    // Day time
                    const noonFactor = 1 - Math.abs(this.currentTime - 12) / 6;
                    sunIntensity = 1.5 * noonFactor;
                    ambientIntensity = 0.4 * noonFactor;
                } else if(this.currentTime >= 5 && this.currentTime <= 7) {
                    // Dawn/Dusk
                    const dawnFactor = 1 - Math.abs(this.currentTime - 6) / 2;
                    sunIntensity = 0.8 * dawnFactor;
                    ambientIntensity = 0.2 * dawnFactor;
                } else if(this.currentTime >= 17 && this.currentTime <= 19) {
                    // Dusk
                    const duskFactor = 1 - Math.abs(this.currentTime - 18) / 2;
                    sunIntensity = 0.8 * duskFactor;
                    ambientIntensity = 0.2 * duskFactor;
                }
                
                this.sun.intensity = sunIntensity;
                this.ambientLight.intensity = ambientIntensity;
                
                // Update fog color based on time
                if(this.fog) {
                    if(this.currentTime >= 6 && this.currentTime <= 18) {
                        this.fog.color.setHex(0x88aaff);
                        this.fog.near = 300;
                        this.fog.far = 2000;
                    } else {
                        this.fog.color.setHex(0x223366);
                        this.fog.near = 100;
                        this.fog.far = 1000;
                    }
                }
                
                // Update street lights
                const lightsOn = this.currentTime < 6 || this.currentTime > 18;
                this.lights.forEach(light => {
                    light.traverse(child => {
                        if(child.isPointLight) {
                            child.intensity = lightsOn ? 1 : 0;
                        }
                        if(child.isMesh && child.material.emissive) {
                            child.material.emissiveIntensity = lightsOn ? 0.5 : 0;
                        }
                    });
                });
            }
        }

        // ============================================
        // INPUT SYSTEM
        // ============================================
        class InputSystem {
            constructor() {
                this.steering = 0;
                this.throttle = 0;
                this.brake = false;
                this.boost = false;
                this.keys = {};
                this.gamepads = {};
                this.touch = {
                    joystick: { x: 0, y: 0, active: false },
                    buttons: { boost: false, brake: false }
                };
                
                this.init();
            }

            init() {
                // Keyboard events
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if(e.key === 'Escape') game.togglePause();
                    if(e.key === ' ') e.preventDefault(); // Prevent space from scrolling
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Gamepad events
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad.id);
                    this.gamepads[e.gamepad.index] = e.gamepad;
                    game.showNotification(`üéÆ ${e.gamepad.id} connected`);
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Gamepad disconnected:', e.gamepad.id);
                    delete this.gamepads[e.gamepad.index];
                });
                
                // Touch events
                this.initTouchControls();
                
                // Prevent context menu
                document.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            initTouchControls() {
                const joystick = document.getElementById('touchJoystick');
                const boostBtn = document.getElementById('touchBoost');
                const brakeBtn = document.getElementById('touchBrake');
                
                if(!joystick || !boostBtn || !brakeBtn) return;
                
                let joystickRect = joystick.getBoundingClientRect();
                let joystickCenter = {
                    x: joystickRect.left + joystickRect.width / 2,
                    y: joystickRect.top + joystickRect.height / 2
                };
                const maxDistance = joystickRect.width / 3;
                
                // Update joystick position on resize
                const updateJoystickRect = () => {
                    joystickRect = joystick.getBoundingClientRect();
                    joystickCenter = {
                        x: joystickRect.left + joystickRect.width / 2,
                        y: joystickRect.top + joystickRect.height / 2
                    };
                };
                
                window.addEventListener('resize', updateJoystickRect);
                
                // Touch events for joystick
                let activeTouchId = null;
                
                const handleJoystickStart = (clientX, clientY) => {
                    this.touch.joystick.active = true;
                    updateJoystickPosition(clientX, clientY);
                };
                
                const handleJoystickMove = (clientX, clientY) => {
                    if(!this.touch.joystick.active) return;
                    updateJoystickPosition(clientX, clientY);
                };
                
                const handleJoystickEnd = () => {
                    this.touch.joystick.active = false;
                    this.touch.joystick.x = 0;
                    this.touch.joystick.y = 0;
                    
                    // Reset joystick handle position
                    const handle = joystick.querySelector('.joystick-handle');
                    if(handle) {
                        handle.style.transform = 'translate(-50%, -50%)';
                    }
                };
                
                const updateJoystickPosition = (clientX, clientY) => {
                    const dx = clientX - joystickCenter.x;
                    const dy = clientY - joystickCenter.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if(distance > maxDistance) {
                        const angle = Math.atan2(dy, dx);
                        this.touch.joystick.x = Math.cos(angle);
                        this.touch.joystick.y = Math.sin(angle);
                    } else {
                        this.touch.joystick.x = dx / maxDistance;
                        this.touch.joystick.y = dy / maxDistance;
                    }
                    
                    // Update joystick handle visual
                    const handle = joystick.querySelector('.joystick-handle');
                    if(handle) {
                        const handleX = this.touch.joystick.x * maxDistance;
                        const handleY = this.touch.joystick.y * maxDistance;
                        handle.style.transform = `translate(calc(-50% + ${handleX}px), calc(-50% + ${handleY}px))`;
                    }
                };
                
                // Touch events
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(activeTouchId === null) {
                        activeTouchId = e.changedTouches[0].identifier;
                        handleJoystickStart(
                            e.changedTouches[0].clientX,
                            e.changedTouches[0].clientY
                        );
                    }
                });
                
                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    for(let touch of e.changedTouches) {
                        if(touch.identifier === activeTouchId) {
                            handleJoystickMove(touch.clientX, touch.clientY);
                            break;
                        }
                    }
                });
                
                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    for(let touch of e.changedTouches) {
                        if(touch.identifier === activeTouchId) {
                            activeTouchId = null;
                            handleJoystickEnd();
                            break;
                        }
                    }
                });
                
                joystick.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    activeTouchId = null;
                    handleJoystickEnd();
                });
                
                // Button events
                boostBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touch.buttons.boost = true;
                    boostBtn.style.background = 'rgba(0, 255, 136, 0.5)';
                });
                
                boostBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touch.buttons.boost = false;
                    boostBtn.style.background = 'rgba(0, 255, 136, 0.3)';
                });
                
                brakeBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touch.buttons.brake = true;
                    brakeBtn.style.background = 'rgba(255, 85, 0, 0.5)';
                });
                
                brakeBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touch.buttons.brake = false;
                    brakeBtn.style.background = 'rgba(255, 85, 0, 0.3)';
                });
            }

            update() {
                // Reset input
                this.steering = 0;
                this.throttle = 0;
                this.brake = false;
                this.boost = false;
                
                // Keyboard input
                if(this.keys['w'] || this.keys['arrowup']) this.throttle = 1;
                if(this.keys['s'] || this.keys['arrowdown']) this.brake = true;
                if(this.keys['a'] || this.keys['arrowleft']) this.steering = 1;
                if(this.keys['d'] || this.keys['arrowright']) this.steering = -1;
                if(this.keys[' ']) this.boost = true;
                
                // Gamepad input
                for(const index in this.gamepads) {
                    const gamepad = navigator.getGamepads()[index];
                    if(gamepad) {
                        // Left stick for steering
                        if(Math.abs(gamepad.axes[0]) > 0.1) {
                            this.steering = -gamepad.axes[0];
                        }
                        
                        // Right trigger for throttle
                        if(gamepad.buttons[7]) {
                            this.throttle = gamepad.buttons[7].value;
                        }
                        
                        // Left trigger for brake
                        if(gamepad.buttons[6]) {
                            this.brake = gamepad.buttons[6].value > 0.1;
                        }
                        
                        // A button for boost
                        if(gamepad.buttons[0]) {
                            this.boost = gamepad.buttons[0].pressed;
                        }
                        
                        // Right shoulder for boost alternative
                        if(gamepad.buttons[5]) {
                            this.boost = gamepad.buttons[5].pressed;
                        }
                    }
                }
                
                // Touch input
                if(this.touch.joystick.active) {
                    this.steering = -this.touch.joystick.x;
                    this.throttle = Math.max(0, -this.touch.joystick.y);
                }
                
                if(this.touch.buttons.boost) this.boost = true;
                if(this.touch.buttons.brake) this.brake = true;
                
                // Apply sensitivity
                this.steering *= game.state.settings.cameraSensitivity;
            }
        }

        // ============================================
        // UI SYSTEM
        // ============================================
        class UISystem {
            constructor() {
                this.elements = {};
                this.notifications = [];
                this.bindElements();
            }

            bindElements() {
                // Bind all UI elements
                const elementIds = [
                    'loadingScreen', 'startMenu', 'multiplayerMenu', 'settingsMenu',
                    'hud', 'playerList', 'playerListContent', 'minimap',
                    'profitValue', 'productValue', 'productFill', 'speedValue',
                    'distanceValue', 'boostValue', 'botCount', 'botCountDisplay',
                    'roomCode', 'graphicsQuality', 'cameraSensitivity', 'sensitivityDisplay'
                ];
                
                elementIds.forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });
            }

            showScreen(screenName) {
                // Hide all screens
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.add('hidden');
                });
                
                // Show requested screen
                const screen = document.getElementById(screenName);
                if(screen) {
                    screen.classList.remove('hidden');
                }
                
                // Update game state
                game.state.screen = screenName;
                
                // Show/hide HUD based on screen
                if(screenName === 'playing') {
                    this.elements.hud?.classList.remove('hidden');
                    this.elements.playerList?.classList.remove('hidden');
                    this.elements.minimap?.classList.remove('hidden');
                    document.getElementById('instructions')?.classList.remove('hidden');
                    
                    // Show touch controls on mobile
                    if('ontouchstart' in window) {
                        document.querySelector('.touch-controls')?.classList.remove('hidden');
                    }
                } else {
                    this.elements.hud?.classList.add('hidden');
                    this.elements.playerList?.classList.add('hidden');
                    this.elements.minimap?.classList.add('hidden');
                    document.getElementById('instructions')?.classList.add('hidden');
                    document.querySelector('.touch-controls')?.classList.add('hidden');
                }
            }

            updateHUD(player) {
                if(!player) return;
                
                // Update values
                if(this.elements.profitValue) {
                    this.elements.profitValue.textContent = `$${Math.floor(player.profit)}`;
                }
                
                if(this.elements.productValue) {
                    this.elements.productValue.textContent = `${player.products}/${CONFIG.INITIAL_PRODUCTS}`;
                }
                
                if(this.elements.speedValue) {
                    this.elements.speedValue.textContent = `${Math.abs(Math.round(player.speed * 3.6))} km/h`;
                }
                
                if(this.elements.distanceValue) {
                    this.elements.distanceValue.textContent = `${Math.floor(game.state.distance)}m`;
                }
                
                if(this.elements.boostValue) {
                    this.elements.boostValue.textContent = `${Math.floor(player.boost)}%`;
                }
                
                // Update product bar
                if(this.elements.productFill) {
                    const percent = (player.products / CONFIG.INITIAL_PRODUCTS) * 100;
                    this.elements.productFill.style.width = `${percent}%`;
                    
                    // Change color based on damage
                    if(percent < 20) {
                        this.elements.productFill.style.background = 'linear-gradient(90deg, #ff0000, #ff5500)';
                    } else if(percent < 50) {
                        this.elements.productFill.style.background = 'linear-gradient(90deg, #ff5500, #ffaa00)';
                    } else {
                        this.elements.productFill.style.background = 'linear-gradient(90deg, #00ff88, #00aaff)';
                    }
                }
                
                // Update player list
                this.updatePlayerList();
                
                // Update minimap
                this.updateMinimap(player);
            }

            updatePlayerList() {
                const container = this.elements.playerListContent;
                if(!container) return;
                
                container.innerHTML = '';
                
                // Add local player
                if(game.state.localPlayer) {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-entry';
                    playerDiv.innerHTML = `
                        <span class="player-name">${game.state.localPlayer.name} üëë</span>
                        <span class="player-products">üì¶ ${game.state.localPlayer.products}</span>
                    `;
                    container.appendChild(playerDiv);
                }
                
                // Add bots
                game.players.bots.forEach(bot => {
                    const botDiv = document.createElement('div');
                    botDiv.className = 'player-entry';
                    botDiv.innerHTML = `
                        <span class="player-name">${bot.name}</span>
                        <span class="player-products">üì¶ ${bot.products}</span>
                    `;
                    container.appendChild(botDiv);
                });
            }

            updateMinimap(player) {
                const canvas = document.getElementById('minimapCanvas');
                if(!canvas) return;
                
                const ctx = canvas.getContext('2d');
                if(!ctx) return;
                
                // Set canvas size
                if(canvas.width !== 200 || canvas.height !== 200) {
                    canvas.width = 200;
                    canvas.height = 200;
                }
                
                // Clear canvas
                ctx.clearRect(0, 0, 200, 200);
                
                // Draw background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, 200, 200);
                
                // Draw road
                ctx.fillStyle = '#333333';
                ctx.fillRect(50, 0, 100, 200);
                
                // Draw lane markings
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(95, 0, 10, 200); // Center line
                ctx.fillRect(65, 0, 5, 200); // Left lane
                ctx.fillRect(130, 0, 5, 200); // Right lane
                
                // Draw player
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.arc(100, 100, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player direction
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(100, 100);
                ctx.lineTo(
                    100 + Math.sin(player.rotation) * 20,
                    100 - Math.cos(player.rotation) * 20
                );
                ctx.stroke();
                
                // Draw bots
                game.players.bots.forEach(bot => {
                    if(bot.cart) {
                        const dx = bot.position.x - player.position.x;
                        const dz = bot.position.z - player.position.z;
                        
                        // Convert to minimap coordinates
                        const mapX = 100 + (dx / 50) * 10; // 50m = 10px
                        const mapY = 100 + (dz / 50) * 10;
                        
                        if(mapX >= 0 && mapX <= 200 && mapY >= 0 && mapY <= 200) {
                            ctx.fillStyle = '#ff5500';
                            ctx.beginPath();
                            ctx.arc(mapX, mapY, 6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
                
                // Draw buildings
                ctx.fillStyle = '#888888';
                game.world.buildings.forEach(building => {
                    const dx = building.x - player.position.x;
                    const dz = building.z - player.position.z;
                    
                    const mapX = 100 + (dx / 50) * 10;
                    const mapY = 100 + (dz / 50) * 10;
                    
                    if(mapX >= 0 && mapX <= 200 && mapY >= 0 && mapY <= 200) {
                        ctx.fillRect(mapX - 3, mapY - 3, 6, 6);
                    }
                });
            }

            showNotification(message, duration = 2000) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;
                
                document.getElementById('notificationContainer').appendChild(notification);
                
                // Remove after duration
                setTimeout(() => {
                    if(notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, duration);
            }

            updateLoadingProgress(percent, text) {
                const progressBar = document.getElementById('loadingProgressBar');
                const loadingText = document.getElementById('loadingText');
                
                if(progressBar) {
                    progressBar.style.width = `${percent}%`;
                }
                
                if(loadingText && text) {
                    loadingText.textContent = text;
                }
            }
        }

        // ============================================
        // MAIN GAME CLASS
        // ============================================
        class CartRidersGame {
            constructor() {
                // Initialize systems
                this.state = new GameState();
                this.assets = new AssetManager();
                this.input = new InputSystem();
                this.ui = new UISystem();
                
                // Systems to be initialized later
                this.world = null;
                this.players = null;
                this.cameraSystem = null;
                this.weather = null;
                
                // Initialize game
                this.init();
            }

            async init() {
                try {
                    // Initialize Three.js
                    this.initThreeJS();
                    
                    // Load assets
                    await this.assets.loadAllAssets();
                    
                    // Initialize game systems
                    this.initGameSystems();
                    
                    // Show start menu
                    this.ui.showScreen('startMenu');
                    
                    // Start game loop
                    this.gameLoop();
                    
                } catch (error) {
                    console.error('Game initialization failed:', error);
                    this.ui.showNotification('‚ùå Game initialization failed!');
                }
            }

            initThreeJS() {
                const canvas = document.getElementById('gameCanvas');
                
                // Scene
                this.scene = new THREE.Scene();
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    5000
                );
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                
                // Window resize handler
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Prevent right-click menu
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            initGameSystems() {
                // Initialize world generator
                this.world = new WorldGenerator();
                
                // Initialize player system
                this.players = new PlayerSystem();
                
                // Initialize camera system
                this.cameraSystem = new CameraSystem(this.camera);
                
                // Initialize weather system
                this.weather = new WeatherSystem(this.scene);
                
                // Load settings
                this.loadSettings();
            }

            loadSettings() {
                const savedSettings = localStorage.getItem('cartRidersSettings');
                if(savedSettings) {
                    this.state.settings = { ...this.state.settings, ...JSON.parse(savedSettings) };
                }
                
                // Apply settings to UI
                if(this.ui.elements.graphicsQuality) {
                    this.ui.elements.graphicsQuality.value = this.state.settings.graphicsQuality;
                }
                
                if(this.ui.elements.cameraSensitivity) {
                    this.ui.elements.cameraSensitivity.value = this.state.settings.cameraSensitivity;
                    this.ui.elements.sensitivityDisplay.textContent = 
                        this.getSensitivityLabel(this.state.settings.cameraSensitivity);
                }
                
                // Apply graphics quality
                this.applyGraphicsSettings();
            }

            saveSettings() {
                // Update settings from UI
                if(this.ui.elements.graphicsQuality) {
                    this.state.settings.graphicsQuality = this.ui.elements.graphicsQuality.value;
                }
                
                if(this.ui.elements.cameraSensitivity) {
                    this.state.settings.cameraSensitivity = parseFloat(this.ui.elements.cameraSensitivity.value);
                }
                
                // Save to localStorage
                localStorage.setItem('cartRidersSettings', JSON.stringify(this.state.settings));
                
                // Apply settings
                this.applyGraphicsSettings();
                
                // Show notification
                this.ui.showNotification('‚öôÔ∏è Settings saved!');
                
                // Return to menu
                setTimeout(() => this.ui.showScreen('startMenu'), 1000);
            }

            applyGraphicsSettings() {
                const quality = this.state.settings.graphicsQuality;
                
                switch(quality) {
                    case 'low':
                        this.renderer.setPixelRatio(1);
                        this.renderer.shadowMap.enabled = false;
                        this.renderer.antialias = false;
                        break;
                    case 'medium':
                        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                        this.renderer.shadowMap.enabled = true;
                        this.renderer.antialias = true;
                        break;
                    case 'high':
                        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                        this.renderer.shadowMap.enabled = true;
                        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        this.renderer.antialias = true;
                        break;
                    case 'ultra':
                        this.renderer.setPixelRatio(window.devicePixelRatio);
                        this.renderer.shadowMap.enabled = true;
                        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        this.renderer.antialias = true;
                        break;
                }
            }

            getSensitivityLabel(value) {
                if(value < 0.7) return 'Very Slow';
                if(value < 1.0) return 'Slow';
                if(value < 1.3) return 'Normal';
                if(value < 1.7) return 'Fast';
                return 'Very Fast';
            }

            startSoloGame() {
                // Reset game state
                this.resetGame();
                
                // Get player name and bot count
                const playerName = document.getElementById('playerName')?.value || 'Cart Rider';
                const botCount = parseInt(this.ui.elements.botCount?.value || 2);
                
                // Create player
                const player = this.players.createPlayer('player1', playerName, true);
                
                // Set camera target
                this.cameraSystem.setTarget(player);
                
                // Generate initial world
                this.world.generateInitialWorld();
                
                // Start game
                this.state.gameActive = true;
                this.state.lastBotSpawn = Date.now();
                this.ui.showScreen('playing');
                
                // Show notification
                this.ui.showNotification('3... 2... 1... GO! üöÄ');
            }

            createRoom() {
                this.ui.showNotification('üéÆ Room created! (Demo mode)');
                setTimeout(() => this.startSoloGame(), 1000);
            }

            joinRoom() {
                const code = this.ui.elements.roomCode?.value;
                if(code && code.length === 6) {
                    this.ui.showNotification(`üîó Joining room ${code}...`);
                    setTimeout(() => this.startSoloGame(), 1000);
                } else {
                    this.ui.showNotification('‚ùå Enter a valid room code!');
                }
            }

            resetGame() {
                // Clear scene
                while(this.scene.children.length > 0) {
                    this.scene.remove(this.scene.children[0]);
                }
                
                // Reset state
                this.state.gameActive = false;
                this.state.gameTime = 0;
                this.state.score = 0;
                this.state.distance = 0;
                this.state.productsDelivered = 0;
                this.state.productsLost = 0;
                
                // Reset systems
                this.world = new WorldGenerator();
                this.players = new PlayerSystem();
                this.cameraSystem = new CameraSystem(this.camera);
                this.weather = new WeatherSystem(this.scene);
                
                // Re-add camera to scene
                this.scene.add(this.camera);
            }

            togglePause() {
                if(this.state.screen !== 'playing') return;
                
                this.state.paused = !this.state.paused;
                
                if(this.state.paused) {
                    this.ui.showNotification('‚è∏Ô∏è Game Paused');
                } else {
                    this.ui.showNotification('‚ñ∂Ô∏è Game Resumed');
                }
            }

            showScreen(screenName) {
                this.ui.showScreen(screenName);
            }

            showNotification(message) {
                this.ui.showNotification(message);
            }

            updateGame(deltaTime) {
                if(!this.state.gameActive || this.state.paused) return;
                
                // Update game time
                this.state.gameTime += deltaTime;
                this.state.deltaTime = deltaTime;
                
                // Update input
                this.input.update();
                
                // Update weather and time
                this.weather.update(deltaTime);
                
                // Update world
                if(this.state.localPlayer) {
                    this.world.update(this.state.localPlayer.position.z);
                }
                
                // Update players
                this.players.players.forEach(player => {
                    this.players.updatePlayer(player, deltaTime);
                });
                
                // Update bots
                this.players.updateBots(deltaTime);
                
                // Update camera
                this.cameraSystem.update(deltaTime);
                
                // Update UI
                this.ui.updateHUD(this.state.localPlayer);
                
                // Check game over condition
                if(this.state.localPlayer && this.state.localPlayer.products <= 0) {
                    this.gameOver();
                }
            }

            gameOver() {
                this.state.gameActive = false;
                
                // Show end screen
                const endScreen = document.createElement('div');
                endScreen.className = 'screen';
                endScreen.innerHTML = `
                    <div class="ui-panel">
                        <h1>GAME OVER</h1>
                        <h2>Delivery Complete!</h2>
                        
                        <div style="text-align: center; margin: 40px 0; font-size: 1.3rem;">
                            <div style="margin: 15px 0;">
                                <span style="color: #00ff88;">üí∞ Final Profit:</span>
                                <span style="font-weight: bold; color: white;"> $${Math.floor(this.state.score)}</span>
                            </div>
                            <div style="margin: 15px 0;">
                                <span style="color: #00aaff;">üéØ Distance Traveled:</span>
                                <span style="font-weight: bold; color: white;"> ${Math.floor(this.state.distance)}m</span>
                            </div>
                            <div style="margin: 15px 0;">
                                <span style="color: #ffaa00;">üì¶ Products Delivered:</span>
                                <span style="font-weight: bold; color: white;"> ${this.state.productsDelivered}</span>
                            </div>
                            <div style="margin: 15px 0;">
                                <span style="color: #ff5500;">‚è±Ô∏è Survival Time:</span>
                                <span style="font-weight: bold; color: white;"> ${Math.floor(this.state.gameTime)}s</span>
                            </div>
                        </div>
                        
                        <div style="text-align: center; margin: 40px 0;">
                            <button class="btn" onclick="game.startSoloGame()">üîÑ Play Again</button>
                            <button class="btn secondary" onclick="game.ui.showScreen('startMenu')">üè† Main Menu</button>
                        </div>
                    </div>
                `;
                
                document.getElementById('gameContainer').appendChild(endScreen);
            }

            gameLoop(currentTime = 0) {
                // Calculate delta time
                const deltaTime = Math.min((currentTime - this.state.lastTime) / 1000, 0.1);
                this.state.lastTime = currentTime;
                
                // Update FPS counter
                this.state.frameCount++;
                if(currentTime - this.state.lastFpsUpdate > 1000) {
                    this.state.fps = this.state.frameCount;
                    this.state.frameCount = 0;
                    this.state.lastFpsUpdate = currentTime;
                }
                
                // Update game logic
                if(this.state.gameActive) {
                    this.updateGame(deltaTime);
                }
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
                
                // Request next frame
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }

        // ============================================
        // GAME INITIALIZATION
        // ============================================
        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Check if Three.js is loaded
            if(typeof THREE === 'undefined') {
                alert('Error: THREE.js failed to load. Please check your internet connection and refresh the page.');
                return;
            }
            
            // Initialize game
            window.game = new CartRidersGame();
            
            // Add event listeners for UI elements
            document.getElementById('botCount')?.addEventListener('input', function(e) {
                document.getElementById('botCountDisplay').textContent = e.target.value;
            });
            
            document.getElementById('cameraSensitivity')?.addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                document.getElementById('sensitivityDisplay').textContent = 
                    game.getSensitivityLabel(value);
            });
            
            // Add fullscreen toggle
            document.addEventListener('keydown', (e) => {
                if(e.key === 'f' || e.key === 'F') {
                    if(!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().catch(err => {
                            console.log('Fullscreen error:', err);
                        });
                    } else {
                        document.exitFullscreen();
                    }
                }
            });
            
            // Add mobile detection
            if('ontouchstart' in window) {
                document.body.classList.add('touch-device');
            }
            
            console.log('üéÆ Cart Riders: Delivery Chaos initialized!');
        });
    </script>
</body>
</html>
