<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless 3D Road Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #0a1929;
            color: #333;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #ui h2 {
            margin-bottom: 10px;
            color: #4CAF50;
            font-size: 1.4em;
        }
        
        .ui-row {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .ui-label {
            color: #aaa;
        }
        
        .ui-value {
            font-weight: bold;
            color: white;
        }
        
        #speedBar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        #speedFill {
            height: 100%;
            width: 30%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #controls h3 {
            margin-bottom: 10px;
            color: #FF9800;
        }
        
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            margin: 2px;
            border-radius: 5px;
            font-family: monospace;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            min-width: 300px;
            border: 2px solid #4CAF50;
        }
        
        #loading h2 {
            margin-bottom: 15px;
            color: #4CAF50;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 15px;
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            min-width: 350px;
            display: none;
            border: 3px solid #FF5252;
            box-shadow: 0 0 30px rgba(255, 82, 82, 0.5);
        }
        
        #gameOver h2 {
            font-size: 2.5em;
            color: #FF5252;
            margin-bottom: 20px;
        }
        
        #gameOver button {
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s;
        }
        
        #gameOver button:hover {
            transform: scale(1.05);
        }
        
        #roadCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <h2>ROAD RUNNER</h2>
            <div class="ui-row">
                <span class="ui-label">SCORE:</span>
                <span id="score" class="ui-value">0</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">SPEED:</span>
                <span id="speed" class="ui-value">60 km/h</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">DISTANCE:</span>
                <span id="distance" class="ui-value">0 m</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">ENEMIES:</span>
                <span id="enemies" class="ui-value">0</span>
            </div>
            <div class="ui-row">
                <span class="ui-label">LANE:</span>
                <span id="lane" class="ui-value">2</span>
            </div>
            <div id="speedBar">
                <div id="speedFill"></div>
            </div>
        </div>
        
        <div id="controls">
            <h3>CONTROLS</h3>
            <p><span class="key">W</span>/<span class="key">↑</span> - Accelerate</p>
            <p><span class="key">A</span>/<span class="key">←</span> - Left Lane</p>
            <p><span class="key">D</span>/<span class="key">→</span> - Right Lane</p>
            <p><span class="key">S</span>/<span class="key">↓</span> - Brake</p>
            <p style="margin-top: 10px; color: #FF9800;">Gamepad Supported</p>
        </div>
        
        <div id="loading">
            <h2>LOADING GAME</h2>
            <p id="loadingText">Initializing 3D engine...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="loadingProgress"></div>
            </div>
        </div>
        
        <div id="gameOver">
            <h2>GAME OVER</h2>
            <p>You crashed!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Distance Traveled: <span id="finalDistance">0 m</span></p>
            <button onclick="restartGame()">PLAY AGAIN</button>
        </div>
        
        <canvas id="roadCanvas"></canvas>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // Import Three.js modules
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://unpkg.com/three@0.162.0/examples/jsm/loaders/GLTFLoader.js';

        // ====================
        // GAME CONFIGURATION
        // ====================
        const CONFIG = {
            // Road settings
            ROAD_WIDTH: 24,
            SHOULDER_WIDTH: 3,
            ROAD_LENGTH: 500, // Shorter segments for better performance
            NUM_LANES: 4,
            
            // Calculate lane positions with equal widths
            get laneWidth() {
                return CONFIG.ROAD_WIDTH / CONFIG.NUM_LANES;
            },
            
            // FIXED: REALISTIC CAR PHYSICS (FASTER!)
            INITIAL_SPEED: 60, // Realistic city speed (km/h)
            MAX_SPEED: 220,    // Realistic highway speed (km/h)
            ACCELERATION_RATE: 30, // Much faster acceleration (km/h per second)
            DECELERATION_RATE: 50, // Strong braking
            LANE_CHANGE_SPEED: 0.2,
            
            // Convert km/h to m/s for game physics
            getSpeedInMps(speedKmph) {
                return speedKmph * (1000 / 3600); // Convert km/h to m/s
            },
            
            // Enemy settings
            MAX_ENEMIES: 8,
            ENEMY_SPAWN_INTERVAL: 2000,
            ENEMY_SPEED_VARIATION: 0.8,
            
            // NPC settings
            MAX_NPCS: 12,
            NPC_SPAWN_INTERVAL: 2500,
            NPC_SPEED_VARIATION: 0.6,
            
            // Asset paths
            ASSETS: {
                PLAYER: 'models/player.glb',
                ENEMY: 'models/enemyCar.glb',
                NPC: 'models/npc.glb'
            }
        };

        // ====================
        // GAME STATE
        // ====================
        let gameState = {
            score: 0,
            distance: 0,
            speed: CONFIG.INITIAL_SPEED,
            currentLane: 2,
            targetLane: 2,
            gameOver: false,
            playerCar: null,
            enemies: [],
            npcs: [],
            playerModel: null,
            enemyModel: null,
            npcModel: null,
            assetsLoaded: false,
            lastEnemySpawn: 0,
            lastNPCSpawn: 0,
            gamepad: null,
            roadSegments: [],
            groundSegments: [],
            roadOffset: 0
        };

        // ====================
        // THREE.JS SETUP
        // ====================
        let scene, camera, renderer;
        let asphaltTexture, grassTexture;
        let clock = new THREE.Clock();
        
        // Calculate lane centers
        function getLaneCenter(laneIndex) {
            const halfRoad = CONFIG.ROAD_WIDTH / 2;
            const laneWidth = CONFIG.laneWidth;
            const leftEdge = -halfRoad + (laneIndex * laneWidth);
            return leftEdge + (laneWidth / 2);
        }
        
        // Update loading progress
        function updateLoading(text, progress) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingProgress').style.width = `${progress}%`;
        }
        
        // Initialize the game
        async function init() {
            updateLoading("Setting up 3D scene...", 10);
            
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);
            
            // FIXED: Camera positioned lower and tilted down
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 4, 12); // Lower camera height
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('roadCanvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Create textures
            createTextures();
            
            // Setup lighting
            setupLighting();
            
            updateLoading("Creating road system...", 40);
            
            // Create infinite road system
            createInfiniteRoad();
            
            updateLoading("Loading car models...", 60);
            
            // Load models in sequence
            await loadModelsSequentially();
            
            updateLoading("Creating player car...", 90);
            
            // Create player car AFTER models are loaded
            createPlayerCar();
            
            // Setup event listeners
            setupEventListeners();
            
            updateLoading("Starting game...", 100);
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                gameState.assetsLoaded = true;
                animate();
            }, 500);
        }
        
        // ====================
        // TEXTURE CREATION
        // ====================
        function createTextures() {
            // Asphalt texture
            const asphaltCanvas = document.createElement('canvas');
            asphaltCanvas.width = 512;
            asphaltCanvas.height = 512;
            const asphaltCtx = asphaltCanvas.getContext('2d');
            
            asphaltCtx.fillStyle = '#2a2a2a';
            asphaltCtx.fillRect(0, 0, 512, 512);
            
            asphaltCtx.fillStyle = '#222222';
            for (let i = 0; i < 15000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 3;
                asphaltCtx.fillRect(x, y, size, size);
            }
            
            asphaltTexture = new THREE.CanvasTexture(asphaltCanvas);
            asphaltTexture.wrapS = THREE.RepeatWrapping;
            asphaltTexture.wrapT = THREE.RepeatWrapping;
            asphaltTexture.repeat.set(40, 400); // More tiling for faster movement
            
            // Grass texture
            const grassCanvas = document.createElement('canvas');
            grassCanvas.width = 512;
            grassCanvas.height = 512;
            const grassCtx = grassCanvas.getContext('2d');
            
            grassCtx.fillStyle = '#1a472a';
            grassCtx.fillRect(0, 0, 512, 512);
            
            grassCtx.fillStyle = '#2d5016';
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                grassCtx.fillRect(x, y, 1, 3);
            }
            
            grassTexture = new THREE.CanvasTexture(grassCanvas);
            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
        }
        
        // ====================
        // LIGHTING SETUP WITH SHADOW BIAS FIX
        // ====================
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            
            // FIXED: Shadow bias adjustment
            directionalLight.shadow.bias = -0.0001;
            directionalLight.shadow.normalBias = 0.05;
            
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            
            scene.add(directionalLight);
            
            // Additional fill light
            const fillLight = new THREE.DirectionalLight(0x88aaff, 0.3);
            fillLight.position.set(-30, 50, -50);
            scene.add(fillLight);
        }
        
        // Create contact shadow texture
        function createContactShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient for soft shadow
            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            
            return new THREE.CanvasTexture(canvas);
        }
        
        // ====================
        // INFINITE ROAD SYSTEM
        // ====================
        function createInfiniteRoad() {
            const segmentCount = 4; // More segments for smoother looping
            
            for (let i = 0; i < segmentCount; i++) {
                // Create road segment
                const roadGeometry = new THREE.PlaneGeometry(
                    CONFIG.ROAD_WIDTH + (CONFIG.SHOULDER_WIDTH * 2),
                    CONFIG.ROAD_LENGTH
                );
                roadGeometry.rotateX(-Math.PI / 2);
                
                const roadMaterial = new THREE.MeshStandardMaterial({
                    map: asphaltTexture,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const roadSegment = new THREE.Mesh(roadGeometry, roadMaterial);
                roadSegment.receiveShadow = true;
                roadSegment.position.y = 0;
                roadSegment.position.z = i * CONFIG.ROAD_LENGTH - CONFIG.ROAD_LENGTH;
                
                // Create ground segment
                const groundGeometry = new THREE.PlaneGeometry(400, CONFIG.ROAD_LENGTH);
                groundGeometry.rotateX(-Math.PI / 2);
                
                const groundMaterial = new THREE.MeshStandardMaterial({
                    map: grassTexture,
                    roughness: 0.9,
                    metalness: 0
                });
                
                const groundSegment = new THREE.Mesh(groundGeometry, groundMaterial);
                groundSegment.receiveShadow = true;
                groundSegment.position.y = -0.1;
                groundSegment.position.z = i * CONFIG.ROAD_LENGTH - CONFIG.ROAD_LENGTH;
                
                scene.add(roadSegment);
                scene.add(groundSegment);
                
                // Create road markings for this segment
                createRoadMarkings(roadSegment.position.z);
                
                gameState.roadSegments.push(roadSegment);
                gameState.groundSegments.push(groundSegment);
            }
            
            // Create shoulders
            createShoulders();
        }
        
        function createRoadMarkings(segmentZ) {
            const dashedLineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            
            const linePositions = [
                getLaneCenter(0) + (CONFIG.laneWidth / 2),
                getLaneCenter(1) + (CONFIG.laneWidth / 2),
                getLaneCenter(2) + (CONFIG.laneWidth / 2)
            ];
            
            const dashLength = 3;
            const gapLength = 5;
            const dashWidth = 0.2;
            const dashHeight = 0.02;
            
            linePositions.forEach((xPos) => {
                const totalDashes = Math.floor(CONFIG.ROAD_LENGTH / (dashLength + gapLength));
                
                for (let i = 0; i < totalDashes; i++) {
                    const dashGeometry = new THREE.PlaneGeometry(dashWidth, dashLength);
                    dashGeometry.rotateX(-Math.PI / 2);
                    
                    const dash = new THREE.Mesh(dashGeometry, dashedLineMaterial);
                    dash.position.x = xPos;
                    dash.position.y = dashHeight;
                    dash.position.z = segmentZ + (i * (dashLength + gapLength)) + dashLength/2;
                    
                    scene.add(dash);
                }
            });
            
            const solidLineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff
            });
            
            const leftLineGeometry = new THREE.PlaneGeometry(0.3, CONFIG.ROAD_LENGTH);
            leftLineGeometry.rotateX(-Math.PI / 2);
            const leftLine = new THREE.Mesh(leftLineGeometry, solidLineMaterial);
            leftLine.position.x = -(CONFIG.ROAD_WIDTH / 2);
            leftLine.position.y = dashHeight;
            leftLine.position.z = segmentZ;
            scene.add(leftLine);
            
            const rightLineGeometry = new THREE.PlaneGeometry(0.3, CONFIG.ROAD_LENGTH);
            rightLineGeometry.rotateX(-Math.PI / 2);
            const rightLine = new THREE.Mesh(rightLineGeometry, solidLineMaterial);
            rightLine.position.x = CONFIG.ROAD_WIDTH / 2;
            rightLine.position.y = dashHeight;
            rightLine.position.z = segmentZ;
            scene.add(rightLine);
        }
        
        function createShoulders() {
            const shoulderMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.9,
                metalness: 0
            });
            
            const shoulderLength = CONFIG.ROAD_LENGTH * 4;
            
            const leftShoulderGeometry = new THREE.PlaneGeometry(
                CONFIG.SHOULDER_WIDTH,
                shoulderLength
            );
            leftShoulderGeometry.rotateX(-Math.PI / 2);
            const leftShoulder = new THREE.Mesh(leftShoulderGeometry, shoulderMaterial);
            leftShoulder.position.x = -(CONFIG.ROAD_WIDTH / 2 + CONFIG.SHOULDER_WIDTH / 2);
            leftShoulder.position.y = 0;
            leftShoulder.position.z = -CONFIG.ROAD_LENGTH * 1.5;
            leftShoulder.receiveShadow = true;
            scene.add(leftShoulder);
            
            const rightShoulderGeometry = new THREE.PlaneGeometry(
                CONFIG.SHOULDER_WIDTH,
                shoulderLength
            );
            rightShoulderGeometry.rotateX(-Math.PI / 2);
            const rightShoulder = new THREE.Mesh(rightShoulderGeometry, shoulderMaterial);
            rightShoulder.position.x = CONFIG.ROAD_WIDTH / 2 + CONFIG.SHOULDER_WIDTH / 2;
            rightShoulder.position.y = 0;
            rightShoulder.position.z = -CONFIG.ROAD_LENGTH * 1.5;
            rightShoulder.receiveShadow = true;
            scene.add(rightShoulder);
        }
        
        function updateRoadSystem(delta) {
            if (!gameState.playerCar) return;
            
            // FIXED: Movement is now in the CAR'S forward direction
            // Since cars are rotated 180°, forward is negative Z
            const movement = CONFIG.getSpeedInMps(gameState.speed) * delta;
            gameState.roadOffset += movement;
            
            // Update ALL road and ground segments
            gameState.roadSegments.forEach((segment, index) => {
                segment.position.z -= movement; // Road moves backward
                
                // FIXED: Proper looping with seamless transition
                if (segment.position.z < -CONFIG.ROAD_LENGTH * 2) {
                    segment.position.z += CONFIG.ROAD_LENGTH * gameState.roadSegments.length;
                    
                    // Update texture offset for seamless appearance
                    segment.material.map.offset.y -= 0.1;
                }
            });
            
            gameState.groundSegments.forEach((segment, index) => {
                segment.position.z -= movement;
                
                if (segment.position.z < -CONFIG.ROAD_LENGTH * 2) {
                    segment.position.z += CONFIG.ROAD_LENGTH * gameState.groundSegments.length;
                    segment.material.map.offset.y -= 0.05;
                }
            });
            
            // Update distance and score
            gameState.distance += movement;
            gameState.score = Math.floor(gameState.distance / 10);
        }
        
        // ====================
        // MODEL LOADING
        // ====================
        async function loadModelsSequentially() {
            const loader = new GLTFLoader();
            let loadedCount = 0;
            
            const loadSingleModel = (url, modelType) => {
                return new Promise((resolve, reject) => {
                    loader.load(
                        url,
                        (gltf) => {
                            // FIXED: Rotate model by 180 degrees on Y-axis
                            gltf.scene.rotation.y = Math.PI;
                            
                            gltf.scene.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            
                            if (modelType === 'player') {
                                gameState.playerModel = gltf.scene;
                            } else if (modelType === 'enemy') {
                                gameState.enemyModel = gltf.scene;
                            } else if (modelType === 'npc') {
                                gameState.npcModel = gltf.scene;
                            }
                            
                            loadedCount++;
                            updateLoading(`Loaded ${modelType} model... ${loadedCount}/3`, 60 + (loadedCount/3)*30);
                            resolve();
                        },
                        undefined,
                        (error) => {
                            console.warn(`Error loading ${modelType} model:`, error);
                            createPlaceholderCar(modelType).then(placeholder => {
                                placeholder.rotation.y = Math.PI;
                                
                                if (modelType === 'player') {
                                    gameState.playerModel = placeholder;
                                } else if (modelType === 'enemy') {
                                    gameState.enemyModel = placeholder;
                                } else if (modelType === 'npc') {
                                    gameState.npcModel = placeholder;
                                }
                                loadedCount++;
                                updateLoading(`Created placeholder for ${modelType}... ${loadedCount}/3`, 60 + (loadedCount/3)*30);
                                resolve();
                            });
                        }
                    );
                });
            };
            
            await loadSingleModel(CONFIG.ASSETS.PLAYER, 'player');
            await loadSingleModel(CONFIG.ASSETS.ENEMY, 'enemy');
            await loadSingleModel(CONFIG.ASSETS.NPC, 'npc');
        }
        
        async function createPlaceholderCar(type) {
            const group = new THREE.Group();
            
            let color;
            if (type === 'player') color = 0x2196F3;
            else if (type === 'enemy') color = 0xFF4444;
            else color = 0x44FF44;
            
            // Car body - FIXED: Lowered position
            const bodyGeometry = new THREE.BoxGeometry(2, 0.8, 4); // Lower height
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.5,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 0.4; // FIXED: Lowered car body
            group.add(body);
            
            // Roof
            const roofGeometry = new THREE.BoxGeometry(1.5, 0.4, 1.8);
            const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
            roof.position.y = 0.8; // Adjusted for lower body
            roof.position.z = -0.2;
            roof.castShadow = true;
            group.add(roof);
            
            // FIXED: Wheels positioned at ground level
            const wheelGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 12);
            const wheelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.8,
                metalness: 0.5
            });
            
            const wheelPositions = [
                [-0.8, 0.15, 1.2],   // Front left
                [0.8, 0.15, 1.2],    // Front right
                [-0.8, 0.15, -1.2],  // Rear left
                [0.8, 0.15, -1.2]    // Rear right
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.castShadow = true;
                group.add(wheel);
            });
            
            // Add contact shadow under each wheel
            const shadowTexture = createContactShadowTexture();
            const shadowMaterial = new THREE.MeshBasicMaterial({
                map: shadowTexture,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
            
            const shadowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            shadowGeometry.rotateX(-Math.PI / 2);
            
            const shadowPositions = [
                [-0.8, 0.01, 1.2],
                [0.8, 0.01, 1.2],
                [-0.8, 0.01, -1.2],
                [0.8, 0.01, -1.2]
            ];
            
            shadowPositions.forEach(pos => {
                const contactShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
                contactShadow.position.set(pos[0], pos[1], pos[2]);
                contactShadow.renderOrder = -1; // Render before other objects
                group.add(contactShadow);
            });
            
            return group;
        }
        
        // ====================
        // CAR CREATION WITH PROPER POSITIONING
        // ====================
        function createPlayerCar() {
            if (!gameState.playerModel) return;
            
            gameState.playerCar = gameState.playerModel.clone();
            
            // FIXED: Car positioned correctly on road surface
            // Y-position at 0.15 so wheels touch ground at y=0.01
            gameState.playerCar.position.set(
                getLaneCenter(gameState.currentLane),
                0.15, // FIXED: Lowered to ground level
                0
            );
            
            gameState.playerCar.scale.set(1, 1, 1);
            scene.add(gameState.playerCar);
        }
        
        function createEnemyCar() {
            if (!gameState.assetsLoaded || !gameState.enemyModel || 
                gameState.enemies.length >= CONFIG.MAX_ENEMIES || 
                !gameState.playerCar) return;
            
            const enemyCar = gameState.enemyModel.clone();
            const laneIndex = Math.floor(Math.random() * CONFIG.NUM_LANES);
            const distanceBehind = 20 + Math.random() * 40;
            
            // FIXED: Proper Y-positioning for enemy cars
            enemyCar.position.set(
                getLaneCenter(laneIndex),
                0.15, // Same as player car
                gameState.playerCar.position.z - distanceBehind
            );
            
            enemyCar.userData = {
                lane: laneIndex,
                // FIXED: Faster enemy speeds
                speed: gameState.speed * (1.0 + Math.random() * 0.3),
                type: 'enemy'
            };
            
            enemyCar.scale.set(1, 1, 1);
            scene.add(enemyCar);
            gameState.enemies.push(enemyCar);
            
            updateUI();
        }
        
        function createNPCCar() {
            if (!gameState.assetsLoaded || !gameState.npcModel || 
                gameState.npcs.length >= CONFIG.MAX_NPCS || 
                !gameState.playerCar) return;
            
            const npcCar = gameState.npcModel.clone();
            const laneIndex = Math.floor(Math.random() * CONFIG.NUM_LANES);
            const distanceBehind = 15 + Math.random() * 60;
            
            // FIXED: Proper Y-positioning for NPC cars
            npcCar.position.set(
                getLaneCenter(laneIndex),
                0.15, // Same as player car
                gameState.playerCar.position.z - distanceBehind
            );
            
            npcCar.userData = {
                lane: laneIndex,
                // FIXED: Varied NPC speeds
                speed: gameState.speed * (0.6 + Math.random() * 0.8),
                type: 'npc'
            };
            
            npcCar.scale.set(1, 1, 1);
            scene.add(npcCar);
            gameState.npcs.push(npcCar);
        }
        
        // ====================
        // LANE SYSTEM
        // ====================
        function updatePlayerLane() {
            if (!gameState.playerCar) return;
            
            const currentX = gameState.playerCar.position.x;
            const targetX = getLaneCenter(gameState.targetLane);
            
            if (Math.abs(currentX - targetX) > 0.01) {
                const newX = THREE.MathUtils.lerp(currentX, targetX, CONFIG.LANE_CHANGE_SPEED);
                gameState.playerCar.position.x = newX;
            } else {
                gameState.currentLane = gameState.targetLane;
                updateUI();
            }
        }
        
        // ====================
        // UPDATE FUNCTIONS
        // ====================
        function updatePlayer(delta) {
            if (!gameState.playerCar || gameState.gameOver) return;
            
            updatePlayerLane();
            updateRoadSystem(delta);
            
            // FIXED: Player car stays at origin, road moves underneath
            // This creates the illusion of forward movement
            gameState.playerCar.position.z = 0;
            
            updateUI();
        }
        
        function updateEnemies(delta) {
            if (!gameState.playerCar) return;
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // AI: Occasionally change lanes
                if (Math.random() < 0.005) {
                    const newLane = Math.floor(Math.random() * CONFIG.NUM_LANES);
                    enemy.userData.lane = newLane;
                }
                
                const currentX = enemy.position.x;
                const targetX = getLaneCenter(enemy.userData.lane);
                
                if (Math.abs(currentX - targetX) > 0.1) {
                    const newX = THREE.MathUtils.lerp(currentX, targetX, 0.05);
                    enemy.position.x = newX;
                }
                
                // FIXED: Enemies move relative to player
                // Negative Z movement = forward (since car faces -Z)
                enemy.position.z -= CONFIG.getSpeedInMps(enemy.userData.speed - gameState.speed) * delta;
                
                // Remove enemies that are far behind
                if (enemy.position.z < gameState.playerCar.position.z - 100) {
                    scene.remove(enemy);
                    gameState.enemies.splice(i, 1);
                    updateUI();
                }
                
                if (checkCollision(gameState.playerCar, enemy)) {
                    gameOver();
                }
            }
        }
        
        function updateNPCs(delta) {
            if (!gameState.playerCar) return;
            
            for (let i = gameState.npcs.length - 1; i >= 0; i--) {
                const npc = gameState.npcs[i];
                
                // FIXED: NPCs move relative to player
                npc.position.z -= CONFIG.getSpeedInMps(npc.userData.speed - gameState.speed) * delta;
                
                if (npc.position.z < gameState.playerCar.position.z - 100) {
                    scene.remove(npc);
                    gameState.npcs.splice(i, 1);
                }
                
                if (checkCollision(gameState.playerCar, npc)) {
                    // FIXED: Realistic collision effect
                    gameState.speed = Math.max(30, gameState.speed * 0.6);
                    scene.remove(npc);
                    gameState.npcs.splice(i, 1);
                    updateUI();
                }
            }
        }
        
        function checkCollision(car1, car2) {
            const dx = car1.position.x - car2.position.x;
            const dz = car1.position.z - car2.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            return distance < 2.0;
        }
        
        function updateCamera() {
            if (!gameState.playerCar) return;
            
            // FIXED: Camera positioned lower and tilted down more
            const cameraDistance = 12;
            const cameraHeight = 4; // Lower camera
            const lookAhead = 15;
            
            camera.position.x = gameState.playerCar.position.x;
            camera.position.y = cameraHeight;
            camera.position.z = gameState.playerCar.position.z + cameraDistance;
            
            // Look at a point lower and closer to create downward tilt
            camera.lookAt(
                gameState.playerCar.position.x,
                gameState.playerCar.position.y + 0.5, // Lower lookAt point
                gameState.playerCar.position.z - lookAhead
            );
        }
        
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('speed').textContent = `${Math.round(gameState.speed)} km/h`;
            document.getElementById('distance').textContent = `${Math.round(gameState.distance)} m`;
            document.getElementById('enemies').textContent = gameState.enemies.length;
            document.getElementById('lane').textContent = gameState.currentLane + 1;
            
            const speedPercent = (gameState.speed / CONFIG.MAX_SPEED) * 100;
            document.getElementById('speedFill').style.width = `${speedPercent}%`;
        }
        
        function spawnCars() {
            if (!gameState.assetsLoaded) return;
            
            const now = Date.now();
            
            if (now - gameState.lastEnemySpawn > CONFIG.ENEMY_SPAWN_INTERVAL) {
                createEnemyCar();
                gameState.lastEnemySpawn = now;
                CONFIG.ENEMY_SPAWN_INTERVAL = Math.max(1000, 2000 - gameState.score * 8);
            }
            
            if (now - gameState.lastNPCSpawn > CONFIG.NPC_SPAWN_INTERVAL) {
                createNPCCar();
                gameState.lastNPCSpawn = now;
            }
        }
        
        // ====================
        // INPUT HANDLING WITH REALISTIC PHYSICS
        // ====================
        function setupEventListeners() {
            const keys = {};
            
            document.addEventListener('keydown', (e) => {
                if (gameState.gameOver) return;
                
                keys[e.key.toLowerCase()] = true;
                
                // Lane changes
                if (e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 'arrowleft') {
                    gameState.targetLane = Math.max(0, gameState.targetLane - 1);
                }
                if (e.key.toLowerCase() === 'd' || e.key.toLowerCase() === 'arrowright') {
                    gameState.targetLane = Math.min(CONFIG.NUM_LANES - 1, gameState.targetLane + 1);
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // Continuous input handling
            function handleContinuousInput(delta) {
                if (gameState.gameOver) return;
                
                // FIXED: Much faster acceleration
                if (keys['w'] || keys['arrowup']) {
                    gameState.speed = Math.min(
                        CONFIG.MAX_SPEED,
                        gameState.speed + CONFIG.ACCELERATION_RATE * delta
                    );
                }
                
                // FIXED: Strong braking
                if (keys['s'] || keys['arrowdown']) {
                    gameState.speed = Math.max(
                        0,
                        gameState.speed - CONFIG.DECELERATION_RATE * delta
                    );
                }
                
                // Natural deceleration when no input
                if (!keys['w'] && !keys['arrowup'] && !keys['s'] && !keys['arrowdown']) {
                    gameState.speed = Math.max(
                        CONFIG.INITIAL_SPEED * 0.5,
                        gameState.speed - (CONFIG.ACCELERATION_RATE * 0.2) * delta
                    );
                }
            }
            
            // Store function for animation loop
            window.handleContinuousInput = handleContinuousInput;
            
            window.addEventListener('gamepadconnected', (e) => {
                gameState.gamepad = e.gamepad;
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function updateGamepadInput(delta) {
            if (!gameState.gamepad) return;
            
            const gamepad = navigator.getGamepads()[gameState.gamepad.index];
            if (!gamepad) return;
            
            const stickX = gamepad.axes[0];
            if (stickX < -0.5) {
                gameState.targetLane = Math.max(0, gameState.targetLane - 1);
            } else if (stickX > 0.5) {
                gameState.targetLane = Math.min(CONFIG.NUM_LANES - 1, gameState.targetLane + 1);
            }
            
            const acceleration = gamepad.buttons[7].value;
            if (acceleration > 0.1) {
                gameState.speed = Math.min(
                    CONFIG.MAX_SPEED,
                    gameState.speed + (CONFIG.ACCELERATION_RATE * 2) * acceleration * delta
                );
            }
            
            const brake = gamepad.buttons[6].value;
            if (brake > 0.1) {
                gameState.speed = Math.max(
                    0,
                    gameState.speed - (CONFIG.DECELERATION_RATE * 2) * brake * delta
                );
            }
        }
        
        // ====================
        // GAME FLOW
        // ====================
        function gameOver() {
            gameState.gameOver = true;
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalDistance').textContent = `${Math.round(gameState.distance)} m`;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            gameState = {
                score: 0,
                distance: 0,
                speed: CONFIG.INITIAL_SPEED,
                currentLane: 2,
                targetLane: 2,
                gameOver: false,
                playerCar: gameState.playerCar,
                enemies: [],
                npcs: [],
                playerModel: gameState.playerModel,
                enemyModel: gameState.enemyModel,
                npcModel: gameState.npcModel,
                assetsLoaded: true,
                lastEnemySpawn: 0,
                lastNPCSpawn: 0,
                gamepad: gameState.gamepad,
                roadSegments: gameState.roadSegments,
                groundSegments: gameState.groundSegments,
                roadOffset: 0
            };
            
            gameState.enemies.forEach(enemy => scene.remove(enemy));
            gameState.npcs.forEach(npc => scene.remove(npc));
            
            if (gameState.playerCar) {
                gameState.playerCar.position.set(
                    getLaneCenter(gameState.currentLane),
                    0.15,
                    0
                );
            }
            
            // Reset road positions
            gameState.roadSegments.forEach((segment, index) => {
                segment.position.z = index * CONFIG.ROAD_LENGTH - CONFIG.ROAD_LENGTH;
                segment.material.map.offset.set(0, 0);
            });
            
            gameState.groundSegments.forEach((segment, index) => {
                segment.position.z = index * CONFIG.ROAD_LENGTH - CONFIG.ROAD_LENGTH;
                segment.material.map.offset.set(0, 0);
            });
            
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }
        
        // ====================
        // ANIMATION LOOP
        // ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1);
            
            if (gameState.gameOver) return;
            
            // Handle continuous keyboard input
            if (window.handleContinuousInput) {
                window.handleContinuousInput(delta);
            }
            
            updateGamepadInput(delta);
            spawnCars();
            updatePlayer(delta);
            updateEnemies(delta);
            updateNPCs(delta);
            updateCamera();
            
            renderer.render(scene, camera);
        }
        
        // ====================
        // START THE GAME
        // ====================
        init().catch(console.error);
        
        window.restartGame = restartGame;
    </script>
</body>
</html>
