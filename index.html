<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless 3D Delivery Drive</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #111;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #game-container {
            flex: 1;
            position: relative;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        #score {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #speed {
            font-size: 20px;
            margin-bottom: 5px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
            pointer-events: none;
        }
        
        #gamepad-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            display: none;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .key {
            display: inline-block;
            background: #333;
            padding: 3px 8px;
            margin: 0 5px;
            border-radius: 4px;
            min-width: 30px;
            text-align: center;
            font-weight: bold;
            color: #fff;
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            display: none;
            box-shadow: 0 0 30px rgba(0, 100, 200, 0.5);
        }
        
        #game-over h2 {
            font-size: 40px;
            color: #f44;
            margin-bottom: 20px;
        }
        
        #final-score {
            font-size: 28px;
            margin-bottom: 25px;
        }
        
        #restart-btn {
            background: #4a8;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #restart-btn:hover {
            background: #5b9;
            transform: scale(1.05);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            z-index: 300;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui">
        <div id="score">SCORE: 0</div>
        <div id="speed">SPEED: 0 km/h</div>
        <div id="lives">LIVES: 3</div>
    </div>
    
    <div id="gamepad-status">Gamepad Connected</div>
    
    <div id="controls">
        <div class="control-row"><span class="key">W</span> / <span class="key">↑</span> : Accelerate</div>
        <div class="control-row"><span class="key">S</span> / <span class="key">↓</span> : Brake</div>
        <div class="control-row"><span class="key">A</span> / <span class="key">←</span> : Move Left Lane</div>
        <div class="control-row"><span class="key">D</span> / <span class="key">→</span> : Move Right Lane</div>
        <div class="control-row">Gamepad: Left Stick / D-Pad for steering, Triggers for acceleration/brake</div>
    </div>
    
    <div id="game-over">
        <h2>GAME OVER</h2>
        <div id="final-score">Final Score: 0</div>
        <button id="restart-btn">RESTART GAME</button>
    </div>
    
    <div id="loading">Loading game...</div>

    <script>
        // ==================== GAME INITIALIZATION ====================
        document.getElementById('loading').style.display = 'block';
        
        // Global variables
        let scene, camera, renderer, roadCurve, roadMesh, playerCar, clock;
        let playerPosition = 0; // Position along the curve
        let playerSpeed = 0;
        let targetLane = 0; // -1: left, 0: center, 1: right
        let currentLane = 0;
        let laneChangeSpeed = 0.1;
        let score = 0;
        let lives = 3;
        let gameRunning = true;
        let keys = {};
        let bots = [];
        let buildings = [];
        let roadSegments = [];
        let curvePoints = [];
        let lastPointIndex = 0;
        let cameraShake = 0;
        
        // Game constants
        const ROAD_WIDTH = 12;
        const LANE_WIDTH = ROAD_WIDTH / 3;
        const ROAD_LENGTH = 2000; // Length of the road segment we keep in memory
        const SEGMENT_LENGTH = 50; // Distance between curve points
        const NUM_SEGMENTS = Math.ceil(ROAD_LENGTH / SEGMENT_LENGTH);
        const INITIAL_PLAYER_SPEED = 20;
        const MAX_SPEED = 120;
        const ACCELERATION = 0.05;
        const BOT_SPEED = 18;
        const CURVE_INTENSITY = 80;
        const HILL_INTENSITY = 40;
        
        // ==================== THREE.JS SETUP ====================
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x88aadd, 100, 800);
            
            // Create camera (third-person)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 10, -20);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Create clock for timing
            clock = new THREE.Clock();
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Initialize road curve points
            initRoadCurve();
            
            // Create the road mesh
            createRoad();
            
            // Create player car
            createPlayerCar();
            
            // Create initial buildings
            createBuildings();
            
            // Create initial bots
            for (let i = 0; i < 3; i++) {
                createBot(i * 50 + 100);
            }
            
            // Start game loop
            animate();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
        }
        
        // ==================== PROCEDURAL ROAD GENERATION ====================
        // This is the core of the game - generating a continuous, endless road without gaps
        function initRoadCurve() {
            curvePoints = [];
            
            // Create initial straight road segment
            for (let i = 0; i < NUM_SEGMENTS; i++) {
                const z = i * SEGMENT_LENGTH;
                curvePoints.push(new THREE.Vector3(0, 0, z));
            }
            
            // Update the curve to add procedural features
            updateRoadCurve();
        }
        
        function updateRoadCurve() {
            // We'll generate the road ahead based on where the player is
            const playerSegment = Math.floor(playerPosition / SEGMENT_LENGTH);
            const segmentsToGenerate = 10; // Number of segments to generate ahead
            
            // Ensure we have enough curve points ahead of the player
            while (lastPointIndex < playerSegment + segmentsToGenerate) {
                lastPointIndex++;
                
                // Get the last few points for curve continuity
                const prevIndex = Math.max(0, curvePoints.length - 4);
                const prevPoints = curvePoints.slice(prevIndex);
                
                // Procedural generation parameters
                // Use sine waves with different frequencies for natural-looking road
                const t = lastPointIndex * 0.1;
                
                // Horizontal curve (turns)
                const curveX = Math.sin(t * 0.3) * Math.cos(t * 0.12) * CURVE_INTENSITY;
                
                // Vertical curve (hills and dips)
                let curveY = 0;
                
                // Create different road features based on position
                const featureType = Math.floor(t) % 20;
                
                if (featureType === 0) {
                    // Gentle uphill
                    curveY = Math.sin(t * 0.2) * HILL_INTENSITY;
                } else if (featureType === 5) {
                    // Gentle downhill
                    curveY = -Math.sin(t * 0.2) * HILL_INTENSITY * 0.7;
                } else if (featureType === 10) {
                    // Speed bump (sharp upward then downward)
                    const localT = (t * 10) % 1;
                    curveY = Math.sin(localT * Math.PI) * 3;
                } else if (featureType === 15) {
                    // Dip (sharp downward then upward)
                    const localT = (t * 10) % 1;
                    curveY = -Math.sin(localT * Math.PI) * 4;
                }
                
                // Add some randomness to make the road feel organic
                const randomX = (Math.random() - 0.5) * 5;
                const randomY = (Math.random() - 0.5) * 2;
                
                // Calculate new point position
                const z = lastPointIndex * SEGMENT_LENGTH;
                const x = curveX + randomX;
                const y = curveY + randomY;
                
                curvePoints.push(new THREE.Vector3(x, y, z));
            }
            
            // Remove points far behind the player to save memory
            const pointsToKeep = 100;
            if (curvePoints.length > pointsToKeep) {
                const removeCount = curvePoints.length - pointsToKeep;
                curvePoints.splice(0, removeCount);
                lastPointIndex -= removeCount;
            }
            
            // Create the CatmullRom curve from the points
            roadCurve = new THREE.CatmullRomCurve3(curvePoints);
            roadCurve.curveType = 'centripetal';
            roadCurve.tension = 0.5;
        }
        
        function createRoad() {
            if (roadMesh) {
                scene.remove(roadMesh);
                roadMesh.geometry.dispose();
                roadMesh.material.dispose();
            }
            
            // Create road geometry by extruding along the curve
            const roadShape = new THREE.Shape();
            const halfWidth = ROAD_WIDTH / 2;
            roadShape.moveTo(-halfWidth, 0);
            roadShape.lineTo(-halfWidth, -0.1); // Slight depth for visual thickness
            roadShape.lineTo(halfWidth, -0.1);
            roadShape.lineTo(halfWidth, 0);
            roadShape.lineTo(-halfWidth, 0);
            
            // Extrude the shape along the curve
            const extrudeSettings = {
                steps: 200, // Higher for smoother curves
                depth: 0.1,
                bevelEnabled: false,
                extrudePath: roadCurve
            };
            
            const geometry = new THREE.ExtrudeGeometry(roadShape, extrudeSettings);
            
            // Center the geometry
            geometry.center();
            
            // Create road material
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                side: THREE.DoubleSide
            });
            
            // Create lane markings
            const laneMarkingMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            
            // Create the road mesh
            roadMesh = new THREE.Mesh(geometry, material);
            roadMesh.receiveShadow = true;
            roadMesh.castShadow = false;
            scene.add(roadMesh);
            
            // Add lane markings
            addLaneMarkings();
        }
        
        function addLaneMarkings() {
            // Remove old lane markings
            scene.children.filter(child => child.userData.isLaneMarking).forEach(marking => {
                scene.remove(marking);
                marking.geometry.dispose();
                marking.material.dispose();
            });
            
            // Create dashed lane markings
            const laneMarkingMaterial = new THREE.LineDashedMaterial({
                color: 0xffff00,
                dashSize: 3,
                gapSize: 5,
                linewidth: 2
            });
            
            // Create markings for the two lane dividers
            for (let laneOffset = -1; laneOffset <= 1; laneOffset += 2) {
                const points = [];
                const markingOffset = laneOffset * LANE_WIDTH;
                
                // Generate points along the curve
                for (let i = 0; i <= 100; i++) {
                    const t = i / 100;
                    const curvePoint = roadCurve.getPoint(t);
                    const tangent = roadCurve.getTangent(t).normalize();
                    
                    // Calculate perpendicular vector
                    const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // Calculate marking position
                    const markingPos = curvePoint.clone().add(perpendicular.multiplyScalar(markingOffset));
                    
                    // Adjust height slightly above road
                    markingPos.y += 0.1;
                    
                    points.push(markingPos);
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, laneMarkingMaterial);
                line.computeLineDistances(); // Required for dashed lines
                line.userData.isLaneMarking = true;
                scene.add(line);
            }
        }
        
        // ==================== PLAYER CAR ====================
        function createPlayerCar() {
            // Car body
            const carBody = new THREE.BoxGeometry(3, 1, 6);
            const carMaterial = new THREE.MeshLambertMaterial({ color: 0x2266ff });
            const car = new THREE.Mesh(carBody, carMaterial);
            car.castShadow = true;
            
            // Car top
            const carTop = new THREE.BoxGeometry(2.5, 1, 3);
            const carTopMesh = new THREE.Mesh(carTop, carMaterial);
            carTopMesh.position.y = 0.8;
            carTopMesh.position.z = -0.5;
            carTopMesh.castShadow = true;
            car.add(carTopMesh);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 8);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            
            const wheelPositions = [
                { x: 1.5, y: -0.5, z: 2 },
                { x: -1.5, y: -0.5, z: 2 },
                { x: 1.5, y: -0.5, z: -2 },
                { x: -1.5, y: -0.5, z: -2 }
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                car.add(wheel);
            });
            
            // Headlights
            const lightGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            
            const headlight1 = new THREE.Mesh(lightGeometry, lightMaterial);
            headlight1.position.set(0.8, 0.2, 3);
            car.add(headlight1);
            
            const headlight2 = new THREE.Mesh(lightGeometry, lightMaterial);
            headlight2.position.set(-0.8, 0.2, 3);
            car.add(headlight2);
            
            playerCar = new THREE.Group();
            playerCar.add(car);
            playerCar.userData.speed = INITIAL_PLAYER_SPEED;
            playerCar.userData.lane = 0;
            
            scene.add(playerCar);
        }
        
        function updatePlayerCar(deltaTime) {
            if (!gameRunning) return;
            
            // Update player position along the curve
            playerPosition += playerSpeed * deltaTime;
            
            // Update the road curve as player moves forward
            updateRoadCurve();
            
            // Update road mesh periodically
            if (Math.floor(playerPosition) % 200 < 5) {
                createRoad();
            }
            
            // Get player position on curve
            const curveT = (playerPosition % ROAD_LENGTH) / ROAD_LENGTH;
            const curvePoint = roadCurve.getPoint(curveT);
            const tangent = roadCurve.getTangent(curveT).normalize();
            
            // Calculate perpendicular vector for lane positioning
            const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
            
            // Smooth lane change
            if (Math.abs(currentLane - targetLane) > 0.01) {
                currentLane += (targetLane - currentLane) * laneChangeSpeed;
            }
            
            // Calculate lane offset
            const laneOffset = currentLane * LANE_WIDTH;
            
            // Calculate car position with lane offset
            const carPosition = curvePoint.clone().add(perpendicular.multiplyScalar(laneOffset));
            
            // Set car position
            playerCar.position.copy(carPosition);
            
            // Adjust car height based on road curvature
            const roadNormal = new THREE.Vector3(0, 1, 0);
            playerCar.position.y += 1; // Height above road
            
            // Rotate car to follow road direction
            playerCar.lookAt(playerCar.position.clone().add(tangent));
            
            // Tilt car slightly during turns
            const turnIntensity = perpendicular.dot(new THREE.Vector3(1, 0, 0));
            playerCar.rotation.z = -turnIntensity * 0.1;
            
            // Update player speed
            if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                playerSpeed = Math.min(playerSpeed + ACCELERATION, MAX_SPEED);
            } else if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                playerSpeed = Math.max(playerSpeed - ACCELERATION * 2, 0);
            } else {
                // Natural deceleration
                playerSpeed = Math.max(playerSpeed - ACCELERATION * 0.2, INITIAL_PLAYER_SPEED);
            }
            
            // Update UI
            document.getElementById('speed').textContent = `SPEED: ${Math.round(playerSpeed)} km/h`;
            document.getElementById('score').textContent = `SCORE: ${Math.round(score)}`;
            document.getElementById('lives').textContent = `LIVES: ${lives}`;
            
            // Update score based on distance
            score += playerSpeed * deltaTime * 0.1;
        }
        
        // ==================== AI BOTS ====================
        function createBot(offsetZ) {
            const botBody = new THREE.BoxGeometry(3, 1, 6);
            const botMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 });
            const bot = new THREE.Mesh(botBody, botMaterial);
            bot.castShadow = true;
            
            // Bot top
            const botTop = new THREE.BoxGeometry(2.5, 1, 3);
            const botTopMesh = new THREE.Mesh(botTop, botMaterial);
            botTopMesh.position.y = 0.8;
            botTopMesh.position.z = -0.5;
            botTopMesh.castShadow = true;
            bot.add(botTopMesh);
            
            const botGroup = new THREE.Group();
            botGroup.add(bot);
            
            // Bot properties
            botGroup.userData = {
                speed: BOT_SPEED + Math.random() * 5,
                offset: offsetZ,
                lane: Math.floor(Math.random() * 3) - 1, // -1, 0, or 1
                lastLaneChange: 0,
                aggro: Math.random() * 0.5 + 0.5 // 0.5 to 1.0
            };
            
            scene.add(botGroup);
            bots.push(botGroup);
        }
        
        function updateBots(deltaTime) {
            for (let i = bots.length - 1; i >= 0; i--) {
                const bot = bots[i];
                
                // Update bot position along curve
                bot.userData.offset += bot.userData.speed * deltaTime;
                
                // Ensure bot is ahead of player
                if (bot.userData.offset < playerPosition - 100) {
                    bot.userData.offset = playerPosition + 50 + Math.random() * 100;
                }
                
                // Get bot position on curve
                const curveT = (bot.userData.offset % ROAD_LENGTH) / ROAD_LENGTH;
                const curvePoint = roadCurve.getPoint(curveT);
                const tangent = roadCurve.getTangent(curveT).normalize();
                
                // Calculate perpendicular vector for lane positioning
                const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // Bot lane changing logic
                bot.userData.lastLaneChange += deltaTime;
                if (bot.userData.lastLaneChange > 3) {
                    // Occasionally change lanes
                    if (Math.random() < 0.02) {
                        const newLane = Math.floor(Math.random() * 3) - 1;
                        // Try to match player's lane if aggressive
                        if (Math.random() < bot.userData.aggro) {
                            if (playerPosition > bot.userData.offset - 30 && playerPosition < bot.userData.offset + 30) {
                                bot.userData.lane = targetLane;
                            }
                        } else {
                            bot.userData.lane = newLane;
                        }
                        bot.userData.lastLaneChange = 0;
                    }
                }
                
                // Calculate lane offset
                const laneOffset = bot.userData.lane * LANE_WIDTH;
                
                // Calculate bot position
                const botPosition = curvePoint.clone().add(perpendicular.multiplyScalar(laneOffset));
                
                // Set bot position
                bot.position.copy(botPosition);
                bot.position.y += 1;
                
                // Rotate bot to follow road
                bot.lookAt(bot.position.clone().add(tangent));
                
                // Check for collision with player
                const distanceToPlayer = Math.abs(bot.userData.offset - playerPosition);
                const lateralDistance = Math.abs(bot.userData.lane - currentLane) * LANE_WIDTH;
                
                if (distanceToPlayer < 5 && lateralDistance < 2.5) {
                    // Collision detected
                    handleCollision();
                    // Remove the bot after collision
                    scene.remove(bot);
                    bots.splice(i, 1);
                    
                    // Create a new bot ahead
                    createBot(playerPosition + 100 + Math.random() * 100);
                }
                
                // Remove bots that are too far behind
                if (bot.userData.offset < playerPosition - 200) {
                    scene.remove(bot);
                    bots.splice(i, 1);
                }
            }
            
            // Add new bots as score increases
            const targetBotCount = 3 + Math.floor(score / 1000);
            if (bots.length < targetBotCount) {
                createBot(playerPosition + 100 + Math.random() * 200);
            }
        }
        
        // ==================== BUILDINGS ====================
        function createBuildings() {
            // Remove old buildings
            buildings.forEach(building => {
                scene.remove(building);
                building.geometry.dispose();
                building.material.dispose();
            });
            buildings = [];
            
            // Create buildings along the road
            for (let i = 0; i < 50; i++) {
                // Get position along curve
                const t = i / 50;
                const curvePoint = roadCurve.getPoint(t);
                const tangent = roadCurve.getTangent(t).normalize();
                
                // Calculate perpendicular vector
                const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // Create buildings on both sides of the road
                for (let side = -1; side <= 1; side += 2) {
                    // Random distance from road
                    const distance = 20 + Math.random() * 30;
                    
                    // Calculate building position
                    const buildingPos = curvePoint.clone().add(
                        perpendicular.multiplyScalar(side * (ROAD_WIDTH/2 + distance))
                    );
                    
                    // Random building size
                    const width = 5 + Math.random() * 10;
                    const height = 10 + Math.random() * 30;
                    const depth = 5 + Math.random() * 10;
                    
                    // Create building geometry
                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    
                    // Random building color
                    const hue = Math.random() * 0.1 + 0.5; // Brownish colors
                    const color = new THREE.Color().setHSL(hue, 0.3, 0.3 + Math.random() * 0.2);
                    
                    const buildingMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    
                    // Position building
                    building.position.copy(buildingPos);
                    building.position.y = height / 2;
                    
                    // Add some rotation for variety
                    building.rotation.y = Math.random() * Math.PI;
                    
                    building.castShadow = true;
                    building.receiveShadow = true;
                    
                    scene.add(building);
                    buildings.push(building);
                }
            }
        }
        
        // ==================== CAMERA ====================
        function updateCamera(deltaTime) {
            if (!playerCar) return;
            
            // Get player position on curve
            const curveT = (playerPosition % ROAD_LENGTH) / ROAD_LENGTH;
            const curvePoint = roadCurve.getPoint(curveT);
            const tangent = roadCurve.getTangent(curveT).normalize();
            
            // Calculate perpendicular vector
            const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
            
            // Calculate lane offset
            const laneOffset = currentLane * LANE_WIDTH;
            
            // Calculate target position (behind and above the car)
            const carPosition = curvePoint.clone().add(perpendicular.multiplyScalar(laneOffset));
            const cameraOffset = new THREE.Vector3(0, 8, -15);
            
            // Apply camera shake from bumps and dips
            if (cameraShake > 0) {
                cameraOffset.x += (Math.random() - 0.5) * cameraShake;
                cameraOffset.y += (Math.random() - 0.5) * cameraShake;
                cameraShake *= 0.9; // Dampen shake over time
            }
            
            // Transform offset to follow car orientation
            cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerCar.rotation.y);
            
            const targetPosition = carPosition.clone().add(cameraOffset);
            targetPosition.y += 5; // Additional height
            
            // Smooth camera movement
            camera.position.lerp(targetPosition, 0.1);
            
            // Make camera look slightly ahead of the car
            const lookAtPosition = carPosition.clone().add(tangent.multiplyScalar(30));
            lookAtPosition.y += 3;
            camera.lookAt(lookAtPosition);
        }
        
        // ==================== GAME LOGIC ====================
        function handleCollision() {
            lives--;
            cameraShake = 2; // Big camera shake on collision
            
            if (lives <= 0) {
                gameOver();
            } else {
                // Slow down after collision
                playerSpeed *= 0.5;
            }
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('final-score').textContent = `Final Score: ${Math.round(score)}`;
            document.getElementById('game-over').style.display = 'block';
        }
        
        function restartGame() {
            // Reset game state
            playerPosition = 0;
            playerSpeed = INITIAL_PLAYER_SPEED;
            targetLane = 0;
            currentLane = 0;
            score = 0;
            lives = 3;
            gameRunning = true;
            cameraShake = 0;
            
            // Remove all bots
            bots.forEach(bot => scene.remove(bot));
            bots = [];
            
            // Remove all buildings
            buildings.forEach(building => scene.remove(building));
            buildings = [];
            
            // Reinitialize road
            lastPointIndex = 0;
            initRoadCurve();
            createRoad();
            
            // Create new bots
            for (let i = 0; i < 3; i++) {
                createBot(i * 50 + 100);
            }
            
            // Create new buildings
            createBuildings();
            
            // Hide game over screen
            document.getElementById('game-over').style.display = 'none';
        }
        
        // ==================== INPUT HANDLING ====================
        function setupInput() {
            // Keyboard input
            document.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                
                // Lane changes
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                    targetLane = Math.max(targetLane - 1, -1);
                }
                if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                    targetLane = Math.min(targetLane + 1, 1);
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Gamepad support
            let gamepadIndex = null;
            
            function gamepadHandler() {
                const gamepads = navigator.getGamepads();
                if (!gamepads) return;
                
                let gamepad = null;
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i] && gamepads[i].connected) {
                        gamepad = gamepads[i];
                        gamepadIndex = i;
                        break;
                    }
                }
                
                if (gamepad) {
                    document.getElementById('gamepad-status').style.display = 'block';
                    
                    // Left stick or D-pad for steering
                    const axisX = gamepad.axes[0] || 0;
                    const buttons = gamepad.buttons;
                    
                    // Lane change with gamepad
                    if (axisX < -0.5) {
                        targetLane = Math.max(targetLane - 0.1, -1);
                    } else if (axisX > 0.5) {
                        targetLane = Math.min(targetLane + 0.1, 1);
                    }
                    
                    // Acceleration/brake with triggers or buttons
                    if (buttons[7] && buttons[7].value > 0.5) {
                        playerSpeed = Math.min(playerSpeed + ACCELERATION * 2, MAX_SPEED);
                    }
                    if (buttons[6] && buttons[6].value > 0.5) {
                        playerSpeed = Math.max(playerSpeed - ACCELERATION * 3, 0);
                    }
                    
                    // Face buttons for acceleration/brake (alternate controls)
                    if (buttons[0] && buttons[0].pressed) {
                        playerSpeed = Math.min(playerSpeed + ACCELERATION, MAX_SPEED);
                    }
                    if (buttons[1] && buttons[1].pressed) {
                        playerSpeed = Math.max(playerSpeed - ACCELERATION * 2, 0);
                    }
                } else {
                    document.getElementById('gamepad-status').style.display = 'none';
                }
            }
            
            // Check for gamepad connection
            window.addEventListener("gamepadconnected", (e) => {
                console.log("Gamepad connected:", e.gamepad.id);
                gamepadIndex = e.gamepad.index;
            });
            
            window.addEventListener("gamepaddisconnected", (e) => {
                console.log("Gamepad disconnected:", e.gamepad.id);
                if (gamepadIndex === e.gamepad.index) {
                    gamepadIndex = null;
                }
            });
            
            // Add gamepad polling to animation loop
            const originalAnimate = animate;
            animate = function() {
                gamepadHandler();
                originalAnimate();
            };
            
            // Restart button
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // ==================== GAME LOOP ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min(clock.getDelta(), 0.033); // Cap at 30 FPS for consistency
            
            if (gameRunning) {
                // Update game elements
                updatePlayerCar(deltaTime);
                updateBots(deltaTime);
                updateCamera(deltaTime);
                
                // Detect road features for camera shake
                const curveT = (playerPosition % ROAD_LENGTH) / ROAD_LENGTH;
                const curvePoint = roadCurve.getPoint(curveT);
                
                // Check if we're on a bump or dip (by analyzing road curvature)
                const sampleAhead = roadCurve.getPoint((curveT + 0.01) % 1);
                const verticalChange = Math.abs(sampleAhead.y - curvePoint.y);
                
                if (verticalChange > 0.5) {
                    cameraShake = verticalChange * 0.5;
                }
            }
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // ==================== START GAME ====================
        // Initialize game when page loads
        window.addEventListener('load', () => {
            init();
            setupInput();
        });
    </script>
</body>
</html>
